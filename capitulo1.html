<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>shared-macros</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>



<div id="collapsiblemenu">
  <button class="collapsible">
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
  </button>
  <div class="content">
    <ul>
    <li><a href="index.html">Home</a></li>
    </ul>
    <ul>
    <li><a href="#introducción">1 Introducción</a>
    <ul>
    <li><a href="#datos-numéricos">Datos numéricos</a></li>
    <li><a href="#datos-lógicos">Datos lógicos</a></li>
    <li><a href="#strings">Strings</a></li>
    <li><a href="#listas">Listas</a></li>
    <li><a href="#funciones-predefinidas">Funciones predefinidas</a></li>
    <li><a href="#funciones">Funciones</a></li>
    <li><a href="#expresiones-condicionales">Expresiones condicionales</a></li>
    <li><a href="#diccionarios">Diccionarios</a></li>
    <li><a href="#instrucción-condicional-if">Instrucción condicional: if</a></li>
    <li><a href="#instrucciones-iterativas-for">Instrucciones iterativas: for</a></li>
    <li><a href="#instrucciones-iterativas-while">Instrucciones iterativas: while</a></li>
    <li><a href="#ejemplo-de-programación-con-invariantes-particionar-un-conjunto">Ejemplo de programación con invariantes: particionar un conjunto</a></li>
    <li><a href="#ejemplo-de-programación-con-invariantes-calcular-y-xn">Ejemplo de programación con invariantes: Calcular <span class="math inline">y = x^n</span></a></li>
    <li><a href="#ejemplo-de-programación-con-invariantes-evaluación-de-un-polinomio">Ejemplo de programación con invariantes: Evaluación de un polinomio</a></li>
    <li><a href="#numpy-y-arreglos">Numpy y Arreglos</a></li>
    <li><a href="#ejemplos-de-programación-con-invariantes-ordenación">Ejemplos de programación con invariantes: Ordenación</a></li>
    <li><a href="#ordenación-por-inserción">Ordenación por inserción</a></li>
    <li><a href="#ordenación-por-selección">Ordenación por Selección</a></li>
    <li><a href="#ordenación-de-la-burbuja">Ordenación de la Burbuja</a></li>
    <li><a href="#recursividad">Recursividad</a></li>
    <li><a href="#ejemplo-calcular-yxn">Ejemplo: Calcular <span class="math inline">y=x^n</span></a></li>
    <li><a href="#recursividad-vs.-iteración">Recursividad vs. Iteración</a></li>
    <li><a href="#ejemplo-torres-de-hanoi">Ejemplo: Torres de Hanoi</a></li>
    <li><a href="#diagramas-de-estados">Diagramas de Estados</a></li>
    <li><a href="#ejemplo-contar-palabras">Ejemplo: Contar palabras</a></li>
    </ul></li>
    </ul>
  </div>
</div>


<section id="introducción" class="level1">
<h1>1 Introducción</h1>
<p>El objetivo de este capítulo es ver los conceptos básicos de programación que luego utilizaremos a lo largo de todo el curso. Esto incluye ver tanto los datos que vamos a manejar, como las instrucciones que operan sobre ellos, así como las técnicas básicas de programación. Para la implementación de los algoritmos que vamos a ver utilizaremos el lenguaje Python, sin perjuicio de que los conceptos que veremos son independientes del lenguaje específico utilizado.</p>
<p>En primer lugar, veremos algunos de los tipos de datos básicos de Python. Las variables cambian de tipo dinámicamente según el tipo del valor que tengan en un instante dado.</p>
<section id="datos-numéricos" class="level2">
<h2>Datos numéricos</h2>
<p>Python distingue entre números enteros (<code>int</code>) y números de punto flotante (<code>float</code>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">5</span> <span class="co"># int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n, <span class="bu">type</span>(n))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>x<span class="op">=</span><span class="fl">3.14</span> <span class="co"># float</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x, <span class="bu">type</span>(x))</span></code></pre></div>
<pre><code>5 &lt;class &#39;int&#39;&gt;
3.14 &lt;class &#39;float&#39;&gt;</code></pre>
<p>Sobre estos datos se pueden ejecutar las operaciones aritméticas habituales.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n<span class="op">/</span><span class="dv">2</span>) <span class="co"># noten la diferencia con Python 2.7</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n<span class="op">//</span><span class="dv">2</span>) <span class="co"># división entera</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>6
2.5
2
9.8596</code></pre>
</section>
<section id="datos-lógicos" class="level2">
<h2>Datos lógicos</h2>
<p>Los valores de verdad son <code>True</code> y <code>False</code>. Las operaciones lógicas se indican con palabras en lugar de símbolos.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>t<span class="op">=</span><span class="va">True</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">=</span><span class="va">False</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(t <span class="kw">and</span> f)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(t <span class="kw">and</span> <span class="kw">not</span> f)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n<span class="op">&gt;</span><span class="dv">0</span>)</span></code></pre></div>
<pre><code>False
True
True</code></pre>
</section>
<section id="strings" class="level2">
<h2>Strings</h2>
<p>Los strings se escriben entre comillas simples o dobles, y existen muchas operaciones definidas para ellos.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>h<span class="op">=</span><span class="st">&quot;Hola&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(h)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(h))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>m<span class="op">=</span><span class="st">&#39;mundo&#39;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(h <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> m)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(h.upper())</span></code></pre></div>
<pre><code>Hola
4
Hola mundo
HOLA</code></pre>
</section>
<section id="listas" class="level2">
<h2>Listas</h2>
<p>Una lista es una secuencia de datos, posiblemente de distintos tipos, de largo variable.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>L<span class="op">=</span>[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>L.append(<span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>x<span class="op">=</span>L.pop()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x)</span></code></pre></div>
<pre><code>[3, 2, 1]
[3, 2, 1, 0]
[3, 2, 1]
0</code></pre>
<p>Los elementos de la lista se indexan partiendo desde cero.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L[<span class="dv">0</span>])</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L[<span class="dv">2</span>])</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L[<span class="op">-</span><span class="dv">1</span>]) <span class="co"># contando desde el extremo derecho</span></span></code></pre></div>
<pre><code>3
1
1</code></pre>
<p>Una lista se puede construir en base a iterar una fórmula:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> [n<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">7</span>)]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C)</span></code></pre></div>
<pre><code>[1, 4, 9, 16, 25, 36]</code></pre>
<p>Una lista se puede recorrer a través de sus subíndices:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(C)):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(C[i])</span></code></pre></div>
<pre><code>1
4
9
16
25
36</code></pre>
<p>O bien iterando sobre los elementos de la lista:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> C:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v)</span></code></pre></div>
<pre><code>1
4
9
16
25
36</code></pre>
</section>
<section id="funciones-predefinidas" class="level2">
<h2>Funciones predefinidas</h2>
<p>Hay funciones que están disponibles para ser utilizadas:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span><span class="dv">3</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>b<span class="op">=</span><span class="dv">4</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span>math.sqrt(a<span class="op">**</span><span class="dv">2</span><span class="op">+</span>b<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code></pre></div>
<pre><code>5.0</code></pre>
</section>
<section id="funciones" class="level2">
<h2>Funciones</h2>
<p>Uno puede definir sus propias funciones:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hipotenusa(a,b):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> math</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    c<span class="op">=</span>math.sqrt(a<span class="op">**</span><span class="dv">2</span><span class="op">+</span>b<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hipotenusa(<span class="dv">3</span>,<span class="dv">4</span>))</span></code></pre></div>
<pre><code>5.0</code></pre>
</section>
<section id="expresiones-condicionales" class="level2">
<h2>Expresiones condicionales</h2>
<p>Una expresión de la forma</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>valor_si_verdadero <span class="cf">if</span> condicion <span class="cf">else</span> valor_si_falso</span></code></pre></div>
<p>permite por ejemplo definir funciones por tramos, como por ejemplo:</p>
<p><span class="math display">
|x| =
\begin{cases}
-x &amp; \text{si } x&lt;0 \\
x &amp; \text{en caso contrario}
\end{cases}
</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> valor_absoluto(x):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>x <span class="cf">if</span> x<span class="op">&lt;</span><span class="dv">0</span> <span class="cf">else</span> x</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(valor_absoluto(<span class="op">-</span><span class="dv">5</span>), valor_absoluto(<span class="dv">5</span>))</span></code></pre></div>
<pre><code>5 5</code></pre>
</section>
<section id="diccionarios" class="level2">
<h2>Diccionarios</h2>
<p>Un diccionario es similar a una lista, pero los elementos se indexan con datos no necesariamente numéricos. Por ejemplo, supongamos que queremos convertir “piedra,” “papel” y “tijera” a una representación numérica 0, 1, 2, respectivamente:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>p_a_n <span class="op">=</span> {<span class="st">&quot;piedra&quot;</span>:<span class="dv">0</span>, <span class="st">&quot;papel&quot;</span>:<span class="dv">1</span>, <span class="st">&quot;tijera&quot;</span>:<span class="dv">2</span>} <span class="co"># para convertir de palabra a número</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(p_a_n[<span class="st">&quot;papel&quot;</span>])</span></code></pre></div>
<pre><code>1</code></pre>
<p>La conversión inversa se puede hacer simplemente con una lista:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>n_a_p <span class="op">=</span> [<span class="st">&quot;piedra&quot;</span>, <span class="st">&quot;papel&quot;</span>, <span class="st">&quot;tijera&quot;</span>] <span class="co"># para convertir de número a palabra</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n_a_p[<span class="dv">1</span>])</span></code></pre></div>
<pre><code>papel</code></pre>
<p>Con esto podemos hacer una función en que el programa juegue “cachipún” contra el usuario:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> juega():</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> random <span class="im">import</span> randint</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    programa<span class="op">=</span>randint(<span class="dv">0</span>,<span class="dv">2</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    usuario<span class="op">=</span>p_a_n[<span class="bu">input</span>(<span class="st">&quot;¿piedra, papel o tijera? &quot;</span>)]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    resultado<span class="op">=</span><span class="st">&quot;Empate&quot;</span> <span class="cf">if</span> programa<span class="op">==</span>usuario <span class="cf">else</span><span class="op">\</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;Gana Usuario&quot;</span> <span class="cf">if</span> (programa<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="dv">3</span><span class="op">==</span>usuario <span class="cf">else</span> <span class="st">&quot;Gana Programa&quot;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Usuario juega&quot;</span>, n_a_p[usuario])</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Programa juega&quot;</span>, n_a_p[programa])</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Resultado:&quot;</span>, resultado)</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>juega()</span></code></pre></div>
<pre><code>¿piedra, papel o tijera? piedra
Usuario juega piedra
Programa juega tijera
Resultado: Gana Usuario</code></pre>
</section>
<section id="instrucción-condicional-if" class="level2">
<h2>Instrucción condicional: if</h2>
<p>La instrucción <code>if</code> permite elegir entre distintas alternativas de instrucciones a ejecutar.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encontrar el máximo entre dos valores</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max2(a, b):</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a<span class="op">&gt;</span>b:</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>        m<span class="op">=</span>a</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        m<span class="op">=</span>b</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max2(<span class="dv">3</span>,<span class="dv">7</span>))</span></code></pre></div>
<pre><code>7</code></pre>
<p>Esto se puede generalizar a 3 valores, pero el resultado no es muy elegante:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encontrar el máximo entre tres valores</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max3(a, b, c):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a<span class="op">&gt;</span>b:</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a<span class="op">&gt;</span>c:</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>            m<span class="op">=</span>a</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>            m<span class="op">=</span>c</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> b<span class="op">&gt;</span>c:</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>            m<span class="op">=</span>b</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            m<span class="op">=</span>c</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max3(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">7</span>))</span></code></pre></div>
<pre><code>7</code></pre>
<p>Una mejor alternativa la podemos obtener si vamos obteniendo aproximaciones sucesivas al máximo:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encontrar el máximo entre dos valores</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max2(a, b):</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span>a</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b<span class="op">&gt;</span>m:</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        m<span class="op">=</span>b</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max2(<span class="dv">3</span>,<span class="dv">7</span>))</span></code></pre></div>
<pre><code>7</code></pre>
<p>Esto se generaliza de manera mucho más simple a tres (o más) valores:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encontrar el máximo entre tres valores</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max3(a, b, c):</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span>a</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b<span class="op">&gt;</span>m:</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        m<span class="op">=</span>b</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> c<span class="op">&gt;</span>m:</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>        m<span class="op">=</span>c</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max3(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">7</span>))</span></code></pre></div>
<pre><code>7</code></pre>
<p>Cuando hay preguntas encadenadas, se puede usar la cláusula <code>elif</code> (abreviatura de <code>else if</code>, pero que no abre un nuevo nivel de indentación):</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dice si un año dado es bisiesto</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> es_bisiesto(a):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a<span class="op">%</span><span class="dv">400</span><span class="op">==</span><span class="dv">0</span>:   <span class="co"># Los múltiplos de 400 siempre son bisiestos</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        b<span class="op">=</span><span class="va">True</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a<span class="op">%</span><span class="dv">100</span><span class="op">==</span><span class="dv">0</span>: <span class="co"># Los demás múltiplos de 100 no son bisiestos</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        b<span class="op">=</span><span class="va">False</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a<span class="op">%</span><span class="dv">4</span><span class="op">==</span><span class="dv">0</span>:   <span class="co"># De los restantes, los múltiplos de 4 son bisiestos</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>        b<span class="op">=</span><span class="va">True</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:          <span class="co"># Cualquier otro año no es bisiesto</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>        b<span class="op">=</span><span class="va">False</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(es_bisiesto(<span class="dv">1900</span>), es_bisiesto(<span class="dv">2000</span>), es_bisiesto(<span class="dv">2020</span>))</span></code></pre></div>
<pre><code>False True True</code></pre>
</section>
<section id="instrucciones-iterativas-for" class="level2">
<h2>Instrucciones iterativas: for</h2>
<p>La instrucción <code>for</code> itera con una variable que toma valores de una lista dada. A menudo, esa lista se especifica mediante <code>range</code>. Ilustraremos su uso generalizando los algoritmos que vimos antes para encontrar el máximo de un conjunto de dos o tres números, al caso de un conjunto con un número cualquiera de elementos:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encuentra el máximo de una lista a</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximo(a):</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span>a[<span class="dv">0</span>]</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Al comenzar cada iteración, se cumple que m==max(a[0],...,a[k-1])</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(a)):</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[k]<span class="op">&gt;</span>m:</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            m<span class="op">=</span>a[k]</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maximo([<span class="dv">25</span>, <span class="dv">42</span>, <span class="dv">93</span>, <span class="dv">17</span>, <span class="dv">54</span>, <span class="dv">28</span>]))</span></code></pre></div>
<pre><code>93</code></pre>
<p>El comentario que aparece junto al <code>for</code> describe lo que se llama el <strong>invariante</strong> del ciclo, y es muy útil para poder argumentar la correctitud del programa, así como para poder ayudar a su diseño.</p>
<p>El invariante una afirmación lógica que debe ser verdadera cada vez que se intenta iniciar una nueva iteración, lo cual incluye tanto la primera vez como el último intento, en que se detecta que el rango ya se ha agotado y el ciclo termina.</p>
<ul>
<li><p>La validez del invariante la primera vez la deben asegurar las instrucciones previas al ciclo, que se llaman instrucciones de <em>inicialización</em>. En este ejemplo, al comenzar el ciclo se tiene que&nbsp;<span class="math inline">k=1</span>, y por lo tanto trivialmente se cumple que&nbsp;<span class="math inline">m=\max(a[0])</span>.</p></li>
<li><p>Las instrucciones al interior del ciclo (el “cuerpo de ciclo”) parten de la premisa de que el invariante se cumple al inicio, y deben garantizar que se cumpla al final (para dejar todo listo para la próxima iteración). Esto se llama <em>preservar el invariante</em>. En este ejemplo, para asegurar que&nbsp;<span class="math inline">m=\max(a[0],\ldots,a[k])</span> sabiendo que ya era cierto que&nbsp;<span class="math inline">m=\max(a[0],\ldots,a[k-1])</span>, se debe modificar&nbsp;<span class="math inline">m</span> solo en el caso de que&nbsp;<span class="math inline">a[k]</span> sea mayor que&nbsp;<span class="math inline">m</span>, o dejarlo igual si no.</p></li>
<li><p>Cuando se detecta que el rango se ha agotado, el invariante igualmente se cumple, y ambas cosas juntas deben asegurar que haya logrado el objetivo final deseado. En este ejemplo, cuando&nbsp;<span class="math inline">k</span> llega a ser igual a&nbsp;<span class="math inline">len(a)</span>, el invariante implica que&nbsp;<span class="math inline">m=\max(a[0],\ldots,a[len(a)-1])</span>, o sea, es el máximo de toda la lista.</p></li>
</ul>
<hr />
<section id="ejercicio-1.1" class="level3">
<h3>Ejercicio 1.1</h3>
<p>La función <code>maximo</code> hace&nbsp;<span class="math inline">n-1</span> comparaciones de elementos para encontrar el máximo de un conjunto de tamaño&nbsp;<span class="math inline">n</span>.</p>
<p>Supongamos que se desea escribir una función <code>minmax</code> que al ser llamada con una lista de números, retorne un par ordenado (tupla) <code>(min,max)</code>, con el mínimo y el máximo elemento del conjunto, respectivamente. Escriba a continuación esa función haciendo dos pasadas sobre los datos: una para encontrar el mínimo y otra para encontrar el máximo, y pruébela sobre una lista de ejemplo.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minmax(a):</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># escribir la función aquí</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(minimo,maximo)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Probarla acá</span></span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
<p>La función anterior debería hacer&nbsp;<span class="math inline">2n-2</span> comparaciones de elementos (<span class="math inline">2n-3</span> si se evita comparar el elemento seleccionado en la primera pasada). ¿Será posible encontrar el mínimo y el máximo haciendo muchas menos comparaciones?</p>
<p>¡La respuesta es que sí! Veámoslo con un ejemplo. Para simplificar, supongamos que la lista es de largo par:</p>
<p><span class="math display">
[45,21,34,67,55,89,44,12]
</span></p>
<p>Luego comparemos cada elemento que está en una posición par con su vecino de la derecha, e intercambiémoslos de modo que el par quede en orden ascendente (recuerde que las posiciones comienzan desde cero):</p>
<p><span class="math display">
[21,45,34,67,55,89,12,44]
</span></p>
<p>Luego hagamos una pasada solo sobre las posiciones pares para encontrar el mínimo (<span class="math inline">12</span>), y otra pasada solo entre las posiciones impares para encontrar el máximo (<span class="math inline">89</span>). ¡Listo!</p>
<p>Programe este nuevo algoritmo, pruébelo y diga cuántas comparaciones hace en total:</p>
<hr />
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minmax(a):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># escribir la función aquí</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(minimo,maximo)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Probarla acá</span></span></code></pre></div>
<hr />
</section>
</section>
<section id="instrucciones-iterativas-while" class="level2">
<h2>Instrucciones iterativas: while</h2>
<p>La instrucción <code>while</code> ejecuta instrucciones mientra la condición especificada sea verdadera:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dice si un número dado es primo o no</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> es_primo(n):</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">==</span><span class="dv">2</span>:</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span> <span class="co"># 2 es primo</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span> <span class="co"># ningún otro par es primo</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span><span class="dv">3</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">**</span><span class="dv">2</span><span class="op">&lt;=</span>n: <span class="co"># no es necesario buscar posibles factores más allá de sqrt(n)</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n<span class="op">%</span>k<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span> <span class="co"># n es divisible por k =&gt; no es primo</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        k<span class="op">+=</span><span class="dv">2</span> <span class="co"># probamos solo los impares</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># si no se encontró ningún factor menor que raíz de n, es primo</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(es_primo(<span class="dv">2</span>), es_primo(<span class="dv">7</span>), es_primo(<span class="dv">9</span>), es_primo(<span class="dv">79823492843</span>), es_primo(<span class="dv">79823492869</span>))</span></code></pre></div>
<pre><code>True True False False True</code></pre>
</section>
<section id="ejemplo-de-programación-con-invariantes-particionar-un-conjunto" class="level2">
<h2>Ejemplo de programación con invariantes: particionar un conjunto</h2>
<p>Supongamos que se tiene un conjunto de datos en una lista&nbsp;<span class="math inline">a[0],\ldots,a[n-1]</span> y un valor de corte&nbsp;<span class="math inline">p</span>, y se desea reordenar los datos dentro de la lista, de modo que queden a la izquierda todos los que son menores que&nbsp;<span class="math inline">p</span>, y a la derecha los que son mayores. Por simplicidad, supondremos que en la lista no hay ningún valor igual a&nbsp;<span class="math inline">p</span>. Este es un problema cuya utilidad veremos más adelante, cuando estudiemos el algoritmo de ordenación Quicksort.</p>
<p>La solución clásica para este problema es la de <strong>Hoare</strong>, el autor de Quicksort, y se basa en ir identificando elementos menores o mayores que&nbsp;<span class="math inline">p</span>, y moviéndolos hacia el extremo izquierdo o derecho de la lista, según corresponda. Esto corresponde al siguiente invariante:</p>
<figure>
<img src="recursos/particion-Hoare.png" alt="particio-Hoare" /><figcaption aria-hidden="true">particio-Hoare</figcaption>
</figure>
<p>En este invariante,&nbsp;<span class="math inline">i</span> y&nbsp;<span class="math inline">j</span> son los primeros elementos desconocidos (esto es, aún no identificados como menores o mayores), viniendo desde cada extremo.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> particionHoare(a,p):</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># retorna el punto de corte, el número de elementos &lt;p y la lista particionada</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    (i,j)<span class="op">=</span>(<span class="dv">0</span>,n<span class="op">-</span><span class="dv">1</span>) <span class="co">#inicialmente todos los elementos son desconocidos</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i<span class="op">&lt;=</span>j: <span class="co"># aún quedan elementos desconocidos</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[i]<span class="op">&lt;</span>p:</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>            i<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> a[j]<span class="op">&gt;</span>p:</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>            j<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>            (a[i],a[j])<span class="op">=</span>(a[j],a[i]) <span class="co"># intercambio</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>            i<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>            j<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (p,i,a)   </span></code></pre></div>
<p>Para ayudarnos a verificar que la partición se realiza correctamente, definiremos una función auxiliar:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verifica_particion(t): <span class="co"># imprime y chequea partición</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    (p,m,a)<span class="op">=</span>t</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># p=punto de corte, m=número de elementos &lt;p, a=lista completa particionada</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(a[<span class="dv">0</span>:m],p,a[m:])</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Partición OK&quot;</span> <span class="cf">if</span> (m<span class="op">==</span><span class="dv">0</span> <span class="kw">or</span> <span class="bu">max</span>(a[<span class="dv">0</span>:m])<span class="op">&lt;</span>p) <span class="kw">and</span> (m<span class="op">==</span><span class="bu">len</span>(a) <span class="kw">or</span> <span class="bu">min</span>(a[m:])<span class="op">&gt;</span>p)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> <span class="st">&quot;Error&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionHoare([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">50</span>))</span></code></pre></div>
<pre><code>[36, 21, 34, 15, 37] 50 [56, 77, 65, 82, 98, 73]
Partición OK</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionHoare([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">0</span>))</span></code></pre></div>
<pre><code>[] 0 [73, 21, 34, 98, 56, 37, 77, 65, 82, 15, 36]
Partición OK</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionHoare([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">100</span>))</span></code></pre></div>
<pre><code>[73, 21, 34, 98, 56, 37, 77, 65, 82, 15, 36] 100 []
Partición OK</code></pre>
<hr />
<section id="ejercicio-1.2" class="level3">
<h3>Ejercicio 1.2</h3>
<p>Existe un algoritmo alternativo, que resulta en una codificación más sencilla. Este algoritmo, debido a <strong>Lomuto</strong>, se basa en el siguiente invariante:</p>
<figure>
<img src="recursos/particion-Lomuto.png" alt="particion-Lomuto" /><figcaption aria-hidden="true">particion-Lomuto</figcaption>
</figure>
<p>En este algoritmo, en cada iteración, si&nbsp;<span class="math inline">a[j]&lt;p</span>, se intercambian&nbsp;<span class="math inline">a[i]</span> con&nbsp;<span class="math inline">a[j]</span> y se incrementa&nbsp;<span class="math inline">i</span>, porque ahora hay un elemento más en el grupo de los menores que&nbsp;<span class="math inline">p</span>. Después de esto, se incrementa&nbsp;<span class="math inline">j</span>, <em>incondicionalmente</em> (¿por qué es correcto hacer eso?).</p>
<p>Programe la partición de Lomuto en el recuadro siguiente y pruébela.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> particionLomuto(a,p):</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># retorna el punto de corte, el número de elementos &lt;p y la lista particionada</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># escribir acá el algoritmo de partición de Lomuto</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (p,i,a) </span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionLomuto([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">50</span>))</span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionLomuto([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">0</span>))</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>verifica_particion(particionLomuto([<span class="dv">73</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">98</span>,<span class="dv">56</span>,<span class="dv">37</span>,<span class="dv">77</span>,<span class="dv">65</span>,<span class="dv">82</span>,<span class="dv">15</span>,<span class="dv">36</span>],<span class="dv">100</span>))</span></code></pre></div>
<hr />
</section>
</section>
<section id="ejemplo-de-programación-con-invariantes-calcular-y-xn" class="level2">
<h2>Ejemplo de programación con invariantes: Calcular <span class="math inline">y = x^n</span></h2>
<p>Supongamos que no tuviéramos una operación de elevación a potencia, y que necesitáramos calcular&nbsp;<span class="math inline">x^n</span> para&nbsp;<span class="math inline">n</span> entero no negativo. El algoritmo obvio es calcular&nbsp;<span class="math inline">x*x*\cdots *x</span> (<span class="math inline">n</span> veces):</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x, n):</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        y<span class="op">*=</span>x</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>El invariante, esto es, lo que se cumple al comenzar cada nueva iteración es&nbsp;<span class="math inline">y = x^k</span>. Así, al inicio, cuando&nbsp;<span class="math inline">k=0</span>, se tiene&nbsp;<span class="math inline">y=1</span> (inicialización), y al término, cuando&nbsp;<span class="math inline">y=n</span>, se tiene la condición final buscada. La preservación del invariante consiste en multiplicar&nbsp;<span class="math inline">y</span> por&nbsp;<span class="math inline">x</span>, porque así se sigue cumpliendo el invariante cuando&nbsp;<span class="math inline">k</span> se incrementa en&nbsp;<span class="math inline">1</span>.</p>
<p>Este algoritmo ejecuta&nbsp;<span class="math inline">n</span> multiplicaciones para calcular&nbsp;<span class="math inline">x^n</span> y, si tomamos en cuenta todo lo que hace, es evidente que demora un tiempo proporcional a&nbsp;<span class="math inline">n</span>, lo cual escribiremos&nbsp;<span class="math inline">O(n)</span> y lo leeremos “del orden de <span class="math inline">n</span>.” (Más adelante definiremos precisamente esta notación, y veremos que podríamos ser más precisos todavía al describir el tiempo que demora un algoritmo)</p>
<p>¿Será posible calcular una potencia de manera más eficiente?</p>
<p>Para ver cómo podríamos mejorar el algoritmo, comenzaremos por reescribirlo de modo que la variable&nbsp;<span class="math inline">k</span> vaya disminuyendo en lugar de ir aumentando, usando para ello la instrucción <code>while</code>:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x, n):</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        y<span class="op">*=</span>x</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        k<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>El invariante en este caso sería&nbsp;<span class="math inline">y = x^{n-k}</span> o, lo que es lo mismo,&nbsp;<span class="math inline">y * x^k = x^n</span>.</p>
<p>El reescribirlo de esta manera nos permite hacer el siguiente truco: vamos a introducir una variable&nbsp;<span class="math inline">z</span>, cuyo valor inicial es&nbsp;<span class="math inline">x</span>, y reformular el invariante como&nbsp;<span class="math inline">y * z^k = x^n</span> y preservarlo aprovechando que&nbsp;<span class="math inline">y*z^k = (y*z)*z^{k-1}</span>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x, n):</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    z<span class="op">=</span>x</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        y<span class="op">*=</span>z</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        k<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>Este cambio podría parecer ocioso, pero gracias a él ahora tenemos un grado adicional de libertad: en efecto, podemos modificar la variable&nbsp;<span class="math inline">z</span> en la medida que eso no haga que el invariante deje de cumplirse.</p>
<p>En particular, una oportunidad de hacer esto aparece cuando&nbsp;<span class="math inline">k</span> es par. En ese caso, como&nbsp;<span class="math inline">z^n=(z^2)^{n/2}</span>, si elevamos&nbsp;<span class="math inline">z</span> al cuadrado y al mismo tiempo dividimos&nbsp;<span class="math inline">k</span> a la mitad, ambos cambios se complementan para hacer que el invariante se preserve. El algoritmo resultante se llama el <em>algoritmo binario</em>.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x, n):</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    z<span class="op">=</span>x</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">0</span>: <span class="co"># caso k par</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>            z<span class="op">=</span>z<span class="op">*</span>z</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>            k<span class="op">//=</span><span class="dv">2</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:      <span class="co"># caso k impar</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>            y<span class="op">*=</span>z </span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>            k<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>Este algoritmo admite todavía una pequeña optimización. Cuando&nbsp;<span class="math inline">k</span> se divide por&nbsp;<span class="math inline">2</span>, no solo se preserva el invariante, sino que además&nbsp;<span class="math inline">k</span> sigue siendo&nbsp;<span class="math inline">&gt;0</span>, y por lo tanto no es necesario en ese caso volver a preguntar por la condición del <code>while</code>. El algoritmo queda como sigue:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x, n):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    z<span class="op">=</span>x</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> k<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">0</span>: <span class="co"># caso k par</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>            z<span class="op">=</span>z<span class="op">*</span>z</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>            k<span class="op">//=</span><span class="dv">2</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>        y<span class="op">*=</span>z <span class="co"># aquí estamos seguros que k es impar</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>        k<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>Este algoritmo (en cualquiera de las dos últimas versiones) se llama el <em>algoritmo binario</em>, y es mucho más eficiente que el algoritmo inicial. Cada vez que se da el caso par,&nbsp;<span class="math inline">k</span> disminuye a a mitad, y eso ocurre al menos la mitad de las veces. Pero si&nbsp;<span class="math inline">k</span> comienza con el valor&nbsp;<span class="math inline">n</span>, la operación de dividir por&nbsp;<span class="math inline">2</span> se puede ejecutar a lo más&nbsp;<span class="math inline">\log_2{n}</span> veces, por lo tanto el tiempo total de ejecución es&nbsp;<span class="math inline">O(\log_2{n})</span>, en lugar de&nbsp;<span class="math inline">O(n)</span>.</p>
<p>Decimos que el algoritmo original era de tiempo lineal, y que el algoritmo binario es de tiempo logarítmico. Para&nbsp;<span class="math inline">n</span> grande, la diferencia de eficiencia es muy grande en favor del algoritmo binario.</p>
<p>Una observación importante es que para que el algoritmo binario funcione, solo es necesario que&nbsp;<span class="math inline">x</span> <span class="math inline">y</span>,&nbsp;<span class="math inline">z</span> pertenezcan a un conjunto para el cual hay definida una operación multiplicativa que sea asociativa y que tenga un elemento neutro. Por lo tanto, este algoritmo no solo sirve para elevar a potencia números enteros o reales, sino que además, por ejemplo, para calcular potencias de <em>matrices</em>.</p>
<section id="por-qué-se-llama-algoritmo-binario" class="level3">
<h3>¿Por qué se llama “algoritmo binario?”</h3>
<p>Existe una relación muy interesante entre el funcionamiento de este algoritmo y la representación binaria del número&nbsp;<span class="math inline">n</span>.</p>
<p>Para quienes no lo recuerden (o lo estén viendo por primera vez), cuando un número se escribe en base&nbsp;<span class="math inline">10</span>, por ejemplo, el número&nbsp;<span class="math inline">2019</span>, esto significa</p>
<p><span class="math display">
(2019)_{10} = 2 \cdot 10^3 + 0 \cdot 10^2 + 1 \cdot 10^1 + 9 \cdot 10^0
</span></p>
<p>De manera análoga, un número escrito en base&nbsp;<span class="math inline">2</span>, por ejemplo&nbsp;<span class="math inline">110101</span> significa</p>
<p><span class="math display">
(110101)_2 = 1 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 
</span></p>
<p>lo cual equivale a 53 en decimal.</p>
<p>Más en general, un número puede estar escrito en base&nbsp;<span class="math inline">b</span>:</p>
<p><span class="math display">
(\ldots d_3 d_2 d_1 d_0)_b = \sum_{k \ge 0}{d_k b^k}
</span></p>
<p>donde&nbsp;<span class="math inline">0\le d_k \le b-1</span> para todo&nbsp;<span class="math inline">k</span>.</p>
<p>Volviendo ahora al problema de calcular&nbsp;<span class="math inline">y=x^n</span>, consideremos como ejemplo de&nbsp;<span class="math inline">n=53</span>. Si escribimos el exponente en binario, tenemos que</p>
<p><span class="math display">
\begin{align}
x^{53} &amp;= x^{(110101)_2}\\
  &amp;=x^{1 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0}\\
  &amp;=x^{2^5}\cdot x^{2^4}\cdot x^{2^2}\cdot x^{2^0}\\
  &amp;=x^{32}\cdot x^{16}\cdot x^{4}\cdot x^{1}\\
\end{align}
</span></p>
<p>Como vemos, el valor final calculado es el producto de los&nbsp;<span class="math inline">x</span> elevados a aquellas potencias de 2 que corresponden exactamente adonde hay un dígito&nbsp;<span class="math inline">1</span> en la representación binaria del número&nbsp;<span class="math inline">n</span>. Veremos que eso es exactamente lo que hace al algoritmo.</p>
<p>Si examinamos el algoritmo, en su primera versión, podemos ver que su estado se puede representar por una terna&nbsp;<span class="math inline">(k,z,y)</span>, la cual tiene el valor inicial&nbsp;<span class="math inline">(n,x,1)</span>. En cada iteración tenemos dos casos:</p>
<p>Caso&nbsp;<span class="math inline">k</span> par: <span class="math display">
(k,z,y) \rightarrow (\frac{k}{2},z^2,y)
</span></p>
<p>Caso&nbsp;<span class="math inline">k</span> impar: <span class="math display">
(k,z,y) \rightarrow (k-1,z,yz)
</span></p>
<p>Estas reglas adquieren una forma mucho muy simple si el número&nbsp;<span class="math inline">k</span> se considera escrito en binario. En esta base un número es <em>par</em> si termina en&nbsp;<span class="math inline">0</span> y es <em>impar</em> si termina en 1. Además, restarle&nbsp;<span class="math inline">1</span> a un número impar es equivalente a sustituir el&nbsp;<span class="math inline">1</span> de más a la derecha por un&nbsp;<span class="math inline">0</span>, y dividir por&nbsp;<span class="math inline">2</span> un número par es equivalente a eliminar el&nbsp;<span class="math inline">0</span> de más a la derecha.</p>
<p>Con esto, podemos reformular nuestras reglas, suponiendo que el número&nbsp;<span class="math inline">k</span> se escribe en binario en la forma&nbsp;<span class="math inline">(\alpha X)_2</span>, donde&nbsp;<span class="math inline">X</span> es el dígito de más a la derecha y&nbsp;<span class="math inline">\alpha</span> es la secuencia de dígitos que lo preceden. Entonces</p>
<p>Caso&nbsp;<span class="math inline">k</span> terminado en&nbsp;<span class="math inline">0</span>: <span class="math display">
((\alpha 0)_2,z,y) \rightarrow ((\alpha)_2,z^2,y)
</span></p>
<p>Caso&nbsp;<span class="math inline">k</span> terminado en&nbsp;<span class="math inline">1</span>: <span class="math display">
((\alpha 1)_2,z,y) \rightarrow ((\alpha 0)_2,z,yz)
</span></p>
<p>En palabras: la variable&nbsp;<span class="math inline">z</span> va tomando sucesivamente los valores&nbsp;<span class="math inline">x^1,x^2,x^4,x^8,\ldots</span>, y el valor final calculado es&nbsp;<span class="math inline">x</span> elevado a la suma aquellas potencias que corresponden exactamente adonde hay un dígito&nbsp;<span class="math inline">1</span> en la representación binaria del número&nbsp;<span class="math inline">n</span>.</p>
<p>La siguiente tabla muestra la ejecución del algoritmo para&nbsp;<span class="math inline">n=53</span>:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">k</span></th>
<th><span class="math inline">z</span></th>
<th><span class="math inline">y</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">(110101)_2</span></td>
<td><span class="math inline">x^1</span></td>
<td><span class="math inline">1</span></td>
</tr>
<tr class="even">
<td><span class="math inline">(110100)_2</span></td>
<td><span class="math inline">x^1</span></td>
<td><span class="math inline">x^1</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">(11010)_2</span></td>
<td><span class="math inline">x^2</span></td>
<td><span class="math inline">x^1</span></td>
</tr>
<tr class="even">
<td><span class="math inline">(1101)_2</span></td>
<td><span class="math inline">x^4</span></td>
<td><span class="math inline">x^1</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">(1100)_2</span></td>
<td><span class="math inline">x^4</span></td>
<td><span class="math inline">x^{1+4}=x^5</span></td>
</tr>
<tr class="even">
<td><span class="math inline">(110)_2</span></td>
<td><span class="math inline">x^8</span></td>
<td><span class="math inline">x^{1+4}=x^5</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">(11)_2</span></td>
<td><span class="math inline">x^{16}</span></td>
<td><span class="math inline">x^{1+4}=x^5</span></td>
</tr>
<tr class="even">
<td><span class="math inline">(10)_2</span></td>
<td><span class="math inline">x^{16}</span></td>
<td><span class="math inline">x^{1+4+16}=x^{21}</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">(1)_2</span></td>
<td><span class="math inline">x^{32}</span></td>
<td><span class="math inline">x^{1+4+16}=x^{21}</span></td>
</tr>
<tr class="even">
<td><span class="math inline">(0)_2</span></td>
<td><span class="math inline">x^{32}</span></td>
<td><span class="math inline">x^{1+4+16+32}=x^{53}</span></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="ejemplo-de-programación-con-invariantes-evaluación-de-un-polinomio" class="level2">
<h2>Ejemplo de programación con invariantes: Evaluación de un polinomio</h2>
<p>Supongamos que se tiene un polinomio</p>
<p><span class="math display">
P(x) = \sum_{0&lt;=k&lt;=n}{a_k x^k}
</span></p>
<p>y se desea calcular su valor en un punto dado&nbsp;<span class="math inline">x</span>.</p>
<p>Una solución trivial se puede obtener directamente de la fórmula anterior:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalp(a,x):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evalúa en el punto x el polinomio cuyos coeficientes son a[0], a[1],...</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna el valor calculado</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    P<span class="op">=</span><span class="dv">0</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(a)):</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Invariante: P=a[0]+a[1]*x+...+a[k-1]*x**(k-1)</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>        P <span class="op">+=</span> a[k]<span class="op">*</span>x<span class="op">**</span>k</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P</span></code></pre></div>
<p>Podemos probar esta función evaluando el polinomio</p>
<p><span class="math display">
P(x) = 5+2x-3x^2+4x^3
</span></p>
<p>en el punto&nbsp;<span class="math inline">x=2</span>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(evalp([<span class="dv">5</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>],<span class="dv">2</span>))</span></code></pre></div>
<pre><code>29</code></pre>
<p>El problema es que este algoritmo puede ser ineficiente. Si el sistema calcula <code>x**k</code> de manera simple, el tiempo total de ejecución sería del orden de&nbsp;<span class="math inline">n^2</span>, y si lo calcula usando el algoritmo binario, el tiempo sería del orden de&nbsp;<span class="math inline">n\log{n}</span>. Veremos que esto se puede reducir a tiempo lineal.</p>
<p>Para esto, vamos a introducir una variable adicional, digamos&nbsp;<span class="math inline">y</span>, que almacene el valor de&nbsp;<span class="math inline">x^k</span> necesario para cada iteración. Para preservar este invariante, al final de cada vuelta del ciclo debemos dejarla multiplicada por&nbsp;<span class="math inline">x</span>, para que tenga el valor correcto al iniciarse la siguiente iteración:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalp(a,x):</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evalúa en el punto x el polinomio cuyos coeficientes son a[0], a[1],...</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna el valor calculado</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    P<span class="op">=</span><span class="dv">0</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="dv">1</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(a)):</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Invariante: P=a[0]+a[1]*x+...+a[k-1]*x**(k-1) and y=x**k</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>        P <span class="op">+=</span> a[k]<span class="op">*</span>y</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>        y <span class="op">*=</span> x</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P</span></code></pre></div>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(evalp([<span class="dv">5</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>],<span class="dv">2</span>))</span></code></pre></div>
<pre><code>29</code></pre>
<hr />
<section id="ejercicio-1.3" class="level3">
<h3>Ejercicio 1.3</h3>
<p>Un polinomio se puede evaluar en tiempo lineal sin necesidad de una variable auxiliar si observamos que&nbsp;<span class="math inline">P(x)</span> se puede factorizar como:</p>
<p><span class="math display">
P(x) = a_0 +x(a_1+x(\cdots+x(a_{n-1}+x(a_n))\cdots))
</span></p>
<p>Por ejemplo,</p>
<p><span class="math display">
\begin{align}
P(x) &amp;= 5+2x-3x^2+4x^3\\
 &amp;=5+x(2+x(-3+x(4)))
\end{align}
</span></p>
<p>Programe un algoritmo iterativo que evalúe el polinomio utilizando esta idea. Comience desde el paréntesis más interno y vaya avanzando hacia la izquierda. Indique cuál es el invariante que utiliza. El algoritmo resultante se llama la <strong>Regla de Horner</strong>.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalp(a,x):</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evalúa en el punto x el polinomio cuyos coeficientes son a[0], a[1],...</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="co">    utilizando la Regla de Horner</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna el valor calculado</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Escriba aquí su algoritmo</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P</span></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(evalp([<span class="dv">5</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>],<span class="dv">2</span>))</span></code></pre></div>
<hr />
</section>
</section>
<section id="numpy-y-arreglos" class="level2">
<h2>Numpy y Arreglos</h2>
<p>Numpy es la principal biblioteca para computación científica en Python.</p>
<p>Una de las características de Numpy es que provee arreglos multidimensionales de alta eficiencia. Mientras la gran flexibilidad de las listas de Python puede hacer que no sea muy eficiente el acceso a elementos específicos, los arreglos de Numpy aseguran el acceso a cada elemento en tiempo constante. Por esa razón, utilizaremos estos arreglos cuando necesitemos asegurar la eficiencia de la implementación de los algoritmos.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="fl">6.5</span>, <span class="fl">5.2</span>, <span class="fl">4.6</span>, <span class="fl">7.0</span>, <span class="fl">4.3</span>])</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a[<span class="dv">2</span>])</span></code></pre></div>
<pre><code>4.6</code></pre>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(a))</span></code></pre></div>
<pre><code>5</code></pre>
<p>Hay varias formas de crear arreglos inicializados con ceros, unos, valores constantes o valores aleatorios.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.ones(<span class="dv">10</span>)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span></code></pre></div>
<pre><code>[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</code></pre>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.zeros(<span class="dv">7</span>,dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code></pre></div>
<pre><code>[0 0 0 0 0 0 0]</code></pre>
<p>En los dos ejemplos anteriores mostramos la diferencia que se produce al explicitar el tipo de datos del arreglo. En el primero, obtenemos el <em>default</em>, que es flotante, mientras en el segundo forzamos a que sea entero.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.full(<span class="dv">5</span>, <span class="dv">2</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code></pre></div>
<pre><code>[2 2 2 2 2]</code></pre>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(d)</span></code></pre></div>
<pre><code>[0.96086121 0.31006032 0.78951795 0.14162147 0.72680238 0.03081408]</code></pre>
<p>También es posible crear y manejar arreglos de varias dimensiones.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]])</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[[1 2 3]
 [4 5 6]]</code></pre>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a[<span class="dv">0</span>,<span class="dv">2</span>])</span></code></pre></div>
<pre><code>3</code></pre>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>(m,n)<span class="op">=</span>np.shape(a)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(m,n)</span></code></pre></div>
<pre><code>2 3</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.zeros((<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span></code></pre></div>
<pre><code>[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]</code></pre>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.eye(<span class="dv">3</span>)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code></pre></div>
<pre><code>[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]</code></pre>
</section>
<section id="ejemplos-de-programación-con-invariantes-ordenación" class="level2">
<h2>Ejemplos de programación con invariantes: Ordenación</h2>
</section>
<section id="ordenación-por-inserción" class="level2">
<h2>Ordenación por inserción</h2>
<p>Supongamos que se tiene un arreglo&nbsp;<span class="math inline">a</span>, de tamaño&nbsp;<span class="math inline">n</span>, y queremos reordenar los datos almacenados en su interior de modo que queden en orden ascendente.</p>
<p>El método de <strong>Ordenación por Inserción</strong> se basa en formar en el sector izquierdo del arreglo un subconjunto ordenado, en el cual se van insertando uno por uno los elementos restantes. Para la inicialización, comenzamos con un subconjunto ordenado de tamaño 0, y el proceso termina cuando el subconjunto ordenado llega a tener tamaño&nbsp;<span class="math inline">n</span>. El invariante se puede visualizar como:</p>
<figure>
<img src="recursos/insercion.png" alt="insercion" /><figcaption aria-hidden="true">insercion</figcaption>
</figure>
<p>La variable&nbsp;<span class="math inline">k</span> indica el tamaño del subconjunto ordenado. Equivalentemente,&nbsp;<span class="math inline">k</span> es el subíndice del primer elemento todavía no ordenado, y que será el que se insertará en esta oportunidad.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordenación Por Inserción</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ordena_insercion(a):</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>        insertar(a,k)</span></code></pre></div>
<p>Este algoritmo todavía no es ejecutable, porque falta definir la función <code>insertar</code>, que se encarga de tomar&nbsp;<span class="math inline">a[k]</span> e insertarlo entre los anteriores. La forma más simple de hacer esto es a través de intercambios sucesivos:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Insertar a[k] entre los elementos anteriores preservando el orden ascendente (versión 1)</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insertar(a, k):</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span>k <span class="co"># señala la posición del elemento que está siendo insertado</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> j<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> a[j]<span class="op">&lt;</span>a[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>        (a[j], a[j<span class="op">-</span><span class="dv">1</span>]) <span class="op">=</span> (a[j<span class="op">-</span><span class="dv">1</span>], a[j])</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>        j<span class="op">-=</span><span class="dv">1</span></span></code></pre></div>
<p>Para poder probar este algoritmo, generemos un arreglo con números aleatorios y ordenémoslo:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>ordena_insercion(a)</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.21698872 0.31136108 0.0676283  0.6468421  0.4082596  0.78409654]
[0.0676283  0.21698872 0.31136108 0.4082596  0.6468421  0.78409654]</code></pre>
<p>Si observamos el algoritmo de inserción, podemos ver que en los intercambios siempre uno de los dos elementos involucrados es el que se está insertando, el cual pasa por muchos lugares provisorios hasta llegar finalmente a su ubicación definitiva. Esto sugiere que podemos ahorrar trabajo si en lugar de hacer todos esos intercambios, sacamos primero el elemento a insertar hacia una variable auxiliar, luego vamos moviendo los restantes elementos hacia la derecha, y al final movemos directamente el nuevo elemento desde la variable auxiliar hasta su posición definitiva:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Insertar a[k] entre los elementos anteriores preservando el orden ascendente (versión 2)</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insertar(a, k):</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    b<span class="op">=</span>a[k] <span class="co"># b almacena transitoriamente al elemento a[k]</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span>k <span class="co"># señala la posición del lugar &quot;vacío&quot;</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> j<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> b<span class="op">&lt;</span>a[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>        a[j]<span class="op">=</span>a[j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>        j<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    a[j]<span class="op">=</span>b</span></code></pre></div>
<div class="sourceCode" id="cb112"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>ordena_insercion(a)</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.63169534 0.51338201 0.75754562 0.11005649 0.81951851 0.5797447 ]
[0.11005649 0.51338201 0.5797447  0.63169534 0.75754562 0.81951851]</code></pre>
<p>Para analizar la eficiencia de este algoritmo, podemos considerar varios casos: * Mejor caso: Si el arreglo ya viene ordenado, el ciclo de la función <code>insertar</code> termina de inmediato, así que esa función demora tiempo constante, y el proceso completo demora tiempo&nbsp;<span class="math inline">O(n)</span>, lineal en&nbsp;<span class="math inline">n</span>. * Peor caso: Si el arreglo viene originalmente en orden decreciente, el ciclo de la función <code>insertar</code> hace el máximo de iteraciones (<span class="math inline">k</span>), y la suma de todos esos costos da un total de&nbsp;<span class="math inline">O(n^2)</span>, cuadrático en&nbsp;<span class="math inline">n</span>. * Caso promedio: Si el arreglo viene en orden aleatorio, el número promedio de iteraciones que hace el ciclo de la función <code>insertar</code> es aproximadamente&nbsp;<span class="math inline">k/2</span>, y la suma de todos esos costos igual da un total de&nbsp;<span class="math inline">O(n^2)</span>. Esto es, el costo promedio también es cuadrático.</p>
</section>
<section id="ordenación-por-selección" class="level2">
<h2>Ordenación por Selección</h2>
<p>El método de <strong>Ordenación por Selección</strong> se basa en extraer el máximo elemento y moverlo hacia el extremo derecho del arreglo, y repetir este proceso entre los elementos restantes hasta que todos hayan sido extraídos. El invariante se puede visualizar como:</p>
<figure>
<img src="recursos/seleccion.png" alt="ord-seleccion" /><figcaption aria-hidden="true">ord-seleccion</figcaption>
</figure>
<p>La variable&nbsp;<span class="math inline">k</span> indica el tamaño del subconjunto que todavía falta por procesar. Equivalentemente, es el subíndice del primer elemento que ya pertenece al subconjunto ordenado.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordenación por Selección</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ordena_seleccion(a):</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n,<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>): <span class="co"># Paramos cuando todavía queda 1 elemento &quot;desordenado&quot; (¿por qué está bien eso?)</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>        j<span class="op">=</span>pos_maximo(a,k) <span class="co"># Encuentra posición del máximo entre a[0],...,a[k-1]</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>        (a[j],a[k<span class="op">-</span><span class="dv">1</span>])<span class="op">=</span>(a[k<span class="op">-</span><span class="dv">1</span>],a[j])</span></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encuentra posición del máximo entre a[0],...,a[k-1]</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pos_maximo(a, k):</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span><span class="dv">0</span> <span class="co"># j señala la posición del máximo</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[i]<span class="op">&gt;</span>a[j]: <span class="co"># Encontramos un nuevo máximo</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> j</span></code></pre></div>
<p>Nuevamente, probamos nuestro algoritmo con un arreglo aleatorio:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>ordena_seleccion(a)</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.91088675 0.55781357 0.6422284  0.80222542 0.49612172 0.32394811]
[0.32394811 0.49612172 0.55781357 0.6422284  0.80222542 0.91088675]</code></pre>
<p>En este algoritmo, siempre se recorre todo el conjunto de tamaño&nbsp;<span class="math inline">k</span> para encontrar el máximo, de modo que la suma de todos estos costos de un total de&nbsp;<span class="math inline">O(n^2)</span>, en todos los casos.</p>
<p>Más adelante veremos que hay maneras mucho más eficientes de calcular el máximo de un conjunto, una vez que se ha encontrado y extraído el máximo la primera vez.</p>
<p>Piensen por ejemplo en un típico torneo de tenis, en donde los jugadores se van eliminando por rondas, hasta que en la final queda solo un jugador invicto: el campeón. Si hay&nbsp;<span class="math inline">n</span> jugadores, ese proceso requiere exactamente&nbsp;<span class="math inline">n-1</span> partidos. <strong>Pero</strong> una vez que se ha jugado todo ese torneo, hagamos un experimento mental y pensemos que habría sucedido si el primer día el campeón no hubiera podido jugar por alguna causa. Para determinar quién habría resultado campeón en esas circunstancias (o sea, para encontrar al subcampeón), <strong>no sería necesario repetir todo el torneo, sino solo volver a jugar los partidos en los que habría participado el campeón</strong>. Ese número de partidos es mucho menor a&nbsp;<span class="math inline">n</span>, y en realidad no es difícil ver que es logarítmico. Y eso puede repetirse para encontrar al tercero, al cuarto, etc., siempre con el mismo costo logarítmico.</p>
<p>Si sumamos todos esos costos, da un total de&nbsp;<span class="math inline">O(n\log{n})</span>, en el peor caso.</p>
<p>Lo anterior es una “demostración de factibilidad” de que existen algoritmos de ordenación de costo&nbsp;<span class="math inline">O(n\log{n})</span>, más eficientes que&nbsp;<span class="math inline">O(n^2)</span>. Más adelante en el curso veremos algoritmos prácticos que alcanzan esta eficiencia.</p>
</section>
<section id="ordenación-de-la-burbuja" class="level2">
<h2>Ordenación de la Burbuja</h2>
<p>Este algoritmo se basa en ir haciendo pasadas sucesivas de izquierda a derecha sobre el arreglo, y cada vez que encuentra dos elementos adyacentes fuera de orden, los intercambia. Así, el arreglo va quedando cada vez “más ordenado,” hasta que finalmente esté totalmente ordenado.</p>
<p>Analizando el efecto de una pasada de izquierda a derecha, vemos que, aparte de los pequeños desórdenes que pueda ir arreglando por el camino, una vez que el algoritmo se encuentra con el máximo, los intercambios lo empiezan a trasladar paso a paso hacia la derecha, hasta que finalmente queda en el extremo derecho del arreglo. Eso significa que ya ha llegado a su posición definitiva, y no necesitamos volver a tocarlo. Por lo tanto, el algoritmo puede ignorar esos elementos al extremo derecho, los que por construcción están ordenados y son mayores que todos los de la izquierda. Esto lo podemos visualizar como:</p>
<figure>
<img src="recursos/seleccion.png" alt="ord-seleccion" /><figcaption aria-hidden="true">ord-seleccion</figcaption>
</figure>
<p>¡El mismo invariante que la Ordenación por Selección! Sin embargo, el algoritmo resultante es distinto.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordenación de la Burbuja (versión 1)</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ordena_burbuja(a):</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n <span class="co"># número de elementos todavía desordenados</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">1</span>:</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hacer una pasada sobre a[0],...,a[k-1]</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># intercambiando elementos adyacentes desordenados</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,k<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[j]<span class="op">&gt;</span>a[j<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>                (a[j],a[j<span class="op">+</span><span class="dv">1</span>])<span class="op">=</span>(a[j<span class="op">+</span><span class="dv">1</span>],a[j])</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Disminuir k</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>        k<span class="op">-=</span><span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>ordena_burbuja(a)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.67980575 0.47893026 0.29847223 0.97584905 0.07176052 0.9138015 ]
[0.07176052 0.29847223 0.47893026 0.67980575 0.9138015  0.97584905]</code></pre>
<p>Este algoritmo demora siempre tiempo&nbsp;<span class="math inline">O(n^2)</span>, ¡incluso si se le da para ordenar un arregla que ya viene ordenado!</p>
<p>No cuesta mucho introducir una variable booleana que señale si en una pasada no se ha hecho ningún intercambio, y usar esa variable para terminar el proceso cuando eso ocurre. Pero hay una manera mejor de modificar el algoritmo para aumentar su eficiencia.</p>
<p>Para esto, introducimos una variable&nbsp;<span class="math inline">i</span> que recuerda el punto donde se hizo el último intercambio (el cual habría sido entre&nbsp;<span class="math inline">a[i-1]</span> y&nbsp;<span class="math inline">a[i]</span>. Si a partir de ese punto ya no se encontraron elementos fuera de orden, eso quiere decir que&nbsp;<span class="math inline">a[i-1]&lt;a[i]</span> y luego a partir de ahí todos los elementos están ordenados, <strong>hasta el final del arreglo</strong>. Por lo tanto, el invariante se preserva si hacemos&nbsp;<span class="math inline">k=i</span>.</p>
<p>¿Qué pasa si no hubo ningún intercambio? Para este caso, si le damos a la variable&nbsp;<span class="math inline">i</span> el valor inicial cero, al hacer&nbsp;<span class="math inline">k=i</span> tendríamos&nbsp;<span class="math inline">k=0</span> y el proceso terminaría automáticamente. El algoritmo resultante es el siguiente:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordenación de la Burbuja (versión 2)</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ordena_burbuja(a):</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n <span class="co"># número de elementos todavía desordenados</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">1</span>:</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hacer una pasada sobre a[0],...,a[k-1]</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># intercambiando elementos adyacentes desordenados</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>        i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,k<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[j]<span class="op">&gt;</span>a[j<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>                (a[j],a[j<span class="op">+</span><span class="dv">1</span>])<span class="op">=</span>(a[j<span class="op">+</span><span class="dv">1</span>],a[j])</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a>                i<span class="op">=</span>j<span class="op">+</span><span class="dv">1</span> <span class="co"># recordamos el lugar del último intercambio</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Disminuir k</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span>i</span></code></pre></div>
<div class="sourceCode" id="cb122"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>ordena_burbuja(a)</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.20877349 0.71209819 0.30996714 0.91145577 0.3479466  0.08197456]
[0.08197456 0.20877349 0.30996714 0.3479466  0.71209819 0.91145577]</code></pre>
<p>Este algoritmo aprovecha mejor el orden previo que puede trar el arreglo, y en particular ordena arreglos ordenados en tiempo lineal. Pero tanto su peor caso como su caso promedio siguen siendo cuadráticos.</p>
</section>
<section id="recursividad" class="level2">
<h2>Recursividad</h2>
<p>El poder escribir funciones que se llamen a sí mismas es una herramienta muy poderosa de programación. Veremos algunos ejemplos de aplicaciones de este concepto, y más adelante veremos cómo puede conducir al diseño de algoritmos muy eficientes.</p>
</section>
<section id="ejemplo-calcular-yxn" class="level2">
<h2>Ejemplo: Calcular <span class="math inline">y=x^n</span></h2>
<p>Revisemos nuevamente este problema, pero ahora desde un punto de vista recursivo. Una potencia se puede definir recursivamente de la siguiente manera:</p>
<p><span class="math display">
x^n =
\begin{cases}x * x^{n-1} &amp; \mbox{si }n&gt;0 \\
1 &amp; \mbox{si }n=0
\end{cases}
</span></p>
<p>lo cual se puede implementar directamente como una función recursiva:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x,n):</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">*</span> potencia(x,n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb125"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>El algoritmo resultante demora tiempo&nbsp;<span class="math inline">O(n)</span>, pero puede mejorarse si el caso&nbsp;<span class="math inline">n</span> par lo tratamos aparte:</p>
<p><span class="math display">
x^n =
\begin{cases}
\left(x^2\right)^{n/2} &amp; \mbox{si }n&gt;0\mbox{, par} \\
x * x^{n-1} &amp; \mbox{si }n&gt;0\mbox{, impar} \\
1 &amp; \mbox{si }n=0
\end{cases}
</span></p>
<p>y la función que lo implementa es:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(x,n):</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> potencia(x<span class="op">*</span>x,n<span class="op">//</span><span class="dv">2</span>)</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">*</span> potencia(x,n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb128"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(potencia(<span class="dv">2</span>,<span class="dv">10</span>))</span></code></pre></div>
<pre><code>1024</code></pre>
<p>El resultado es el algoritmo binario, que demora tiempo&nbsp;<span class="math inline">O(\log{n})</span>, en versión recursiva.</p>
</section>
<section id="recursividad-vs.-iteración" class="level2">
<h2>Recursividad vs. Iteración</h2>
<p>Todo algoritmo iterativo puede escribirse recursivamente. En particular, cualquier ciclo de la forma</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> C:</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    A</span></code></pre></div>
<p>puede implementarse como</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f():</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C:</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>        A</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>        f()</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>f()</span></code></pre></div>
<p>Por cierto, en la llamada recursiva se le debe entregar a la función el contexto en que habría operado en la siguiente iteración del ciclo.</p>
<p>Por ejemplo, si queremos imprimir uno por uno los elementos de un arreglo&nbsp;<span class="math inline">a</span>, una forma iterativa de hacerlo sería:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir(a):</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span><span class="dv">0</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&lt;</span><span class="bu">len</span>(a):</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a[k])</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>        k<span class="op">+=</span><span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb133"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>np.random.random(<span class="dv">6</span>)</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>imprimir(a)</span></code></pre></div>
<pre><code>0.7033836563496955
0.6452018723083637
0.7390309665914873
0.7347873655983367
0.7866498089752649
0.6219100789368107</code></pre>
<p>En forma recursiva, esto queda como:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir(a):</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    imprimir_recursivo(a,<span class="dv">0</span>)</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir_recursivo(a,k): <span class="co"># imprimir desde a[k] en adelante</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k<span class="op">&lt;</span><span class="bu">len</span>(a):</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a[k])</span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>        imprimir_recursivo(a,k<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb136"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>np.random.random(<span class="dv">6</span>)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>imprimir(a)</span></code></pre></div>
<pre><code>0.48983219759773877
0.32335914035360247
0.9701200719987955
0.6556528043143391
0.5783404506167958
0.7588468412552624</code></pre>
<p>Este proceso es reversible: cuando una función recursiva lo último que hace es llamarse a sí misma, lo que se llama “recursividad a la cola” (“<em>tail recursion</em>”), eso se puede reemplazar por un <code>while</code>:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir(a):</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    imprimir_recursivo(a,<span class="dv">0</span>)</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir_recursivo(a,k): <span class="co"># imprimir desde a[k] en adelante, ahora NO recursivo</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&lt;</span><span class="bu">len</span>(a): <span class="co"># reemplazó a &quot;if k&lt;len(a):&quot;</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a[k])</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>        k<span class="op">+=</span><span class="dv">1</span> <span class="co"># reemplazó a &quot;imprimir_recursivo(a,k+1)&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb139"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>np.random.random(<span class="dv">6</span>)</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>imprimir(a)</span></code></pre></div>
<pre><code>0.5879986363022844
0.22292489446199648
0.3649081383243461
0.0760636478498492
0.6282506237409337
0.9933423327883073</code></pre>
<p>Pero ahora la función <code>imprimir_recursivo</code> es llamada desde un único lugar, con k=0, y por lo tanto, en ese lugar podemos sustituir la llamada por el código de la función, con lo que el resultado es:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir(a):</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Esto reemplaza a &quot;imprimir_recursivo(a,0)&quot;</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span><span class="dv">0</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&lt;</span><span class="bu">len</span>(a): <span class="co"># reemplazó a &quot;if k&lt;len(a):&quot;</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a[k])</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>        k<span class="op">+=</span><span class="dv">1</span> <span class="co"># reemplazó a &quot;imprimir_recursivo(a,k+1)&quot;&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb142"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>np.random.random(<span class="dv">6</span>)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>imprimir(a)</span></code></pre></div>
<pre><code>0.2796059938546853
0.7140250823437458
0.27114927650914356
0.1913138660755075
0.3131581564588708
0.13509564673494912</code></pre>
<p>¡Con lo cual hemos vuelto al punto de partida!</p>
<p>Sin embargo, esto solo funciona para eliminar la “recursividad a la cola.” Si hay llamadas recursivas que <strong>no</strong> son lo último que ejecuta la función, no pueden eliminarse con esta receta, y como veremos más adelante, requerirá el uso de una estructura llamada una “pila” (<em>stack</em>).</p>
<p>El siguiente ejemplo ilustra un caso en que esto ocurre.</p>
</section>
<section id="ejemplo-torres-de-hanoi" class="level2">
<h2>Ejemplo: Torres de Hanoi</h2>
<figure>
<img src="recursos/ColorHanoi.jpg" alt="Torres de Hanoi" /><figcaption aria-hidden="true">Torres de Hanoi</figcaption>
</figure>
<p>Este puzzle consiste en trasladar&nbsp;<span class="math inline">n</span> discos desde la estaca 1 a la estaca 3, respetando siempre las dos reglas siguientes: * Solo se puede mover de a un disco a la vez, y * Nunca puede haber un disco más grande sobre uno más chico Esto se puede resolver recursivamente de la siguiente manera:</p>
<figure>
<img src="recursos/hanoi.gif" alt="Torres de Hanoi" /><figcaption aria-hidden="true">Torres de Hanoi</figcaption>
</figure>
<p>Para mover&nbsp;<span class="math inline">n</span> discos desde&nbsp;<span class="math inline">a</span> hasta&nbsp;<span class="math inline">c</span> (usando la estaca&nbsp;<span class="math inline">b</span> como auxiliar): * Primero movemos (recursivamente)&nbsp;<span class="math inline">n-1</span> discos desde la estaca&nbsp;<span class="math inline">a</span> a la estaca&nbsp;<span class="math inline">b</span> * Una vez despejado el camino, movemos 1 disco desde&nbsp;<span class="math inline">a</span> hasta&nbsp;<span class="math inline">c</span> * Finalmente, movemos de nuevo (recursivamente) los&nbsp;<span class="math inline">n-1</span> discos, ahora desde&nbsp;<span class="math inline">b</span> hasta&nbsp;<span class="math inline">c</span> (usando&nbsp;<span class="math inline">a</span> como auxiliar)</p>
<p>El caso base es&nbsp;<span class="math inline">n=0</span>, en cuyo caso no se hace nada.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Hanoi(n, a, b, c): <span class="co"># Mover n discos desde &quot;a&quot; a &quot;c&quot;, usando &quot;b&quot; como auxiliar</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>        Hanoi(n<span class="op">-</span><span class="dv">1</span>, a, c, b)</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a, <span class="st">&quot;--&gt;&quot;</span>, c) <span class="co"># Mueve 1 disco desde &quot;a&quot; hasta &quot;c&quot;</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>        Hanoi(n<span class="op">-</span><span class="dv">1</span>, b, a, c)</span></code></pre></div>
<div class="sourceCode" id="cb145"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>Hanoi(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<pre><code>1 --&gt; 3
1 --&gt; 2
3 --&gt; 2
1 --&gt; 3
2 --&gt; 1
2 --&gt; 3
1 --&gt; 3</code></pre>
<p>Este algoritmo es muy claro y bastante intuitivo. Si aplicamos la regla de eliminación de “recursividad a la cola,” lo que resulta es un algoritmo equivalente, pero mucho menos trivial de entender:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Hanoi(n, a, b, c): <span class="co"># Mover n discos desde &quot;a&quot; a &quot;c&quot;, usando &quot;b&quot; como auxiliar</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> n<span class="op">&gt;</span><span class="dv">0</span>: <span class="co"># reemplaza a &quot;if n&gt;0:&quot;</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>        Hanoi(n<span class="op">-</span><span class="dv">1</span>, a, c, b)</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(a, <span class="st">&quot;--&gt;&quot;</span>, c) <span class="co"># Mueve 1 disco desde &quot;a&quot; hasta &quot;c&quot;</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>        n<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>        (a,b)<span class="op">=</span>(b,a) <span class="co"># reemplaza a &quot;Hanoi(n-1, b, a, c)&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb148"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>Hanoi(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<pre><code>1 --&gt; 3
1 --&gt; 2
3 --&gt; 2
1 --&gt; 3
2 --&gt; 1
2 --&gt; 3
1 --&gt; 3</code></pre>
<p>¿Puede usted dar una explicación intuitiva de por qué funciona este algoritmo?</p>
</section>
<section id="diagramas-de-estados" class="level2">
<h2>Diagramas de Estados</h2>
<p>Consideremos una instrucción iterativa con un invariante “I,” que se inicializa con instrucciones “B,” con condición de continuación “C,” con un cuerpo del ciclo consistente de instrucciones “A” y con el objetivo de lograr que se cumpla una afirmación lógica “F.” Esto tendría la estructura siguiente:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>B</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> C: <span class="co"># invariante I</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    A</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a><span class="co"># al terminar se debería cumplir F</span></span></code></pre></div>
<p>Anotando con un poco más de precisión, podemos identificar lo que se cumple en cada punto:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>B</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="co"># aquí se cumple el invariante &quot;I&quot; por primera vez</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> C:</span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># aquí se cumple &quot;I and C&quot;</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>    A</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># acá se debe cumplir nuevamente &quot;I&quot;</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a><span class="co"># al terminar el ciclo se cumple &quot;I and not C&quot;</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a><span class="co"># y eso debe implicar que se cumple F</span></span></code></pre></div>
<p>Esto se puede visualizar de manera más sencilla en un <strong>diagrama de estados</strong> como el siguiente:</p>
<figure>
<img src="recursos/state-diagram-1.png" alt="Diagrama de Estados 1" /><figcaption aria-hidden="true">Diagrama de Estados 1</figcaption>
</figure>
<p>En este diagrama: * Los estados (círculos) representan el estado del proceso en ese momento, descrito por la afirmación lógica correspondiente. En un ciclo, esa afirmación lógica es lo que hemos llamado invariante. * Un doble círculo representa a un estado final. * Las flechas pueden llevar como rótulo un “if” con una condición, que debe cumplirse para que se siga esa flecha, y también pueden estar rotuladas con una instrucción (o un bloque de instrucciones), que se ejecuta al hacer esa transición.</p>
<p>Una ventaja de modelar un algoritmo en base a un diagrama de estados es que no estamos restringidos solo a los diagramas simples que corresponden a ciclos <code>while</code>, sino que podemos construir diagramas mucho más complejos, con múltiples estados y transiciones.</p>
<p>Piensen por ejemplo en cómo modelar el funcionamiento de un <strong>cajero automático</strong>:</p>
<ul>
<li>El cajero está originalmente en un estado inicial, que es además el estado al cual regresa cada vez que concluye la atención de un cliente.</li>
<li>Cuando llega un cliente e inserta su tarjeta, el cajero debe verificar que la tarjeta es legible y si no es, debe devolverla con un mensaje de error y volver al estado inicial.</li>
<li>Si la tarjeta es legible, debe pedir que ingrese el PIN y pasar a otro estado en que espera que el cliente ingrese dicha clave.</li>
<li>Si la clave es incorrecta, debe pedir que la ingrese de nuevo y seguir en ese estado. Pero eso tiene un límite, porque si el usuario comete muchos errores, el cajero debe dar un mensaje de error, retener la tarjeta y volver al estado inicial.</li>
<li>Si la clave es correcta, debe mostrar un menú de posibles operaciones y esperar que el cliente seleccione una.</li>
<li>Si el cliente selecciona “Retirar dinero,” debe pasar a otro estado en que le pregunta el monto que quiere sacar.</li>
<li>Etc., etc., etc.,</li>
</ul>
<p>En realidad, el diagrama de estados de un cajero automático es enorme, porque en cada estado hay múltiples opciones que conducen a realizar acciones y trasladarse a otros estados. Además, hay “timeouts” que interrumpen el proceso si una operación se demora demasiado. El diagrama de estados es la herramienta que permite modelar este tipo de procesos complejos.</p>
</section>
<section id="ejemplo-contar-palabras" class="level2">
<h2>Ejemplo: Contar palabras</h2>
<p>Supongamos que tenemos un string que contiene una frase y queremos contar cuántas palabras contiene. Para simplificar, supondremos que una palabra es cualquier secuencia de caracteres distintos de un espacio en blanco. Por ejemplo, el string</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;    Algoritmos y    Estructuras  de   Datos   &quot;</span></span></code></pre></div>
<p>contiene 5 palabras.</p>
<p>Para resolver este problema, iremos examinando uno a uno los caracteres del string, y para cada uno deberemos decidir si ese caracter es el comienzo de una nueva palabra o no. Esto depende de si estábamos FUERA de una palabra (en cuyo caso sí es el inicio y hay que incrementar el contador de palabars) o si estábamos DENTRO de una palabra (en cuyo caso no se incrementa).</p>
<p>Esto sugiere tener un diagrama de estados con dos estados (FUERA y DENTRO), más un tercer estado final FIN, al que se llega cuando se agota el string.</p>
<p>El siguiente diagrama modela este proceso, donde el caracter que se está examinando en cada momento es&nbsp;<span class="math inline">s[k]</span>. Para simplificar, suponemos que las transiciones hacia FIN tienen prioridad. Además, como en cada transición se examina un nuevo caracter, dejaremos implícita la inicialización&nbsp;<span class="math inline">k=0</span> y el incremento&nbsp;<span class="math inline">k+=1</span> que hay después de cada transición.</p>
<figure>
<img src="recursos/state-diagram-2.png" alt="Diagrama de Estados 2" /><figcaption aria-hidden="true">Diagrama de Estados 2</figcaption>
</figure>
<p>Una vez modelado el proceso mediante un diagrama de estados, debemos escribirlo en forma de un programa. Veremos a continuación que <strong>hay más de una manera de hacerlo</strong>:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Contar palabras, versión 1 con variables de estado</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contar_palabras(s):</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    np<span class="op">=</span><span class="dv">0</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>    estado<span class="op">=</span><span class="st">&quot;FUERA&quot;</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(s)):</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> estado<span class="op">==</span><span class="st">&quot;FUERA&quot;</span>:</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[k]<span class="op">!=</span><span class="st">&#39; &#39;</span>:</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>                np<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>                estado<span class="op">=</span><span class="st">&quot;DENTRO&quot;</span></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># estado==&quot;DENTRO&quot;</span></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[k]<span class="op">==</span><span class="st">&#39; &#39;</span>:</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>                estado<span class="op">=</span><span class="st">&quot;FUERA&quot;</span></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np</span></code></pre></div>
<div class="sourceCode" id="cb154"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>s<span class="op">=</span><span class="bu">input</span>(<span class="st">&quot;Escriba frase: &quot;</span>)</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Hay&quot;</span>, contar_palabras(s), <span class="st">&quot;palabras&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb155"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Contar palabras, versión 2 con variables de estado</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contar_palabras(s):</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    np<span class="op">=</span><span class="dv">0</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>    estado<span class="op">=</span><span class="st">&quot;FUERA&quot;</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(s)):</span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[k]<span class="op">==</span><span class="st">&#39; &#39;</span>:</span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>            estado<span class="op">=</span><span class="st">&quot;FUERA&quot;</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># s[k]!=&#39; &#39;</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> estado<span class="op">==</span><span class="st">&quot;FUERA&quot;</span>:</span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>                np<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>            estado<span class="op">=</span><span class="st">&quot;DENTRO&quot;</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np</span></code></pre></div>
<div class="sourceCode" id="cb156"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>s<span class="op">=</span><span class="bu">input</span>(<span class="st">&quot;Escriba frase: &quot;</span>)</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Hay&quot;</span>, contar_palabras(s), <span class="st">&quot;palabras&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb157"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Contar palabras, versión sin variables de estado</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contar_palabras(s):</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    np<span class="op">=</span><span class="dv">0</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span><span class="dv">0</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&lt;</span><span class="bu">len</span>(s):</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Estamos en el estado FUERA</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[k]<span class="op">!=</span><span class="st">&#39; &#39;</span>:</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>            np<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>            k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ahora estamos en el estado DENTRO</span></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> k<span class="op">&lt;</span><span class="bu">len</span>(s) <span class="kw">and</span> s[k]<span class="op">!=</span><span class="st">&#39; &#39;</span>:</span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>                k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k<span class="op">==</span><span class="bu">len</span>(s):</span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Por descarte, s[k]==&#39; &#39;</span></span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a>        k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np</span></code></pre></div>
<div class="sourceCode" id="cb158"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>s<span class="op">=</span><span class="bu">input</span>(<span class="st">&quot;Escriba frase: &quot;</span>)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Hay&quot;</span>, contar_palabras(s), <span class="st">&quot;palabras&quot;</span>)</span></code></pre></div>
<hr />
<section id="ejercicio-1.4" class="level3">
<h3>Ejercicio 1.4</h3>
<p>Se le llama “Camel Case” a la convención de escribir una frase sin espacios, pero marcando el inicio de cada palabra poniendo su primera letra en mayúscula. Por ejemplo, la frase</p>
<pre><code>&quot;  Algoritmos y    estructuras de   datos   &quot;</code></pre>
<p>transformada a Camel Case queda así:</p>
<pre><code>&quot;AlgoritmosYEstructurasDeDatos&quot;</code></pre>
<p>Escriba una función que transforme a Camel Case y pruébela:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> CamelCase(s):</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Retorna un string conteniendo la versión Camel Case del string s&quot;&quot;&quot;</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># escriba aquí su algoritmo</span></span></code></pre></div>
<div class="sourceCode" id="cb162"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(CamelCase(<span class="st">&quot;    Algoritmos y    estructuras de   datos   &quot;</span>))</span></code></pre></div>
<hr />
</section>
</section>
</section>

<div id="lastupdate">
Last updated: jue mar  4 15:06:36 -05 2021
</div>
</article>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</body>
</html>
