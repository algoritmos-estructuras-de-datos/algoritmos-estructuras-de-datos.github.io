<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>shared-macros</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>



<div id="collapsiblemenu">
  <button class="collapsible">
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
  </button>
  <div class="content">
    <ul>
    <li><a href="index.html">Home</a></li>
    </ul>
    <ul>
    <li><a href="#ordenación">7 Ordenación</a>
    <ul>
    <li><a href="#cota-inferior">Cota inferior</a></li>
    <li><a href="#quicksort">Quicksort</a></li>
    <li><a href="#heapsort">Heapsort</a></li>
    <li><a href="#radix-sort">Radix Sort</a></li>
    <li><a href="#mergesort">Mergesort</a></li>
    </ul></li>
    </ul>
  </div>
</div>


<section id="ordenación" class="level1">
<h1>7 Ordenación</h1>
<p>El problema de ordenar un conjunto de datos (por ejemplo, en orden ascendente) tiene gran importancia tanto teórica como práctica. En esta sección veremos principalmente algoritmos que ordenan mediante comparaciones entre llaves, para los cuales se puede demostrar una cota inferior que coincide con la cota superior provista por varios algoritmos. También veremos un algoritmo de otro tipo, que al no hacer comparaciones, no está sujeto a esa cota inferior.</p>
<section id="cota-inferior" class="level2">
<h2>Cota inferior</h2>
<p>Supongamos que deseamos ordenar tres datos&nbsp;<span class="math inline">A</span>,&nbsp;<span class="math inline">B</span> y&nbsp;<span class="math inline">C</span>. La siguiente figura muestra un árbol de decisión posible para resolver este problema. Los nodos internos del árbol representan comparaciones y los nodos externos representan salidas emitidas por el programa.</p>
<figure>
<img src="recursos/arbol-decision-ordenacion.gif" alt="arbol-decision-ordenacion" /><figcaption aria-hidden="true">arbol-decision-ordenacion</figcaption>
</figure>
<p>Como se vio en el capítulo de búsqueda, todo árbol de decisión con&nbsp;<span class="math inline">H</span> hojas tiene al menos altura&nbsp;<span class="math inline">\log_2{H}</span>, y la altura del árbol de decisión es igual al número de comparaciones que se efectúan en el peor caso.</p>
<p>En un árbol de decisión para ordenar&nbsp;<span class="math inline">n</span> datos se tiene que&nbsp;<span class="math inline">H=n!</span>, y por lo tanto se tiene que todo algoritmo que ordene&nbsp;<span class="math inline">n</span> datos mediante comparaciones entre llaves debe hacer al menos&nbsp;<span class="math inline">\log_2{n!}</span> comparaciones en el peor caso.</p>
<p>Usando la aproximación de Stirling, se puede demostrar que&nbsp;<span class="math inline">\log_2{n!} = n \log_2{n} + \Theta(n)</span>, por lo cual la cota inferior es de&nbsp;<span class="math inline">\Theta(n\log{n})</span>.</p>
<p>Si suponemos que todas las posibles permutaciones resultantes son equiprobables, es posible demostrar también que el número promedio de comparaciones que cualquier algoritmo debe hacer es también de&nbsp;<span class="math inline">\Theta(n\log{n})</span>.</p>
</section>
<section id="quicksort" class="level2">
<h2>Quicksort</h2>
<p>Este método fue inventado por C.A.R. Hoare a comienzos de los ’60s, y sigue siendo el método más eficiente para uso general.</p>
<p>Quicksort es un ejemplo clásico de la aplicación del principio de <em>dividir para reinar</em>. Su estructura es la siguiente:</p>
<ul>
<li><p>Primero se elige un elemento al azar, que se denomina el pivote.</p></li>
<li><p>El arreglo a ordenar se reordena dejando a la izquierda a los elementos menores que el pivote, el pivote al medio, y a la derecha los elementos mayores que el pivote:</p></li>
</ul>
<figure>
<img src="recursos/particion.gif" alt="particion" /><figcaption aria-hidden="true">particion</figcaption>
</figure>
<ul>
<li>Luego cada sub-arreglo se ordena recursivamente.</li>
</ul>
<p>La recursividad termina, en principio, cuando se llega a sub-arreglos de tamaño cero o uno, los cuales trivialmente ya están ordenados. En la práctica veremos que es preferible detener la recursividad antes de eso, para no desperdiciar tiempo ordenando recursivamente arreglos pequeños, los cuales pueden ordenarse más eficientemente usando Ordenación por Inserción, por ejemplo.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort(a):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    qsort(a,<span class="dv">0</span>,<span class="bu">len</span>(a)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qsort(a,i,j): <span class="co"># ordena a[i],...,a[j]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">&lt;</span>j: <span class="co"># quedan 2 o más elementos por ordenar</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span>particion(a,i,j)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        qsort(a,i,k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        qsort(a,k<span class="op">+</span><span class="dv">1</span>,j)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> particion(a,i,j): <span class="co"># particiona a[i],...,a[j], retorna posición del pivote</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.random.randint(i,j) <span class="co"># genera un número al azar k en rango i..j</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    (a[i],a[k])<span class="op">=</span>(a[k],a[i]) <span class="co"># mueve a[k] al extremo izquierdo</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># a[i] es el pivote</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span>i <span class="co"># invariante: a[i+1..s]&lt;=a[i], a[s+1..t]&gt;a[i]</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(s,j):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[t<span class="op">+</span><span class="dv">1</span>]<span class="op">&lt;=</span>a[i]:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            (a[s<span class="op">+</span><span class="dv">1</span>],a[t<span class="op">+</span><span class="dv">1</span>])<span class="op">=</span>(a[t<span class="op">+</span><span class="dv">1</span>],a[s<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            s<span class="op">=</span>s<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># mover pivote al centro</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    (a[i],a[s])<span class="op">=</span>(a[s],a[i])</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chequea_orden(a):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Ordenado&quot;</span> <span class="cf">if</span> np.<span class="bu">all</span>(a[:<span class="op">-</span><span class="dv">1</span>]<span class="op">&lt;=</span>a[<span class="dv">1</span>:]) <span class="cf">else</span> <span class="st">&quot;Desordenado&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">12</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>chequea_orden(a)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>quicksort(a)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>chequea_orden(a)</span></code></pre></div>
<pre><code>[0.21939313 0.41324672 0.99870279 0.15140399 0.33302848 0.92304672
 0.11206401 0.63418302 0.64504804 0.50401626 0.2064129  0.81939607]
Desordenado
[0.11206401 0.15140399 0.2064129  0.21939313 0.33302848 0.41324672
 0.50401626 0.63418302 0.64504804 0.81939607 0.92304672 0.99870279]
Ordenado</code></pre>
<section id="costo-promedio-de-quicksort" class="level3">
<h3>Costo promedio de Quicksort</h3>
<p>Si suponemos, como una primera aproximación, que el pivote siempre resulta ser la mediana del conjunto, entonces el costo de ordenar está dado (aproximadamente) por la ecuación de recurrencia</p>
<p><span class="math display">
T(n)=n+2T\left( \frac{n}{2} \right)
</span></p>
<p>Esto tiene solución&nbsp;<span class="math inline">T(n) = n \log_2{n}</span> y es, en realidad, el <em>mejor</em> caso de Quicksort.</p>
<p>Para analizar el tiempo promedio que demora la ordenación mediante Quicksort, observemos que el funcionamiento de Quicksort puede graficarse mediante un <em>árbol de partición</em>:</p>
<figure>
<img src="recursos/arbol-particion.gif" alt="arbol-particion" /><figcaption aria-hidden="true">arbol-particion</figcaption>
</figure>
<p>Por la forma en que se construye, es fácil ver que el árbol de partición es un <em>árbol de búsqueda binaria</em>, y como el pivote es escogido al azar, entonces la raíz de cada subárbol puede ser cualquiera de los elementos del conjunto en forma equiprobable. En consecuencia, los árboles de partición y los árboles de búsqueda binaria tienen exactamente la misma distribución.</p>
<p>En el proceso de partición, cada elemento de los subárboles ha sido comparado contra la raíz (el pivote). Al terminar el proceso, cada elemento ha sido comparado contra todos sus ancestros. Si sumamos todas estas comparaciones, el resultado total es igual al <em>largo de caminos internos</em>.</p>
<p>Usando todas estas correspondencias, tenemos que, usando los resultados ya conocidos para árboles, el número promedio de comparaciones que realiza Quicksort es de:</p>
<p><span class="math display">
T(n)=1.38 n\log_2{n}+\Theta(n)
</span></p>
<p>Por lo tanto, Quicksort, en el caso esperado, corre en un tiempo proporcional a la cota inferior.</p>
</section>
<section id="peor-caso-de-quicksort" class="level3">
<h3>Peor caso de Quicksort</h3>
<p>El peor caso de Quicksort se produce cuando el pivote resulta ser siempre el mínimo o el máximo del conjunto. En este caso la ecuación de recurrencia es</p>
<p><span class="math display">
T(n) = n - 1 + T(n-1)
</span></p>
<p>lo que tiene solución&nbsp;<span class="math inline">T(n) = \Theta(n^2)</span>. Desde el punto de vista del árbol de partición, esto corresponde a un árbol en “zig-zag.”</p>
<p>Si bien este peor caso es extremadamente improbable si el pivote se escoge al azar, algunas implementaciones de Quicksort toman como pivote al primer elemento del arreglo (suponiendo que, al venir el arreglo al azar, entonces el primer elemento es tan aleatorio como cualquier otro). El problema es que si el conjunto viene en realidad ordenado, entonces caemos justo en el peor caso cuadrático.</p>
<p>Lo anterior refuerza la importancia de que el pivote se escoja al azar. Esto no aumenta significativamente el costo total, porque el número total de elecciones de pivote es&nbsp;<span class="math inline">\Theta(n)</span>.</p>
</section>
<section id="mejoras-a-quicksort" class="level3">
<h3>Mejoras a Quicksort</h3>
<p>Quicksort puede ser optimizado de varias maneras, pero hay que ser muy cuidadoso con estas mejoras, porque es fácil que terminen empeorando el desempeño del algoritmo.</p>
<p>En primer lugar, es desaconsejable hacer cosas que aumenten la cantidad de trabajo que se hace dentro del “loop” de partición, porque este es el lugar en donde se concentra el costo&nbsp;<span class="math inline">\Theta(n \log{n})</span>.</p>
<p>Algunas de las mejoras que han dado buen resultado son las siguientes:</p>
<section id="quicksort-con-mediana-de-3" class="level4">
<h4>Quicksort con “mediana de 3”</h4>
<p>En esta variante, el pivote no se escoge como un elemento tomado al azar, sino que primero se extrae una muestra de 3 elementos, y entre ellos se escoge a la mediana de esa muestra como pivote.</p>
<p>Si la muestra se escoge tomando al primer elemento del arreglo, al del medio y al último, entonces lo que era el peor caso (arreglo ordenado) se transforma de inmediato en mejor caso.</p>
<p>De todas formas, es aconsejable que la muestra se escoja al azar, y en ese caso el análisis muestra que el costo esperado para ordenar n elementos es</p>
<p><span class="math display">
\frac{12}{7} n \ln{n}  \approx  1.19 n \log_2{n}
</span></p>
<p>Esta reducción en el costo se debe a que el pivote es ahora una mejor aproximación a la mediana. De hecho, si en lugar de escoger una muestra de tamaño 3, lo hiciéramos con tamaños como 7, 9, etc., se lograría una reducción aún mayor, acercándonos cada vez más al óptimo, pero con rendimientos rápidamente decrecientes.</p>
<hr />
</section>
</section>
<section id="ejercicio-7.1-quicksort-con-mediana-de-3" class="level3">
<h3>Ejercicio 7.1 (Quicksort con mediana de 3)</h3>
<p>Modifique el algoritmo Quicksort para que en la fase de partición utilice como pivote a la mediana de 3 elementos elegidos al azar.</p>
<p>Para esto, se recomienda modificar el algoritmo de partición de modo que seleccione 3 elementos al azar en el rango&nbsp;<span class="math inline">i..j</span> y los ordene, dejando en&nbsp;<span class="math inline">a[i]</span> el mínimo de los 3, en&nbsp;<span class="math inline">a[i+1]</span> la mediana de los 3 y en&nbsp;<span class="math inline">a[j]</span> el máximo de los 3. Luego, se aplica el algoritmo de partición ya conocido al segmento&nbsp;<span class="math inline">a[i+2],\ldots,a[j-1]</span>, con&nbsp;<span class="math inline">a[i+1]</span> como pivote. Al terminar, el pivote se mueve al centro y se retorna su posición.</p>
<p>Otro cambio que se debe hacer es tratar los casos de arreglos de tamaño&nbsp;<span class="math inline">0</span>,&nbsp;<span class="math inline">1</span> y&nbsp;<span class="math inline">2</span> como casos de borde, y aplicar <code>qsort</code> recursivo solo a arreglos de tamaño mayor o igual a 3.</p>
<p>En el siguiente recuadro escriba su algoritmo modificado y luego ejecute las instrucciones de prueba del recuadro siguiente.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort3(a):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span> <span class="co"># reemplace esto por su programa</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">12</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>chequea_orden(a)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>quicksort3(a)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>chequea_orden(a)</span></code></pre></div>
<pre><code>[0.72391606 0.16663225 0.25313304 0.7389159  0.60516548 0.69447401
 0.56282635 0.44320546 0.81602    0.62844513 0.99977674 0.15667959]
Desordenado
[0.72391606 0.16663225 0.25313304 0.7389159  0.60516548 0.69447401
 0.56282635 0.44320546 0.81602    0.62844513 0.99977674 0.15667959]
Desordenado</code></pre>
<hr />
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
<section id="uso-de-ordenación-por-inserción-para-ordenar-sub-arreglos-pequeños" class="level4">
<h4>Uso de Ordenación por Inserción para ordenar sub-arreglos pequeños</h4>
<p>Tal como se dijo antes, no es eficiente ordenar recursivamente sub-arreglos demasiado pequeños.</p>
<p>En lugar de esto, se puede establecer un tamaño mínimo&nbsp;<span class="math inline">M</span>, de modo que los sub-arreglos de tamaño menor que esto se ordenan por inserción en lugar de por Quicksort.</p>
<p>Claramente debe haber un valor óptimo para&nbsp;<span class="math inline">M</span>, porque si creciera indefinidamente se llegaría a un algoritmo cuadrático. Esto se puede analizar, y el óptimo es cercano a 10.</p>
<p>Como método de implementación, al detectarse un sub-arreglo de tamaño menor que&nbsp;<span class="math inline">M</span>, se lo puede dejar simplemente sin ordenar, retornando de inmediato de la recursividad. Al final del proceso, se tiene un arreglo cuyos pivotes están en orden creciente, y encierran entre ellos a bloques de elementos desordenados, pero que ya están en el grupo correcto. Para completar la ordenación, entonces, basta con hacer una sola gran pasada de Ordenación por Inserción, la cual ahora no tiene costo&nbsp;<span class="math inline">\Theta(n^2)</span>, sino&nbsp;<span class="math inline">\Theta(nM)</span>, porque ningún elemento está a distancia mayor que&nbsp;<span class="math inline">M</span> de su ubicación definitiva.</p>
</section>
<section id="ordenar-recursivamente-sólo-el-sub-arreglo-más-pequeño" class="level4">
<h4>Ordenar recursivamente sólo el sub-arreglo más pequeño</h4>
<p>Un problema potencial con Quicksort es la profundidad que puede llegar a tener la recursividad. En el peor caso, ésta puede llegar a ser&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Para evitar esto, se puede usar recursividad solo para la “mitad” más pequeña, y ordenar la otra “mitad” de manera iterativa. Con este enfoque, cada llamada recursiva se aplica a un sub-arreglo cuyo tamaño es a lo más la mitad del tamaño del arreglo a ordenar, de modo que si llamamos&nbsp;<span class="math inline">S(n)</span> a la profundidad de recursión, tenemos que</p>
<p><span class="math display">
S(n) \le 1 + S\left(\frac{n}{2}\right)
</span></p>
<p>lo cual tiene solución&nbsp;<span class="math inline">\log_2{n}</span>, de modo que la profundidad de la recursión nunca es más que logarítmica.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qsort(a,i,j): <span class="co"># ordena a[i],...,a[j]</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i<span class="op">&lt;</span>j: <span class="co"># quedan 2 o más elementos por ordenar</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span>particion(a,i,j)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">-</span>i<span class="op">&lt;=</span>j<span class="op">-</span>k: <span class="co">#mitad izquierda es más pequeña</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            qsort(a,i,k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            i<span class="op">=</span>k<span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            qsort(a,k<span class="op">+</span><span class="dv">1</span>,j)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>k<span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>quicksort(a)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.66656624 0.76798384 0.87811887 0.74763235 0.30180187 0.82056957]
[0.30180187 0.66656624 0.74763235 0.76798384 0.82056957 0.87811887]</code></pre>
</section>
</section>
<section id="un-algoritmo-de-selección-basado-en-quicksort" class="level3">
<h3>Un algoritmo de selección basado en Quicksort</h3>
<p>Es posible modificar el algoritmo de Quicksort para seleccionar el&nbsp;<span class="math inline">k</span>-ésimo elemento de un arreglo&nbsp;<span class="math inline">a[0],\ldots,a[n-1]</span>, esto es, el elemento que quedaría en la posición&nbsp;<span class="math inline">a[k]</span> si el arreglo se ordenara. Una solución trivial sería, precisamente, ordenar el arreglo y retornar ese elemento, pero la pregunta es si eso se puede hacer de manera más eficiente.</p>
<p>Una idea para resolver este problema idea es ejecutar Quicksort, pero en lugar de ordenar las dos mitades, hacerlo solo con aquella mitad en donde se encontraría el elemento buscado, o incluso no hacer nada si tenemos suerte y el pivote quedó justo en la posición&nbsp;<span class="math inline">a[k]</span>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quickselect(a,k):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> k<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> k<span class="op">&lt;</span><span class="bu">len</span>(a)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    qselect(a,k,<span class="dv">0</span>,<span class="bu">len</span>(a)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a[k]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qselect(a,k,i,j): <span class="co"># selecciona el elemento que quedaría en a[k]</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                      <span class="co"># si se ordenara a[i],...,a[j] (i&lt;=k&lt;=j)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">&lt;</span>j:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span>particion(a,i,j)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p<span class="op">!=</span>k:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k<span class="op">&lt;</span>p:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                qselect(a,k,i,p<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                qselect(a,k,p<span class="op">+</span><span class="dv">1</span>,j)</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>k<span class="op">=</span><span class="bu">int</span>(<span class="bu">input</span>(<span class="st">&quot;k=&quot;</span>))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(quickselect(a,k))</span></code></pre></div>
<pre><code>[0.19052461 0.578469   0.14702632 0.62380414 0.21373454 0.59978106]
k=4
0.5997810643996624</code></pre>
<p>En realidad la recursividad de <code>qselect</code> es fácil de transformar en iteración, y una vez hecho eso ya no hay razón para que sea una función aparte:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quickselect(a,k):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> k<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> k<span class="op">&lt;</span><span class="bu">len</span>(a)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span><span class="bu">len</span>(a)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i<span class="op">&lt;</span>j:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span>particion(a,i,j)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p<span class="op">==</span>k:</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">&lt;</span>p:</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>p<span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>            i<span class="op">=</span>p<span class="op">+</span><span class="dv">1</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a[k]</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>k<span class="op">=</span><span class="bu">int</span>(<span class="bu">input</span>(<span class="st">&quot;k=&quot;</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(quickselect(a,k))</span></code></pre></div>
<pre><code>[0.28147833 0.06014974 0.56597127 0.42582274 0.66869136 0.11621771]
k=3
0.4258227414342961</code></pre>
<p>El análisis del costo esperado de Quickselect es complicado, pero se puede demostrar que es&nbsp;<span class="math inline">\Theta(n)</span>. Por otra parte, el peor caso se da cuando el pivote cae siempre en un extremo, y en ese caso el costo es&nbsp;<span class="math inline">\Theta(n^2)</span>.</p>
</section>
<section id="un-algoritmo-de-selección-de-tiempo-lineal-en-el-peor-caso" class="level3">
<h3>Un algoritmo de selección de tiempo lineal en el peor caso</h3>
<p>La razón por la cual el algoritmo <code>Quickselect</code> puede demorar tiempo cuadrático en el peor caso es que el pivote puede resultar ser siempre el mínimo o el máximo, o un elemento muy cercano a los extremos.</p>
<p>Esta debilidad se subsanaría si pudiéramos garantizar que los elementos que quedan a cada lado del pivote son siempre al menos una cierta fracción fija del total, digamos&nbsp;<span class="math inline">\alpha n</span>, para algún&nbsp;<span class="math inline">\alpha \in (0,\frac12)</span>.</p>
<p>Una forma de lograrlo es la siguiente. Dividamos el conjunto completo de&nbsp;<span class="math inline">n</span> elementos en grupos de tamaño&nbsp;<span class="math inline">5</span>, y encontremos la mediana de cada uno de estos pequeños conjuntos. Cada uno de ellos se puede visualizar como un orden parcial de la forma</p>
<figure>
<img src="recursos/spider.png" alt="spider" /><figcaption aria-hidden="true">spider</figcaption>
</figure>
<p>donde los dos elementos de arriba son mayores que la mediana, y ésta es mayor que los dos de abajo.</p>
<p>A continuación, aplicamos este mismo algoritmo, recursivamente, para encontrar la <strong>mediana de las medianas</strong>. Este elemento, que se muestra encerrado en un círculo en el diagrama siguiente, será nuestro pivote:</p>
<figure>
<img src="recursos/median-of-medians.png" alt="median-of-medians" /><figcaption aria-hidden="true">median-of-medians</figcaption>
</figure>
<p>Como se ve, todos los elementos encerrados en las líneas punteadas están garantizados de estar por sobre o por debajo del pivote, respectivamente. Por lo tanto, en el peor caso, podemos garantizar que al menos&nbsp;<span class="math inline">\frac{3}{10}n</span> elementos son menores que el pivote, otros&nbsp;<span class="math inline">\frac{3}{10}n</span> son mayores que él.</p>
<p>Por lo tanto, en el peor caso, la llamada recursiva que se hace para continuar el proceso se aplica a un conjunto de a lo más&nbsp;<span class="math inline">\frac{7}{10}n</span> elementos.</p>
<p>Si llamamos&nbsp;<span class="math inline">T(n)</span> al tiempo que demora este algoritmo en el peor caso, y si&nbsp;<span class="math inline">cn</span> es el tiempo que demora encontrar las medianas de los&nbsp;<span class="math inline">n/5</span> subconjuntos, para alguna constante&nbsp;<span class="math inline">c</span>, entonces tenemos que, en el peor caso,</p>
<p><span class="math display">
T(n)=cn+T\left(\frac{n}{5}\right)+T\left(\frac{7n}{10}\right)
</span></p>
<p>Esta ecuación tiene solución lineal. En efecto, supongamos que existe una constante&nbsp;<span class="math inline">d</span> tal que&nbsp;<span class="math inline">T(n)=dn</span>. Reemplazando en la ecuación, tenemos</p>
<p><span class="math display">
dn=cn+\frac{dn}{5}+\frac{7dn}{10}
</span></p>
<p>de donde podemos despejar&nbsp;<span class="math inline">d</span> y obtener&nbsp;<span class="math inline">d=10c</span>. Por lo tanto,&nbsp;<span class="math inline">T(n)=10cn</span>, y el algoritmo demora tiempo&nbsp;<span class="math inline">\Theta(n)</span> en el peor caso.</p>
<p>La razón por la cual la ecuación admite solución lineal es porque los coeficientes de&nbsp;<span class="math inline">n</span> en las llamadas recursivas suman&nbsp;<span class="math inline">\frac{1}{5}+\frac{7}{10}&lt;1</span>. Eso explica por qué no habría funcionado haber dividido el conjunto en grupos de tamaño 3. En ese caso, los coeficientes habrían sido&nbsp;<span class="math inline">\frac{1}{3}</span> y&nbsp;<span class="math inline">\frac{2}{3}</span> respectivamente, y su suma no sería menor que&nbsp;<span class="math inline">1</span>.</p>
</section>
</section>
<section id="heapsort" class="level2">
<h2>Heapsort</h2>
<p>A partir de cualquier implementación de una cola de prioridad es posible obtener un algoritmo de ordenación. El esquema del algoritmo es:</p>
<ul>
<li>Comenzar con una cola de prioridad vacía.</li>
<li><em>Fase de construcción de la cola de prioridad</em>: Traspasar todos los elementos del conjunto que se va a ordenar a la cola de prioridad, mediante <span class="math inline">n</span> inserciones.</li>
<li><em>Fase de ordenación</em>: Sucesivamente extraer el máximo <span class="math inline">n</span> veces. Los elementos van apareciendo en orden decreciente y se van almacenando en el conjunto de salida.</li>
</ul>
<p>Si aplicamos esta idea a las dos implementaciones simples de colas de prioridad, utilizando lista enlazada ordenada y lista enlazada desordenada, se obtienen los algoritmos de ordenación por Inserción y por Selección, respectivamente. Ambos son algoritmos cuadráticos, pero es posible que una mejor implementación lleve a un algoritmo más rápido. En el capítulo de <em>Pilas y Colas</em> vimos que una forma de obtener una implementación eficiente de colas de prioridad es utilizando una estructura de datos llamada <em>heap</em>.</p>
<section id="implementación-de-heapsort" class="level3">
<h3>Implementación de Heapsort</h3>
<p>Al utilizar un heap como implementación de una cola de prioridad para construir un algoritmo de ordenación, se obtiene un algoritmo llamado <em>Heapsort</em>, para el cual resulta que tanto la fase de construcción de la cola de prioridad, como la fase de ordenación, tienen ambas costo&nbsp;<span class="math inline">\Theta(n \log{n})</span>, de modo que el algoritmo completo tiene ese mismo costo.</p>
<p>Por lo tanto, Heapsort tiene un orden de magnitud que coincide con la cota inferior, esto es, es óptimo incluso en el peor caso. Nótese que esto no era así para Quicksort, el cual era óptimo en promedio, pero no en el peor caso.</p>
<p>De acuerdo a la descripción de esta familia de algoritmos, daría la impresión de que en la fase de construcción del heap se requeriría un arreglo aparte para el heap, distinto del arreglo de entrada. De la misma manera, se requeriría un arreglo de salida aparte, distinto del heap, para recibir los elementos a medida que van siendo extraídos en la fase de ordenación.</p>
<p>En la práctica, esto no es necesario y basta con un sólo arreglo: todas las operaciones pueden efectuarse directamente sobre el arreglo de entrada.</p>
<p>En primer lugar, en cualquier momento de la ejecución del algoritmo, los elementos se encuentran particionados entre aquellos que están ya o aún formando parte del heap, y aquellos que se encuentran aún en el conjunto de entrada, o ya se encuentran en el conjunto de salida, según sea la fase. Como ningún elemento puede estar en más de un conjunto a la vez, es claro que, en todo momento, en total nunca se necesita más de&nbsp;<span class="math inline">n</span> casilleros de memoria, si la implementación se realiza bien.</p>
<p>En el caso de Heapsort, durante la fase de construcción del heap, podemos utilizar las celdas de la izquierda del arreglo para ir “armando” el heap. Las celdas necesarias para ello se las vamos “quitando” al conjunto de entrada, el cual va perdiendo elementos a medida que van “trepando” en el heap. Al concluir esta fase, todos los elementos han sido insertados, y el arreglo completo es un solo gran heap.</p>
<figure>
<img src="recursos/heap-cons.gif" alt="heap-cons" /><figcaption aria-hidden="true">heap-cons</figcaption>
</figure>
<p>En la fase de ordenación, se van extrayendo elementos del heap, con lo cual éste se contrae de tamaño y deja espacio libre al final, el cual puede ser justamente ocupado para ir almacenando los elementos a medida que van saliendo del heap (recordemos que van apareciendo en orden decreciente).</p>
<figure>
<img src="recursos/heap-ord.gif" alt="heap-ord" /><figcaption aria-hidden="true">heap-ord</figcaption>
</figure>
</section>
<section id="optimización-de-la-fase-de-construcción-del-heap" class="level3">
<h3>Optimización de la fase de construcción del heap</h3>
<p>Como se ha señalado anteriormente, tanto la fase de construcción del heap como la de ordenación demoran tiempo&nbsp;<span class="math inline">\Theta(n \log{n})</span>. Esto es el mínimo posible (en orden de magnitud), de modo que no es posible mejorarlo significativamente.</p>
<p>Sin embargo, es posible modificar la implementación de la fase de construcción del heap para que sea mucho más eficiente.</p>
<p>La idea es invertir el orden de las “mitades” del arreglo, haciendo que el “input” esté a la izquierda y el “heap” a la derecha.</p>
<p>En realidad, si el “heap” está a la derecha, entonces no es realmente un heap, porque no es un árbol completo (le falta la parte superior), pero sólo nos interesa que en ese sector del arreglo se cumplan las relaciones de orden entre cada padre y sus hijos. En cada iteración, se toma el último elemento del “input” y se le “hunde” dentro del heap de acuerdo a su nivel de prioridad.</p>
<figure>
<img src="recursos/heap-cons2.gif" alt="heap-cons2" /><figcaption aria-hidden="true">heap-cons2</figcaption>
</figure>
<p>Al concluir, se llega igualmente a un heap completo, pero el proceso es significativamente más rápido.</p>
<p>La razón es que, al ser “hundido,” un elemento paga un costo proporcional a su distancia al fondo del árbol. Dada las características de un árbol, la gran mayoría de los elementos están al fondo o muy cerca de él, por lo cual pagan un costo muy bajo. En un análisis aproximado, la mitad de los elementos pagan 0 (ya están al fondo), la cuarta parte paga 1, la octava parte paga 2, etc. Sumando todo esto, tenemos que el costo total está acotado por</p>
<p><span class="math display">
n \sum_{i\ge 0}{\frac{i}{2^{i+1}}}
</span></p>
<p>lo cual es igual a&nbsp;<span class="math inline">n</span>.</p>
<p>En la práctica, al comenzar a construir el heap “de abajo hacia arriba,” no hace falta examinar los elementos que no tienen hijos, porque ellos cumplen automáticamente la relación de orden. Por lo tanto, basta comenzar a examinar los elementos desde el casillero&nbsp;<span class="math inline">\lfloor \frac{n}{2} \rfloor-1</span> hacia atrás.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hundir(a,j,n): <span class="co"># El elemento a[j] se hunde hasta su nivel de prioridad</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="dv">2</span><span class="op">*</span>j<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>n: <span class="co"># mientras tenga al menos 1 hijo</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span><span class="dv">2</span><span class="op">*</span>j<span class="op">+</span><span class="dv">1</span> <span class="co"># el hijo izquierdo</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>n <span class="kw">and</span> a[k<span class="op">+</span><span class="dv">1</span>]<span class="op">&gt;</span>a[k]: <span class="co"># el hijo derecho existe y es mayor</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[j]<span class="op">&gt;=</span>a[k]: <span class="co"># tiene mejor prioridad que ambos hijos</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        (a[j],a[k])<span class="op">=</span>(a[k],a[j]) <span class="co"># se intercambia con el mayor de los hijos</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        j<span class="op">=</span>k <span class="co"># bajamos al lugar del mayor de los hijos</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heapsort(a):</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fase de construcción del heap</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        hundir(a,i,n)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fase de ordenación</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        (a[<span class="dv">0</span>],a[i])<span class="op">=</span>(a[i],a[<span class="dv">0</span>])</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        hundir(a,<span class="dv">0</span>,i)</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>heapsort(a)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.58123276 0.57772293 0.22690173 0.49691097 0.78430617 0.16308228]
[0.16308228 0.22690173 0.49691097 0.57772293 0.58123276 0.78430617]</code></pre>
</section>
</section>
<section id="radix-sort" class="level2">
<h2>Radix Sort</h2>
<p>Los métodos anteriores operan mediante comparaciones de llaves, y están sujetos, por lo tanto, a la cota inferior&nbsp;<span class="math inline">\Omega(n \log{n})</span>. Veremos a continuación el método <em>Radix Sort</em> (llamado también <em>Bucket Sort</em>), que opera de una manera distinta, y logra ordenar el conjunto en tiempo lineal.</p>
<p>Supongamos que queremos ordenar&nbsp;<span class="math inline">n</span> números, cada uno de ellos compuesto de&nbsp;<span class="math inline">k</span> dígitos decimales. El siguiente es un ejemplo con&nbsp;<span class="math inline">n=10</span>,&nbsp;<span class="math inline">k=5</span>.</p>
<pre><code>    73895
    93754
    82149
    99046
    04853
    94171
    54963
    70471
    80564
    66496</code></pre>
<p>Para comenzar, veamos cómo podemos ordenar el conjunto, en una pasada, si la llave de ordenación fuera uno solo de los dígitos, por ejemplo el tercero de izquierda a derecha (lo mostramos separado para destacarlo):</p>
<pre><code>    99 0 46
    82 1 49
    94 1 71
    70 4 71
    66 4 96
    80 5 64
    93 7 54
    73 8 95
    04 8 53
    54 9 63</code></pre>
<p>La forma de hacerlo es la siguiente. Llamemos&nbsp;<span class="math inline">j</span> a la posición del dígito mediante el cual se ordena. La ordenación se puede hacer utilizando una cola de entrada, que contiene al conjunto a ordenar, y un arreglo de 10 colas de salida, subindicadas de 0 a 9. Los elementos se van sacando de la cola de entrada y se van encolando en la cola de salida&nbsp;<span class="math inline">Q[d_j]</span>, donde&nbsp;<span class="math inline">d_j</span> es el&nbsp;<span class="math inline">j</span>-ésimo dígito del elemento que se está transfiriendo.</p>
<figure>
<img src="recursos/bucket-pass.gif" alt="bucket-pass" /><figcaption aria-hidden="true">bucket-pass</figcaption>
</figure>
<p>Al terminar este proceso, los elementos están separados por dígito. Para completar la ordenación, basta concatenar las&nbsp;<span class="math inline">k</span> colas de salida y formar nuevamente una sola cola con todos los elementos.</p>
<p>Este proceso se hace en una pasada sobre los datos, y toma tiempo&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Para ordenar el conjunto por las llaves completas, ejecutamos este proceso dígito por dígito, <em>de derecha a izquierda</em>, en cada pasada separando los elementos según el valor del dígito respectivo, luego recolectándolos para formar una sola cola, y realimentando el proceso con esos mismos datos. El conjunto completo queda finalmente ordenado (¡esto <em>no</em> es obvio!).</p>
<p>Como hay que realizar&nbsp;<span class="math inline">k</span> pasadas y cada una de ellas toma tiempo&nbsp;<span class="math inline">\Theta(n)</span>, el tiempo total es&nbsp;<span class="math inline">\Theta(kn)</span>, que es el tamaño total del archivo de entrada (en bytes). Por lo tanto, la ordenación toma tiempo lineal en el tamaño de los datos.</p>
<p>El proceso anterior se puede generalizar para cualquier alfabeto, no sólo dígitos (por ejemplo, ASCII). Esto aumenta el número de colas de salida, pero no cambia sustancialmente el tiempo que demora el programa.</p>
<hr />
<section id="ejercicio-7.2-radix-sort" class="level3">
<h3>Ejercicio 7.2 (Radix Sort)</h3>
<p>Ordene el conjunto</p>
<pre><code>    73895
    93754
    82149
    99046
    04853
    94171
    54963
    70471
    80564
    66496</code></pre>
<p>usando Radix Sort. Muestre el estado del conjunto después cada pasada (una pasada consiste en la separación en grupos de acuerdo a los dígitos presentes en la columna que se está procesando, seguida de la concatenación de los grupos resultantes). Recuerde que las columnas se procesan de derecha a izquierda.</p>
<hr />
</section>
<section id="el-tiempo-es-lineal-pero-es-thetan" class="level3">
<h3>El tiempo es lineal, pero ¿es <span class="math inline">\Theta(n)</span>?</h3>
<p>Como&nbsp;<span class="math inline">k</span> es un parámetro (<span class="math inline">k=5</span> en nuestro ejemplo), es tentador decir que&nbsp;<span class="math inline">\Theta(kn)=\Theta(n)</span>, pero en realidad no es tan simple.</p>
<p>Si fijamos&nbsp;<span class="math inline">k</span>, entonces el máximo número de elementos distintos que podemos generar es&nbsp;<span class="math inline">10^k</span>. Por lo tanto,&nbsp;<span class="math inline">n\le 10^k</span>, es decir,&nbsp;<span class="math inline">k\ge \log_{10}{n}</span>.</p>
<p>Por lo tanto,&nbsp;<span class="math inline">k</span> no puede ser constante, sino que tiene que crecer logarítmicamente con&nbsp;<span class="math inline">n</span>, de modo que el algoritmo en realidad demora tiempo&nbsp;<span class="math inline">\Omega(n\log{n})</span>.</p>
</section>
<section id="archivos-con-records-de-largo-variable" class="level3">
<h3>Archivos con records de largo variable</h3>
<p>Si las líneas a ordenar no son todas del mismo largo, es posible alargarlas hasta completar el largo máximo, con lo cual el algoritmo anterior es aplicable. Pero si hay algunas pocas líneas desproporcionadamente largas y otras muy cortas, se puede perder mucha eficiencia.</p>
<p>Es posible, aunque no lo vamos a ver aquí, generalizar este algoritmo para ordenar líneas de largo variable sin necesidad de alargarlas. El resultado es que la ordenación se sigue realizando en tiempo proporcional al tamaño del archivo.</p>
</section>
</section>
<section id="mergesort" class="level2">
<h2>Mergesort</h2>
<p>Si tenemos dos arreglos que ya están ordenados, podemos mezclarlos para formar un solo arreglo ordenado en tiempo proporcional a la suma de los tamaños de los dos arreglos.</p>
<p>Esto se hace leyendo el primer elemento de cada arreglo, copiando hacia un arreglod de salida al menor de los dos, y avanzando al siguiente elemento en el arreglo respectivo. Cuando uno de los dos arreglos se termina, todos los elementos restantes del otro se copian hacia la salida. Este proceso se denomina “mezcla,” o bien “merge,” por su nombre en inglés.</p>
<p>Como cada elemento se copia sólo una vez, y con cada comparación se copia algún elemento, es evidente que el costo de mezclar los dos archivos es lineal.</p>
<p>Si bien es posible realizar el proceso de mezcla de dos arreglos contiguos <em>in situ</em>, el algoritmo es muy complicado y no resulta práctico. Por esta razón, el proceso se implementa generalmente copiando desde dos arreglos de entrada a uno de salida.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge(a,b):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span><span class="dv">0</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i<span class="op">&lt;</span><span class="bu">len</span>(a) <span class="kw">or</span> j<span class="op">&lt;</span><span class="bu">len</span>(b):</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j<span class="op">&gt;=</span><span class="bu">len</span>(b) <span class="kw">or</span> (i<span class="op">&lt;</span><span class="bu">len</span>(a) <span class="kw">and</span> a[i]<span class="op">&lt;=</span>b[j]):</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> a[i]</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>            i<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> b[j]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>j<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> [<span class="dv">24</span>,<span class="dv">43</span>,<span class="dv">55</span>,<span class="dv">57</span>,<span class="dv">88</span>,<span class="dv">91</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> [<span class="dv">10</span>,<span class="dv">17</span>,<span class="dv">40</span>,<span class="dv">61</span>,<span class="dv">70</span>,<span class="dv">76</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span>[x <span class="cf">for</span> x <span class="kw">in</span> merge(a,b)]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c)</span></code></pre></div>
<pre><code>[24, 43, 55, 57, 88, 91]
[10, 17, 40, 61, 70, 76]
[10, 17, 24, 40, 43, 55, 57, 61, 70, 76, 88, 91]</code></pre>
<p>Usando esta idea en forma reiterada, es posible ordenar un conjunto. Una forma de ver esto es recursivamente, de manera “<em>top-down</em>,” usando “dividir para reinar.”</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mergesort(a):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">&gt;</span><span class="dv">1</span>:    </span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        mergesort(a[<span class="dv">0</span>:n<span class="op">//</span><span class="dv">2</span>])</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        mergesort(a[n<span class="op">//</span><span class="dv">2</span>:n])</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        a[<span class="dv">0</span>:n]<span class="op">=</span>[x <span class="cf">for</span> x <span class="kw">in</span> merge(a[<span class="dv">0</span>:n<span class="op">//</span><span class="dv">2</span>],a[n<span class="op">//</span><span class="dv">2</span>:n])]</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.random.random(<span class="dv">6</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>mergesort(a)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>[0.98208828 0.87903465 0.49512148 0.9665445  0.75927717 0.20751891]
[0.20751891 0.49512148 0.75927717 0.87903465 0.9665445  0.98208828]</code></pre>
<p>El tiempo total está dado aproximadamente por la ecuación de recurrencia</p>
<p><span class="math display">
T(n) = 2 T\left(\frac{n}{2}\right) + n
</span></p>
<p>la cual tiene solución&nbsp;<span class="math inline">\Theta(n \log{n})</span>, de modo que el algoritmo resulta ser óptimo.</p>
<p>Esto mismo se puede implementar en forma no recursiva, “<em>bottom-up</em>,” agrupando los elementos de a dos y mezclándolos para formar pares ordenados. Luego mezclamos pares para formar cuádruplas ordenadas, y así sucesivamente hasta mezclar las últimas dos mitades y formar el conjunto completo ordenado. Como cada “ronda” tiene costo lineal y se realizan&nbsp;<span class="math inline">\log{n}</span> rondas, el costo total es&nbsp;<span class="math inline">\Theta(n \log{n})</span>.</p>
<section id="runs" class="level3">
<h3>“<em>Runs</em>”</h3>
<p>En el enfoque “<em>bottom-up</em>” no recursivo, en lugar de comenzar mezclando elementos individuales para formar pares, etc., podemos comenzar detectando “<em>runs</em>” (corridas), que son secuencias de elementos consecutivos lo más largas posibles que ya vengan ordenados. A partir de ahí, mezclamos “<em>runs</em>” consecutivas y lo seguimos haciendo hasta que quede solo una gran “<em>run</em>,” que es el arreglo completo ordenado.</p>
</section>
<section id="mergesort-para-ordenamiento-externo" class="level3">
<h3>Mergesort para ordenamiento externo</h3>
<p>La idea de Mergesort es la base de la mayoría de los métodos de ordenamiento externo, esto es, métodos que ordenan conjuntos almacenados en archivos muy grandes, en donde no es posible copiar todo el contenido del archivo a memoria para aplicar alguno de los métodos estudiados anteriormente.</p>
<p>En las implementaciones prácticas de estos métodos, se utiliza el enfoque no recursivo, optimizado usando las siguientes ideas:</p>
<ul>
<li>No se comienza con elementos individuales para formar pares ordenados, sino que se generan archivos ordenados lo más grandes posibles. Para esto, el archivo de entrada se va leyendo por trozos a memoria y se ordena mediante Quicksort, por ejemplo.</li>
<li>En lugar de mezclar sólo dos archivos se hace una mezcla múltiple (con <span class="math inline">k</span> archivos de entrada. Como en cada iteración hay <span class="math inline">k</span> candidatos a ser el siguiente elemento en salir, y siempre hay que extrar al mínimo de ellos y sustituirlo en la lista de candidatos por su sucesor, la estructura de datos apropiada para ello es un heap. En caso que no baste con una pasada de mezcla múltiple para ordenar todo el archivo, el proceso se repite las veces que sea necesario.</li>
</ul>
<p>Al igual que en los casos anteriores, el costo total es&nbsp;<span class="math inline">\Theta(n \log{n})</span>.</p>
</section>
</section>
</section>

<div id="lastupdate">
Last updated: jue mar  4 15:11:55 -05 2021
</div>
</article>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</body>
</html>
