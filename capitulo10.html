<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>shared-macros</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>



<div id="collapsiblemenu">
  <button class="collapsible">
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
  </button>
  <div class="content">
    <ul>
    <li><a href="index.html">Home</a></li>
    </ul>
    <ul>
    <li><a href="#grafos">10 Grafos</a>
    <ul>
    <li><a href="#definiciones-básicas">Definiciones básicas</a></li>
    <li><a href="#representaciones-de-grafos-en-memoria">Representaciones de grafos en memoria</a></li>
    <li><a href="#caminos-ciclos-y-árboles">Caminos, ciclos y árboles</a></li>
    <li><a href="#recorridos-de-grafos">Recorridos de grafos</a></li>
    <li><a href="#árbol-cobertor-mínimo-minimum-spanning-tree">Árbol Cobertor Mínimo (<em>Minimum Spanning Tree</em>)</a></li>
    <li><a href="#distancias-mínimas-en-un-grafo-dirigido">Distancias mínimas en un grafo dirigido</a></li>
    <li><a href="#algoritmo-de-warshall-para-cerradura-transitiva-y-reflexiva-de-un-grafo-dirigido">Algoritmo de Warshall para cerradura transitiva y reflexiva de un grafo dirigido</a></li>
    </ul></li>
    </ul>
  </div>
</div>


<section id="grafos" class="level1">
<h1>10 Grafos</h1>
<p>Un <em>grafo</em> es una estructura matemática que se utiliza para representar relaciones como las que hay entre las ciudades conectadas por caminos, los cursos con sus requisitos, las componentes conectadas en un circuito eléctrico, las páginas web vinculadas por enlaces, etc.</p>
<section id="definiciones-básicas" class="level2">
<h2>Definiciones básicas</h2>
<p>Un grafo consiste de un conjunto&nbsp;<span class="math inline">V</span> de <em>vértices</em> (también llamados <em>nodos</em>) y un conjunto&nbsp;<span class="math inline">E</span> de <em>arcos</em>. El número de vértices se suele denotar&nbsp;<span class="math inline">n</span> y el número de arcos como&nbsp;<span class="math inline">m</span> (o a veces&nbsp;<span class="math inline">e</span>).</p>
<p>Se dice que un grafo es <em>no dirigido</em> si sus arcos no tiene una dirección asociada. Por ejemplo,</p>
<figure>
<img src="recursos/grafo-no-dirigido.png" alt="grafo-no-dirigido" /><figcaption aria-hidden="true">grafo-no-dirigido</figcaption>
</figure>
<p><span class="math display">
\begin{align}
V &amp;=\{v_1,v_2,v_3,v_4,v_5\}\\
E &amp;=\{ \{v_1,v_2\},\{v_1,v_3\},\{v_1,v_5\},\{v_2,v_3\},\{v_3,v_4\},\{v_4,v_5\} \}
\end{align}
</span></p>
<p>Un grafo es <em>dirigido</em> si sus arcos tienen una orientación. Por ejemplo:</p>
<figure>
<img src="recursos/grafo-dirigido.png" alt="grafo-dirigido" /><figcaption aria-hidden="true">grafo-dirigido</figcaption>
</figure>
<p><span class="math display">
\begin{align}
V &amp;=\{v_1,v_2,v_3,v_4\}\\
E &amp;=\{ (v_1,v_2), (v_2,v_2), (v_2,v_3), (v_3,v_1), (v_3,v_4), (v_4,v_3) \}
\end{align}
</span></p>
<p>Adicionalmente, los grafos pueden tener rótulos asociados a sus vértices o arcos. Estos rótulos pueden representar costos, longitudes, pesos, etc.</p>
</section>
<section id="representaciones-de-grafos-en-memoria" class="level2">
<h2>Representaciones de grafos en memoria</h2>
<p>Un grafo se puede almacenar en memoria de distintas maneras, las cuales tienen distintos requerimientos de espacio, y ponen también distintas restricciones al tiempo de proceso.</p>
<section id="matriz-de-adyacencia" class="level3">
<h3>Matriz de adyacencia</h3>
<p>Un grafo se puede representar a través de una matriz&nbsp;<span class="math inline">A</span> donde&nbsp;<span class="math inline">A[i,j]=1</span> si hay un arco que conecta&nbsp;<span class="math inline">v_i</span> con&nbsp;<span class="math inline">v_j</span>, y&nbsp;<span class="math inline">0</span> si no. La matriz de adyacencia de un grafo no dirigido es simétrica.</p>
<p>Una matriz de adyacencia permite determinar si dos vértices están conectados o no en tiempo constante, pero requieren&nbsp;<span class="math inline">\Theta(n^2)</span> bits de memoria. Esto puede ser demasiado para muchos grafos que aparecen en aplicaciones reales, en donde&nbsp;<span class="math inline">m&lt;&lt;n^2</span>. Otro problema es que se requiere tiempo&nbsp;<span class="math inline">\Theta(n)</span> para encontrar la lista de vecinos de un vértice dado.</p>
</section>
<section id="listas-de-adyacencia" class="level3">
<h3>Listas de adyacencia</h3>
<p>Esta representación consiste en almacenar, para cada nodo, la lista de los nodos adyacentes a él (sus “vecinos”). Para el segundo ejemplo anterior, tenemos:</p>
<p><span class="math display">
\begin{align}
\text{vecinos}[v_1] &amp;= [v_2]\\
\text{vecinos}[v_2] &amp;= [v_2, v_3]\\
\text{vecinos}[v_3] &amp;= [v_1, v_4]\\
\text{vecinos}[v_4] &amp;= [v_3]
\end{align}
</span></p>
<p>Esto utiliza espacio&nbsp;<span class="math inline">\Theta(m)</span> y permite acceso eficiente a los vecinos, pero no permite acceso directo a los arcos.</p>
</section>
</section>
<section id="caminos-ciclos-y-árboles" class="level2">
<h2>Caminos, ciclos y árboles</h2>
<p>Consideremos un grafo no dirigido.</p>
<p>Un <em>camino</em> es una secuencia de arcos en que el extremo final de cada arco coincide con el extremo inicial del siguiente en la secuencia. Por ejemplo, los arcos gruesos forman un camino desde&nbsp;<span class="math inline">v_2</span> a&nbsp;<span class="math inline">v_5</span> (o viceversa):</p>
<figure>
<img src="recursos/camino.png" alt="camino" /><figcaption aria-hidden="true">camino</figcaption>
</figure>
<p>Un camino es <em>simple</em> si no se repiten vértices, excepto posiblemente el primero y el último.</p>
<p>Un <em>ciclo</em> es un camino simple y cerrado (esto es, en que el vértice inicial y final son el mismo). En el siguiente ejemplo los arcos gruesos forman un ciclo:</p>
<figure>
<img src="recursos/ciclo.png" alt="ciclo" /><figcaption aria-hidden="true">ciclo</figcaption>
</figure>
<p>Un grafo que no tiene ciclos se dice que es <em>acíclico</em>.</p>
<p>Se dice que un grafo es <em>conexo</em> si para todo par de vértices del grafo existe un camino que los une. Si un grafo no es conexo, entonces estará compuesto por varias “islas,” cada una de las cuales se llama una <em>componente conexa</em>. Más precisamentem una componente conexa es un subgrafo conexo <em>maximal</em> (esto es, que no está estrictamente contenido dentro de un subgrafo conexo mayor).</p>
<p>Un <em>árbol</em> es un grafo que es <em>conexo</em> y <em>acíclico</em>. En el siguiente ejemplo, los arcos gruesos forman un árbol:</p>
<figure>
<img src="recursos/arbol.png" alt="arbol" /><figcaption aria-hidden="true">arbol</figcaption>
</figure>
<p>Si un árbol incluye todos los nodos de un grafo, se dice que es un <em>árbol cobertor</em> (<em>spanning tree</em>).</p>
<section id="propiedades-de-los-árboles" class="level3">
<h3>Propiedades de los árboles</h3>
<p>Es fácil demostrar las siguientes propiedades:</p>
<ul>
<li>Todo árbol con <span class="math inline">n</span> nodos tiene <span class="math inline">n-1</span> arcos.</li>
<li>Si se agrega un arco a un árbol, se crea un único ciclo.</li>
</ul>
</section>
</section>
<section id="recorridos-de-grafos" class="level2">
<h2>Recorridos de grafos</h2>
<p>En muchas aplicaciones es necesario visitar todos los vértices del grafo a partir de un nodo dado. Algunas aplicaciones son:</p>
<ul>
<li>Encontrar ciclos</li>
<li>Encontrar componentes conexas</li>
<li>Encontrar árboles cobertores</li>
</ul>
<p>Hay dos enfoque básicos:</p>
<p><em>Recorrido (o búsqueda) en profundidad (depth-first search)</em>:</p>
<p>La idea es alejarse lo más posible del nodo inicial (sin repetir nodos), luego devolverse un paso e intentar lo mismo por otro camino.</p>
<p><em>Recorrido (o búsqueda) en amplitud (breadth-first search)</em>:</p>
<p>Se visita a todos los vecinos directos del nodo inicial, luego a los vecinos de los vecinos, etc.</p>
<section id="recorrido-en-profundidad-dfs" class="level3">
<h3>Recorrido en profundidad (DFS)</h3>
<p>A medida que recorremos el grafo, iremos numerando correlativamente los nodos encontrados&nbsp;<span class="math inline">1,2,\ldots</span>. Suponemos que todos estos números son cero inicialmente, y para ir asignando esta numeración utilizamos un contador global&nbsp;<span class="math inline">n</span>, también inicializado en cero. A esta numeración asignada la llamamos el Depth-First-Number (DFN).</p>
<p>El siguiente algoritmo en seudo-código muestra cómo se puede hacer este tipo de recorrido recursivamente:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> DFS(v): <span class="co"># Recorre en profundidad a partir del vértice v    </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> n</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> DFN</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> DFN[v]<span class="op">==</span><span class="dv">0</span> <span class="co"># Supone que es primera vez que se visita el vértice v</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>n<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    DFN[v]<span class="op">=</span>n <span class="co"># Numeramos el vértice v</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> vecinos[v]:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> DFN[w]<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            DFS(w)  <span class="co"># Visitamos w si no había sido visitado aún</span></span></code></pre></div>
<p>Para dar el “puntapié inicial” al proceso, hay que hacer que todos los DFN estén en cero, inicializar en cero la variable global&nbsp;<span class="math inline">n</span> e indicar el nodo de partida&nbsp;<span class="math inline">x</span>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> startDFS(x):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> n</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> DFN</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> V:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        DFN[v]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    DFS(x)</span></code></pre></div>
<p>En el siguiente ejemplo mostraremos un posible resultado de aplicar este recorrido a un grafo dado. A la derecha se muestra el mismo grafo, con sus vértices numerados con DFN y marcando más grueso al arco que permitió llegar a por primera vez a cada vértice. A estos arcos los llamamos <em>arcos de árbol</em>. A los arcos que permiten llegar a un vértice que ya había sido visitado los llamamos <em>arcos de retorno</em> y los mostramos con línea segmentada.</p>
<figure>
<img src="recursos/DFS.png" alt="DFS" /><figcaption aria-hidden="true">DFS</figcaption>
</figure>
<p>Si hubiera más de una componente conexa, este recorrido no llegaría a todos los nodos. Para recorrer el grafo por completo, podemos ejecutar un DFS sobre cada componente conexa.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> startDFS(): <span class="co"># recorre el grafo, retorna número de componentes conexas</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> n</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> ncc</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> DFN</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="dv">0</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> V:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        DFN[v]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ncc<span class="op">=</span><span class="dv">0</span> <span class="co"># cuenta el número de componentes conexas</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> V:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> DFN[x]<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            ncc<span class="op">=</span>ncc<span class="op">+</span><span class="dv">1</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            DFS(x)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ncc</span></code></pre></div>
<p>Existe una gran similitud entre el DFS y el recorrido en preorden que vimos para árboles binarios. Tal como ocurrió en esa oportunidad, también es posible programar el recorrido de manera no recursiva utilzando una pila:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> DFSnorecursivo(x): <span class="co"># Recorre en profundidad a partir del vértice x  </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> V:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        DFN[v]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span>Pila()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    s.push(x) <span class="co"># el vértice inicial del recorrido</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">not</span> s.is_empty():</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        v<span class="op">=</span>s.pop()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> DFN[v]<span class="op">==</span><span class="dv">0</span>: <span class="co"># primera vez que se visita este nodo</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            n<span class="op">=</span>n<span class="op">+</span><span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            DFN[v]<span class="op">=</span>n      </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> w <span class="kw">in</span> vecinos[v]:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                s.push(w)</span></code></pre></div>
</section>
<section id="recorrido-en-amplitud" class="level3">
<h3>Recorrido en amplitud</h3>
<p>Este recorrido es análogo al recorrido por niveles que vimos para árboles binarios. Su programación es similar a <code>DFSnorecursivo</code>, sustituyendo la pila por una cola.</p>
</section>
</section>
<section id="árbol-cobertor-mínimo-minimum-spanning-tree" class="level2">
<h2>Árbol Cobertor Mínimo (<em>Minimum Spanning Tree</em>)</h2>
<p>Para un grafo dado pueden existir muchos árboles cobertores. Si introducimos un concepto de “peso” (o “costo”) sobre los arcos, es interesante tratar de encontrar un árbol cobertor que tenga costo mínimo. El costo de un árbol es la suma de los costos de sus arcos.</p>
<p>En esta sección veremos dos algoritmos para encontrar un árbol cobertor mínimo para un grafo no dirigido dado, conexo y con costos asociados a los arcos.</p>
<section id="algoritmo-de-kruskal" class="level3">
<h3>Algoritmo de Kruskal</h3>
<p>Este es un algoritmo del tipo “avaro” (“greedy”). Comienza inicialmente con un grafo que contiene sólo los nodos del grafo original, sin arcos. Luego, en cada iteración, se agrega al grafo el arco más barato que no genere un ciclo. El proceso termina cuando el grafo está completamente conectado.</p>
<p>En general, la estrategia “avara” no garantiza que se encuentre un óptimo global, porque es un método “miope,” que sólo optimiza las decisiones de corto plazo. Por otra parte, a menudo este tipo de métodos proveen buenas heurísticas, que se acercan al óptimo global. Pero en este caso, afortunadamente, se puede demostrar que el método “avaro” logra siempre encontrar el óptimo global, por lo cual un árbol cobertor encontrado por esta vía está garantizado que es un árbol cobertor mínimo.</p>
<p>Una forma de ver este algoritmo es diciendo que al principio cada nodo constituye su propia componente conexa, aislado de todos los demás nodos. Durante el proceso de construcción del árbol, se agrega un arco sólo si sus dos extremos se encuentran en componentes conexas distintas, y luego de agregarlo, esas dos componentes conexas se fusionan en una sola.</p>
<p>La siguiente animación muestra el algoritmo de Kruskal en funcionamiento. A cada paso, se intenta agregar un arco. Si se descarta, porque formaría un ciclo, se marca con una “X” y se pasa al siguiente. Si se acepta, porque une dos componentes conexas distintas, se marca como un arco sólido.</p>
<figure>
<img src="recursos/kruskal.gif" alt="kruskal" /><figcaption aria-hidden="true">kruskal</figcaption>
</figure>
<p>Para la operatoria con componentes conexas supondremos que cada componente conexa se identifica mediante un representante canónico (el “lider” del conjunto), y que se dispone de las siguientes operaciones:</p>
<p><code>Union(a,b)</code>: Se fusionan las componentes canónicas representadas por a y b, respectivamente.</p>
<p><code>Find(x)</code>: Encuentra al representante canónico de la componente conexa a la cual pertenece x.</p>
<p>Con estas operaciones, el algoritmo de Kruskal se puede escribir así (en seudo-código):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kruskal(V,E):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    sort(E) <span class="co"># Ordenar los arcos en orden creciente de costo</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> [[v] <span class="cf">for</span> v <span class="kw">in</span> V] <span class="co"># C es el conjunto de componentes conexas, inicialmente &quot;singletons&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> [] <span class="co"># La lista de los arcos del árbol</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> e <span class="kw">in</span> E: <span class="co"># consideramos los arcos en orden creciente</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(C)<span class="op">==</span><span class="dv">1</span>: <span class="co"># queda solo 1 componente conexa</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        (v,w)<span class="op">=</span>vertices(e)      <span class="co"># los dos extremos del arco e</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Find(v) <span class="op">!=</span> Find(w): <span class="co"># están en componentes conexas distintas</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            T.append(e) <span class="co"># Agregar el arco e al árbol</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            Union(Find(v),Find(w)) <span class="co"># Fusionamos las dos componentes en una sola</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T</span></code></pre></div>
<p>El tiempo que demora este algoritmo está dominado por lo que demora la ordenación del conjunto&nbsp;<span class="math inline">E</span> de arcos,&nbsp;<span class="math inline">\Theta(m \log{m})</span>, más lo que demora realizar&nbsp;<span class="math inline">m</span> operaciones <code>Find</code>, más&nbsp;<span class="math inline">n</span> operaciones <code>Union</code>.</p>
<p>Es posible implementar <code>Union-Find</code> de modo que las operaciones <code>Union</code> demoren tiempo constante, y las operaciones <code>Find</code> un tiempo casi constante. Más precisamente, el costo amortizado de un Find está acotado por&nbsp;<span class="math inline">\log^*{n}</span>, donde&nbsp;<span class="math inline">\log^*{n}</span> es una función definida como el número de veces que es necesario tomar el logaritmo de un número para que el resultado sea menor que 1.</p>
<p>Por lo tanto, el costo total es&nbsp;<span class="math inline">\Theta(m \log{m})</span>, lo cual es igual a&nbsp;<span class="math inline">\Theta(m \log{n})</span>, porque en todo grafo se tiene que&nbsp;<span class="math inline">m=O(n^2)</span>.</p>
<p>La correctitud del algoritmo de Kruskal viene del siguiente lema:</p>
<section id="lema" class="level4">
<h4>Lema</h4>
<p>Sea&nbsp;<span class="math inline">V&#39;</span> subconjunto propio de&nbsp;<span class="math inline">V</span>, y sea&nbsp;<span class="math inline">e=\{v,w\}</span> un arco de costo mínimo tal que&nbsp;<span class="math inline">v \in V&#39;</span> y&nbsp;<span class="math inline">w \in V-V&#39;</span>. Entonces existe un árbol cobertor mínimo que incluye a&nbsp;<span class="math inline">e</span>.</p>
<p>Este lema permite muchas estrategias distintas para escoger los arcos del árbol. Un ejemplo es el siguiente algoritmo.</p>
</section>
</section>
<section id="algoritmo-de-prim" class="level3">
<h3>Algoritmo de Prim</h3>
<p>Comenzamos con el arco más barato, y marcamos sus dos extremos como “alcanzables.” Luego, a cada paso, intentamos extender nuestro conjunto de nodos alcanzables agregando siempre el arco más barato que tenga uno de sus extremos dentro del conjunto alcanzable y el otro fuera de él. De esta manera, el conjunto alcanzable se va extendiendo como una “mancha de aceite.”</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prim(V,E):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    e<span class="op">=</span>arco_de_costo_minimo(E)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    (v,w)<span class="op">=</span>vertices(e)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    T<span class="op">=</span>[e]   <span class="co"># árbol</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">=</span>[v,w] <span class="co"># conjunto alcanzable</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> A<span class="op">!=</span>V:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        e<span class="op">=</span>arco_de_costo_minimo_que_conecta(A,V<span class="op">-</span>A)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        (v,w)<span class="op">=</span>vertices(e) <span class="co"># suponemos v en A y w en V-A</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        T.append(e)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        A.append(w)</span></code></pre></div>
<p>La siguiente animación muestra el algoritmo de Prim en funcionamiento. A cada paso, los arcos candidatos a agregarse se muestran con líneas punteadas. El arco que se acepta, por ser el de menor costo que une al conjunto alcanzable con el resto del grafo se marca como un arco sólido.</p>
<figure>
<img src="recursos/prim.gif" alt="prim" /><figcaption aria-hidden="true">prim</figcaption>
</figure>
<p>Para implementar este algoritmo eficientemente, podemos mantener una tabla donde, para cada nodo de&nbsp;<span class="math inline">V-A</span>, almacenamos el costo del arco más barato que lo conecta al conjunto A. Estos costos pueden cambiar en cada iteración, así que hay que recalcularlos para todos los vecinos del nodo que se agrega al conjunto alcanzable.</p>
<p>Si se organiza la tabla como una cola de prioridad, el tiempo total es&nbsp;<span class="math inline">\Theta(m \log{n})</span>. Si se deja la tabla desordenada y se busca linealmente en cada iteración, el costo es&nbsp;<span class="math inline">\Theta(n^2)</span>. Esto último es mejor que lo anterior cuando el grafo es denso.</p>
</section>
</section>
<section id="distancias-mínimas-en-un-grafo-dirigido" class="level2">
<h2>Distancias mínimas en un grafo dirigido</h2>
<p>Consideremos un grafo <em>dirigido</em> <span class="math inline">G=(V,E)</span>, donde para cada arco&nbsp;<span class="math inline">e=(u,v)</span> se conoce su largo, o distancia,&nbsp;<span class="math inline">d(e)=d(u,v)\ge 0</span>. Podemos extender la función&nbsp;<span class="math inline">d</span> a todo&nbsp;<span class="math inline">V\times V</span> si definimos&nbsp;<span class="math inline">d(u,v)=\infty</span> cuando&nbsp;<span class="math inline">(u,v)\notin E</span>.</p>
<p>Si se define el largo de un camino como la suma de los largos de los arcos que lo componen, es interesante encontrar los caminos más cortos que unen a nodos del grafo.</p>
<p>Este problema se suele estudiar en dos variantes:</p>
<ul>
<li><p>Encontrar todos los caminos más cortos desde un nodo “origen” <span class="math inline">s</span> hasta todos los demás nodos del grafo.</p></li>
<li><p>Encontrar todos los caminos más cortos entre todos los pares de nodos del grafo. Esto se puede resolver iterando&nbsp;<span class="math inline">n</span> veces el problema anterior, cambiando cada vez el nodo origen, pero es posible encontrar un algoritmo más simple si se resuelve todo de una vez.</p></li>
</ul>
<section id="algoritmo-de-dijkstra-para-los-caminos-más-cortos-desde-un-nodo-origen" class="level3">
<h3>Algoritmo de Dijkstra para los caminos más cortos desde un nodo origen</h3>
<p>La idea del algoritmo es mantener un conjunto&nbsp;<span class="math inline">A</span> de nodos “alcanzables” desde el nodo origen e ir extendiendo este conjunto en cada iteración.</p>
<p>Los nodos alcanzables son aquellos para los cuales ya se ha encontrado su camino óptimo desde el nodo origen. Para esos nodos su distancia óptima al origen es conocida. Inicialmente&nbsp;<span class="math inline">A=\{s\}</span>.</p>
<p>Para los nodos que todavía no están en&nbsp;<span class="math inline">A</span> aún no se conoce su camino óptimo desde&nbsp;<span class="math inline">s</span>, pero sí se puede conocer el camino óptimo <em>que pasa sólo por nodos de</em> <span class="math inline">A</span>. Esto es, caminos en que todos los nodos intermedios son nodos de&nbsp;<span class="math inline">A</span>. Llamemos a esto su camino óptimo <em>tentativo</em>.</p>
<p>En cada iteración, el algoritmo encuentra el nodo que no está en&nbsp;<span class="math inline">A</span> cuyo camino óptimo tentativo tiene largo mínimo. Es fácil demostrar por contradicción que ese camino tiene que ser el camino óptimo para ese nodo. Luego, ese nodo se agrega a&nbsp;<span class="math inline">A</span> y su camino óptimo tentativo se convierte en su camino óptimo. Luego se actualizan los caminos óptimos tentativos para los demás nodos.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Dijkstra(V,E,d,s):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">=</span>[s]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> V:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        D[v]<span class="op">=</span>d[v]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    D[s]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># D[] almacena las distancias óptimas desde s para los nodos en A</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># y las distancias óptimas tentativas para los nodos en V-A</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> A<span class="op">!=</span>V:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Encontramos el nodo v de menor distancia óptima tentativa</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> findmin(D[u] <span class="cf">for</span> u <span class="kw">in</span> V<span class="op">-</span>A)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Agregamos v al conjunto alcanzable</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        A.append(v)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># recalculamos las distancias óptimas tentativas</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># considerando la posibilidad de pasar por el nuevo nodo v</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> vecinos[v]: <span class="co"># los nodos w tal que (v,w) in E</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            D[w] <span class="op">=</span> <span class="bu">min</span>(D[w],D[v]<span class="op">+</span>d(v,w))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Al terminar, D[] almacena las distancias óptimas definitivas</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span></code></pre></div>
<p>Si&nbsp;<span class="math inline">D</span> se implementa como un arreglo en donde el mínimo se busca secuencialmente, encontrar el mínimo toma tiempo&nbsp;<span class="math inline">\Theta(n)</span>, con un aporte de&nbsp;<span class="math inline">\Theta(n^2)</span> al tiempo total. Por otra parte, recalcular las distancias óptimas tentativas toma en total tiempo&nbsp;<span class="math inline">\Theta(m)</span>, porque cada arco se usa a lo más una vez. Como&nbsp;<span class="math inline">m=O(n^2)</span>, el tiempo total es&nbsp;<span class="math inline">\Theta(n^2)</span>.</p>
<p>Una forma alternativa de implementar este algoritmo es usando una <em>cola de prioridad</em>, por ejemplo un heap, para almacenar los valores de&nbsp;<span class="math inline">D</span> de los nodos en&nbsp;<span class="math inline">V-A</span>. Así, encontrar y extraer el mínimo toma tiempo&nbsp;<span class="math inline">\Theta(\log{n})</span>, lo cual se ejecuta&nbsp;<span class="math inline">n</span> veces, y cada recálculo toma también tiempo&nbsp;<span class="math inline">\Theta(\log{n})</span>, porque hay que cambiar la prioridad del respectivo elemento en el heap, y esto se ejecuta&nbsp;<span class="math inline">m</span> veces. Por lo tanto, en esta implementación el tiempo total es&nbsp;<span class="math inline">\Theta(m\log{n})</span>.</p>
</section>
<section id="algoritmo-de-floyd-para-todas-las-distancias-más-cortas" class="level3">
<h3>Algoritmo de Floyd para todas las distancias más cortas</h3>
<p>Para aplicar este algoritmo, los nodos se numeran arbitrariamente&nbsp;<span class="math inline">1,2,\ldots,n</span>. El algoritmo va a construir una matriz&nbsp;<span class="math inline">D</span> tal que, al final,&nbsp;<span class="math inline">D[i,j]</span> va a ser el largo del camino más corto que va desde el nodo&nbsp;<span class="math inline">i</span> hasta el nodo&nbsp;<span class="math inline">j</span>.</p>
<p>El invariante del algoritmo es que al comenzar la iteración&nbsp;<span class="math inline">k</span>-ésima,&nbsp;<span class="math inline">D[i,j]</span> es la distancia mínima entre&nbsp;<span class="math inline">i</span> y&nbsp;<span class="math inline">j</span> medida a través de caminos <em>que pasen sólo por nodos intermedios de numeración</em> <span class="math inline">&lt;k</span>.</p>
<p>En la iteración&nbsp;<span class="math inline">k</span>-ésima se comparan estas distancias óptimas con las que se obtendrían si se pasara una vez por el nodo&nbsp;<span class="math inline">k</span>. Si de esta manera se obtendría un camino más corto, entonces se prefiere este nuevo camino, de lo contrario nos quedamos con el camino antiguo.</p>
<figure>
<img src="recursos/floyd.gif" alt="floyd" /><figcaption aria-hidden="true">floyd</figcaption>
</figure>
<p>Al terminar esta iteración, las distancias calculadas ahora incluyen la posibilidad de pasar por nodos intermedios de numeración&nbsp;<span class="math inline">\le k</span>, con lo cual estamos listos para ir a la iteración siguiente.</p>
<p>Inicialmente, hacemos&nbsp;<span class="math inline">D[i,j]=d(i,j)</span> para todo&nbsp;<span class="math inline">i,j</span> (recordemos la convención de que&nbsp;<span class="math inline">d(i,j)=\infty</span> si&nbsp;<span class="math inline">(i,j)\notin E</span>), excepto que la diagonal es&nbsp;<span class="math inline">D[i,i]=0</span>, porque la distancia óptima de todo nodo a sí mismo es&nbsp;<span class="math inline">0</span>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Floyd(V,E,d):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            D[i,j]<span class="op">=</span>d(i,j)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        D[i,i]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                D[i,j]<span class="op">=</span><span class="bu">min</span>(D[i,j],D[i,k]<span class="op">+</span>D[k,j])</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span></code></pre></div>
<p>El tiempo total que demora este algoritmo claramente es&nbsp;<span class="math inline">\Theta(n^3)</span>.</p>
</section>
</section>
<section id="algoritmo-de-warshall-para-cerradura-transitiva-y-reflexiva-de-un-grafo-dirigido" class="level2">
<h2>Algoritmo de Warshall para cerradura transitiva y reflexiva de un grafo dirigido</h2>
<p>Dado un grafo dirigido&nbsp;<span class="math inline">G=(V,E)</span>, su <em>cerradura transitiva y reflexiva</em> es un grafo&nbsp;<span class="math inline">G^*=(V,E^*)</span>, donde hay un arco&nbsp;<span class="math inline">(u,v)\in E^*</span> ssi existe un camino desde&nbsp;<span class="math inline">u</span> hasta&nbsp;<span class="math inline">v</span> en&nbsp;<span class="math inline">G</span>. Si se consideran solo caminos de largo&nbsp;<span class="math inline">\ge 1</span>, el grafo se llama la cerradura transitiva de&nbsp;<span class="math inline">G</span> y se denota por&nbsp;<span class="math inline">G^+</span>. La diferencia entre&nbsp;<span class="math inline">G^+</span> y&nbsp;<span class="math inline">G^*</span> es que para construir&nbsp;<span class="math inline">G^+</span> se agregan todos los arcos de transitividad, y para&nbsp;<span class="math inline">G^*</span> se agregan además todos los auto-ciclos.</p>
<p>El siguiente ejemplo muestra un grafo dirigido&nbsp;<span class="math inline">G</span> y su correspondiente cerradura transitiva y reflexiva&nbsp;<span class="math inline">G^*</span>, mostrando en línea punteada los arcos que se agregan.</p>
<figure>
<img src="recursos/warshall.png" alt="warshall" /><figcaption aria-hidden="true">warshall</figcaption>
</figure>
<p>Supongamos que el grafo&nbsp;<span class="math inline">G</span> se representa a través de su matriz de adyacencia&nbsp;<span class="math inline">A</span>, con&nbsp;<span class="math inline">A[i,j]=1</span> si hay un arco entre&nbsp;<span class="math inline">v_i</span> y&nbsp;<span class="math inline">v_j</span>, y&nbsp;<span class="math inline">0</span> si no. Queremos calcular la matriz&nbsp;<span class="math inline">A^*</span> correspondiente al grafo&nbsp;<span class="math inline">G^*</span>. Para el grafo del ejemplo, tendríamos</p>
<p><span class="math display">
A=
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
~~~~~~
A^*=
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
</span></p>
<p>Podemos resolver este problema haciendo uso del algoritmo de Floyd, de la siguiente manera: formamos una matriz de distancias&nbsp;<span class="math inline">D</span>, con</p>
<p><span class="math display">
D[i,j] =
\begin{cases}
+\infty &amp; \text{if }A[i,j]=0 \\
0 &amp; \text{if }A[i,j]=1
\end{cases}
</span></p>
<p>Luego de aplicar el algoritmo de Floyd, tendremos que la distancia entre dos nodos es&nbsp;<span class="math inline">0</span> ssi existe un camino entre los dos nodos, así que podemos recuperar la matriz&nbsp;<span class="math inline">A^*</span> haciendo la sustitución inversa.</p>
<p>Yendo más allá, podemos re-examinar el funcionamiento del algoritmo de Floyd sobre esos infinitos y ceros, y ver cuál sería su interpretación si estuvieran operando sobre los ceros y unos originales, respectivamente.</p>
<p>El algoritmo de Floyd hace uso de dos operaciones,&nbsp;<span class="math inline">+</span>, y&nbsp;<span class="math inline">\min</span>. Las dos tablas siguientes muestran el efecto de esas operaciones:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">+</span></th>
<th><span class="math inline">\infty</span></th>
<th><span class="math inline">0</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\infty</span></td>
<td><span class="math inline">\infty</span></td>
<td><span class="math inline">\infty</span></td>
</tr>
<tr class="even">
<td><span class="math inline">0</span></td>
<td><span class="math inline">\infty</span></td>
<td><span class="math inline">0</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\min</span></th>
<th><span class="math inline">\infty</span></th>
<th><span class="math inline">0</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\infty</span></td>
<td><span class="math inline">\infty</span></td>
<td><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td><span class="math inline">0</span></td>
<td><span class="math inline">0</span></td>
<td><span class="math inline">0</span></td>
</tr>
</tbody>
</table>
<p>Si reemplazamos&nbsp;<span class="math inline">\infty</span> por&nbsp;<span class="math inline">0</span> y&nbsp;<span class="math inline">0</span> por&nbsp;<span class="math inline">1</span>, respectivamente, vemos que las tablas resultantes corresponden a las operaciones lógicas&nbsp;<span class="math inline">\wedge</span> y&nbsp;<span class="math inline">\vee</span>:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">0</span></th>
<th><span class="math inline">1</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">0</span></td>
<td><span class="math inline">0</span></td>
<td><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td><span class="math inline">1</span></td>
<td><span class="math inline">0</span></td>
<td><span class="math inline">1</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">0</span></th>
<th><span class="math inline">1</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">0</span></td>
<td><span class="math inline">0</span></td>
<td><span class="math inline">1</span></td>
</tr>
<tr class="even">
<td><span class="math inline">1</span></td>
<td><span class="math inline">1</span></td>
<td><span class="math inline">1</span></td>
</tr>
</tbody>
</table>
<p>Si reescribimos el algoritmo de Floyd en términos de ceros y unos, con estas operaciones lógicas, obtenermos el algoritmo de Warshall:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seudo-código</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Warshall(V,E,d):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            A[i,j]<span class="op">=</span><span class="dv">1</span> <span class="cf">if</span> (i,j) <span class="kw">in</span> E <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        A[i,i]<span class="op">=</span><span class="dv">1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                A[i,j]<span class="op">=</span>A[i,j] <span class="kw">or</span> (A[i,k] <span class="kw">and</span> A[k,j])</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A</span></code></pre></div>
<p>Tal como en el caso del algoritmo de Floyd, el algoritmo de Warshall obviamente demora tiempo&nbsp;<span class="math inline">\Theta(n^3)</span>.</p>
</section>
</section>

<div id="lastupdate">
Last updated: jue mar  4 15:12:15 -05 2021
</div>
</article>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</body>
</html>
