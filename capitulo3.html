<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>shared-macros</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>



<div id="collapsiblemenu">
  <button class="collapsible">
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
  </button>
  <div class="content">
    <ul>
    <li><a href="index.html">Home</a></li>
    </ul>
    <ul>
    <li><a href="#dise√±o-de-algoritmos-eficientes">3 Dise√±o de Algoritmos Eficientes</a>
    <ul>
    <li><a href="#dividir-para-reinar">Dividir para Reinar</a></li>
    <li><a href="#programaci√≥n-din√°mica">Programaci√≥n Din√°mica</a></li>
    <li><a href="#algoritmos-avaros-greedy-algorithms">Algoritmos Avaros (<em>Greedy Algorithms</em>)</a></li>
    <li><a href="#backtracking">Backtracking</a></li>
    </ul></li>
    </ul>
  </div>
</div>


<section id="dise√±o-de-algoritmos-eficientes" class="level1">
<h1>3 Dise√±o de Algoritmos Eficientes</h1>
<p>En este cap√≠tulo veremos un conjunto de ideas que permiten dise√±ar algoritmos que, en muchos casos, son de los m√°s eficientes que se conocen para sus respectivos problemas.</p>
<section id="dividir-para-reinar" class="level2">
<h2>Dividir para Reinar</h2>
<p>Este es un m√©todo de dise√±o de algoritmos que se basa en subdividir el problema en sub-problemas, resolverlos recursivamente, y luego combinar las soluciones de los sub-problemas para construir la soluci√≥n del problema original. Es necesario que los subproblemas tengan la misma estructura que el problema original, de modo que se pueda aplicar la recursividad.</p>
<section id="ejemplo-multiplicaci√≥n-de-polinomios" class="level3">
<h3>Ejemplo: Multiplicaci√≥n de Polinomios</h3>
<p>Supongamos que tenemos dos polinomios&nbsp;<span class="math inline">A(x)</span> y&nbsp;<span class="math inline">B(x)</span>, cada uno de grado&nbsp;<span class="math inline">n-1</span>:</p>
<p><span class="math display">
A(x) = a_0+a_1 x+a_2 x^2 + \ldots + a_{n-1}x^{n-1}
</span> <span class="math display">
B(x) = b_0+b_1 x+b_2 x^2 + \ldots + b_{n-1}x^{n-1}
</span></p>
<p>representados por sus respectivos arreglos de coeficientes&nbsp;<span class="math inline">a[0],\ldots,a[n-1]</span> y&nbsp;<span class="math inline">b[0],\ldots,b[n-1]</span>.</p>
<p>El problema consiste en calcular los coeficientes&nbsp;<span class="math inline">c[0],\ldots,c[2n-2]</span> del polinomio producto&nbsp;<span class="math inline">C(x)=A(x)B(x)</span>.</p>
<p>Por ejemplo,</p>
<p><span class="math display">
\begin{align}
A(x) &amp;= 2+3x-6x^2+x^3\\
B(x) &amp;= 1-x+3x^2+x^3\\
C(x) &amp;= A(x)B(x) = 2+x-3x^2+18x^3-16x^4-3x^5+x^6
\end{align}
</span></p>
<p>La manera obvia de resolver este problema es multiplicando cada t√©rmino de&nbsp;<span class="math inline">A(x)</span> por cada t√©rmino de&nbsp;<span class="math inline">B(x)</span> y acumulando los resultados que corresponden a la misma potencia de&nbsp;<span class="math inline">x</span>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multpol(a, b):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(b)<span class="op">==</span>n</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    c<span class="op">=</span>np.zeros(<span class="dv">2</span><span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            c[i<span class="op">+</span>j]<span class="op">+=</span>a[i]<span class="op">*</span>b[j]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>multpol(np.array([<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">6</span>,<span class="dv">1</span>]), np.array([<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>]))</span></code></pre></div>
<pre><code>array([  2.,   1.,  -3.,  18., -16.,  -3.,   1.])</code></pre>
<p>Evidentemente, este algoritmo demora tiempo&nbsp;<span class="math inline">O(n^2)</span>. ¬øEs posible hacerlo m√°s r√°pido? Para esto, aplicaremos la t√©cnica de <em>dividir para reinar</em>.</p>
<p>Supongamos que&nbsp;<span class="math inline">n</span> es par, y dividamos los polinomios en dos partes, separando las potencias bajas de las altas. Por ejemplo, si</p>
<p><span class="math display">
A(x)=2+3x-6x^2+x^3
</span></p>
<p>lo podemos reescribir como</p>
<p><span class="math display">
A(x)=(2+3x) + (-6+3x)x^2
</span></p>
<p>En general, podemos reescribir&nbsp;<span class="math inline">A(x)</span> y&nbsp;<span class="math inline">B(x)</span> como</p>
<p><span class="math display">
A(x) = A&#39;(x)+A&#39;&#39;(x)x^{n/2}
</span> <span class="math display">
B(x) = B&#39;(x)+B&#39;&#39;(x)x^{n/2}
</span></p>
<p>y entonces (omitiendo los ‚Äú<span class="math inline">(x)</span>‚Äù para simplificar la notaci√≥n),</p>
<p><span class="math display">
C = A&#39;B&#39;+(A&#39;B&#39;&#39;+A&#39;&#39;B&#39;)x^{n/2}+A&#39;&#39;B&#39;&#39;x^n
</span></p>
<p>Esto se puede implementar con 4 multiplicaciones recursivas, cada una involucrando polinomios de la mitad del tama√±o. N√≥tese que las multiplicaciones por potencias de&nbsp;<span class="math inline">x</span> son solo realineaciones de los arreglos de coeficientes, de modo que son ‚Äúgratis.‚Äù</p>
<p>Si llamamos&nbsp;<span class="math inline">T(n)</span> al n√∫mero total de operaciones, √©ste obedece la ecuaci√≥n de recurrencia</p>
<p><span class="math display">
T(n) = 4T \left(\frac{n}{2}\right)+Kn
</span></p>
<p>para alguna constante K.</p>
<p>Por el Teorema Maestro, con&nbsp;<span class="math inline">p=4</span>,&nbsp;<span class="math inline">q=2</span>,&nbsp;<span class="math inline">r=1</span>, tenemos</p>
<p><span class="math display">
T(n)=\Theta(n^2)
</span></p>
<p>lo cual no es mejor que el algoritmo anterior.</p>
<p>Afortunadamente, hay una manera de obtener un algoritmo realmente m√°s eficiente. Si calculamos</p>
<p><span class="math display">
\begin{align}
D &amp;= (A&#39;+A&#39;&#39;)(B&#39;+B&#39;&#39;)\\
E &amp;= A&#39;B&#39;\\
F &amp;= A&#39;&#39;B&#39;&#39;
\end{align}
</span></p>
<p>podemos construir el polinomio&nbsp;<span class="math inline">C</span> de la manera siguiente:</p>
<p><span class="math display">
C = E+(D-E-F)x^{n/2}+Fx^n
</span></p>
<p>¬°lo cual utiliza solo 3 multiplicaciones recursivas!</p>
<p><span class="math display">
T(n) = 3T \left(\frac{n}{2}\right)+Kn
</span></p>
<p>Usando nuevamente el Teorema Maestro, esta vez con&nbsp;<span class="math inline">p=3</span>, tenemos que</p>
<p><span class="math display">
T(n)=\Theta(n^{\log_2{3}}) \approx \Theta(n^{1.59})
</span></p>
<p>√âste se llama el <em>Algoritmo de Karatsuba</em>.</p>
<hr />
</section>
<section id="ejercicio-3.1" class="level3">
<h3>Ejercicio 3.1</h3>
<p>Si tenemos dos n√∫meros complejos</p>
<p><span class="math display">
\begin{align}
u&amp;=a+bi\\
v&amp;=c+di
\end{align}
</span></p>
<p>podemos calcular su producto</p>
<p><span class="math display">
uv=(ac-bd)+(ad+bc)i
</span></p>
<p>haciendo 4 multiplicaci√≥n de n√∫meros reales.</p>
<p>Encuentre una forma de realizar este c√°lculo haciendo solo 3 multiplicaciones de n√∫meros reales.</p>
<hr />
</section>
</section>
<section id="programaci√≥n-din√°mica" class="level2">
<h2>Programaci√≥n Din√°mica</h2>
<p>Hay ocasiones en que la simple aplicaci√≥n de la recursividad conduce a algoritmos muy ineficientes, pero es posible evitar esa ineficiencia con un uso adecuado de memoria.</p>
<section id="ejemplo-c√°lculo-de-un-n√∫mero-de-fibonacci" class="level3">
<h3>Ejemplo: C√°lculo de un n√∫mero de Fibonacci</h3>
<p>Recordemos la ecuaci√≥n de Fibonacci</p>
<p><span class="math display">
\begin{align}
f_n &amp;= f_{n-1}+f_{n-2} \text{ para } n\ge 2\\
f_0 &amp;= 0\\
f_1 &amp;= 1
\end{align}
</span></p>
<p>algunos de cuyos valores son:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">ùëõ</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">f_n</span></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
<td>144</td>
<td>233</td>
<td>377</td>
<td>610</td>
<td>987</td>
<td>1597</td>
<td>2584</td>
<td>4181</td>
<td>6765</td>
</tr>
</tbody>
</table>
<p>Queremos resolver el siguiente problema: dado un&nbsp;<span class="math inline">n</span>, calcular&nbsp;<span class="math inline">f_n</span>.</p>
<p>A partir de la ecuaci√≥n de recurrencia podemos escribir de inmediato una soluci√≥n recursiva:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">&lt;=</span><span class="dv">1</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fibonacci(n<span class="op">-</span><span class="dv">1</span>)<span class="op">+</span>fibonacci(n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fibonacci(<span class="dv">10</span>))</span></code></pre></div>
<pre><code>55</code></pre>
<p>El problema es que, para&nbsp;<span class="math inline">n</span> grande, este algoritmo es horriblemente ineficiente. El motivo de esto es que, a medida que se van ejecutando las llamadas recursivas, un mismo n√∫mero de Fibonacci puede calcularse m√∫ltiples veces, independientemente de si ya se ha calculado antes.</p>
<p>Una forma de dimensionar esta ineficiencia es calcular, por ejemplo, el n√∫mero de operaciones de suma que se hacen al calcular <code>fibonacci(n)</code>. Llamemos&nbsp;<span class="math inline">s_n</span> a ese n√∫mero de sumas. Es f√°cil ver que</p>
<p><span class="math display">
\begin{align}
s_n &amp;= s_{n-1}+s_{n-2}+1 \text{ para } n\ge 2\\
s_0 &amp;= 0\\
s_1 &amp;= 0
\end{align}
</span></p>
<p>Si definimos una nueva funci√≥n inc√≥gnita&nbsp;<span class="math inline">t_n=s_n+1</span>, tenemos que</p>
<p><span class="math display">
\begin{align}
t_n &amp;= t_{n-1}+t_{n-2} \text{ para } n\ge 2\\
t_0 &amp;= 1\\
t_1 &amp;= 1
\end{align}
</span></p>
<p>Esta es la misma ecuaci√≥n de Fibonacci, comenzando un paso m√°s adelante, y por lo tanto su soluci√≥n es&nbsp;<span class="math inline">t_n=f_{n+1}</span>, y el n√∫mero de sumas es&nbsp;<span class="math inline">s_n=f_{n+1}-1=\Theta(\phi^n)</span>. Conclusi√≥n: ¬°el tiempo que demora la ejecuci√≥n de <code>fibonacci(n)</code> crece exponencialmente!</p>
</section>
<section id="evitando-la-ineficiencia-memoizaci√≥n" class="level3">
<h3>Evitando la ineficiencia: Memoizaci√≥n</h3>
<p>La ineficiencia de la soluci√≥n recursiva se debe, como dijimos antes, a que un mismo valor de la funci√≥n&nbsp;<span class="math inline">f</span> se calcula y recalcula m√∫ltiples veces. Una forma de evitar esto es incorporar una memoria auxiliar, en forma de un arreglo&nbsp;<span class="math inline">F</span> inicializado con ceros. La primera vez que se pide calcular un&nbsp;<span class="math inline">f_n</span> dado, lo hacemos recursivamente, pero dejamos el valor anotado en&nbsp;<span class="math inline">F[n]</span>. Las siguientes veces lo tomamos del arreglo, sin incurrir de nuevo en el costo del c√°lculo recursivo. Esta forma de utilizar una memoria para almacenar resultados calculados previamente, para evitar recalcularlos, se llama una <em>memoria cach√©</em>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    F<span class="op">=</span>np.zeros(n<span class="op">+</span><span class="dv">1</span>,dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fib_rec(k):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> F[k]<span class="op">==</span><span class="dv">0</span>: <span class="co"># primera vez que se calcula</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k<span class="op">&lt;=</span><span class="dv">1</span>:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                F[k]<span class="op">=</span>k</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                F[k]<span class="op">=</span>fib_rec(k<span class="op">-</span><span class="dv">1</span>)<span class="op">+</span>fib_rec(k<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> F[k]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib_rec(n)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fibonacci(<span class="dv">10</span>))</span></code></pre></div>
<pre><code>55</code></pre>
<p>La introducci√≥n de esta memoria auxiliar tiene como efecto transformar el algoritmo original, de tiempo exponencial, en un algoritmo de tiempo lineal&nbsp;<span class="math inline">\Theta(n)</span>.</p>
</section>
<section id="evitando-la-ineficiencia-tabulaci√≥n" class="level3">
<h3>Evitando la ineficiencia: Tabulaci√≥n</h3>
<p>La t√©cnica de <em>memoizaci√≥n</em> va llenando el arreglo auxiliar&nbsp;<span class="math inline">F</span> a medida que sus valores son solicitados. Este m√©todo es bastante general, pero se puede mejorar si logramos encontrar un orden para ir llenando el arreglo&nbsp;<span class="math inline">F</span> que garantice que cuando se requiere el valor de un cierto casillero, √©ste ya est√° llenado.</p>
<p>En el caso de Fibonacci, esto se logra simplemente al ir llenando los casilleros&nbsp;<span class="math inline">F[k]</span> en orden creciente de&nbsp;<span class="math inline">k</span>. Esta t√©cnica se llama <em>tabulaci√≥n</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    F<span class="op">=</span>np.zeros(n<span class="op">+</span><span class="dv">1</span>,dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    F[<span class="dv">0</span>]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    F[<span class="dv">1</span>]<span class="op">=</span><span class="dv">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        F[k]<span class="op">=</span>F[k<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>F[k<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F[n]</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fibonacci(<span class="dv">10</span>))</span></code></pre></div>
<pre><code>55</code></pre>
<p>Es evidente que el tiempo que demora este algoritmo es&nbsp;<span class="math inline">\Theta(n)</span>.</p>
</section>
<section id="derrotando-al-algoritmo-lineal" class="level3">
<h3>Derrotando al algoritmo lineal</h3>
<p>Si bien parecer√≠a que para calcular&nbsp;<span class="math inline">f_n</span> es necesario calcular previamente todos los&nbsp;<span class="math inline">f_k</span>, para&nbsp;<span class="math inline">0\le k&lt;n</span>, en realidad esto no es cierto.</p>
<p>Introduzcamos una funci√≥n inc√≥gnita adicional&nbsp;<span class="math inline">g_n</span> en la ecuaci√≥n de Fibonacci, defini√©ndola como&nbsp;<span class="math inline">g_n=f_{n-1}</span>. La ecuaci√≥n puede reescribirse as√≠:</p>
<p><span class="math display">
\begin{align}
f_n &amp;= f_{n-1}+g_{n-1}\\
g_n &amp;= f_{n-1}\\
f_1 &amp;=1\\
g_1 &amp;=0
\end{align}
</span></p>
<p>Esto se puede reescribir en forma matricial:</p>
<p><span class="math display">
\begin{pmatrix}
f_n \\
g_n
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 1\\
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
f_{n-1} \\
g_{n-1}
\end{pmatrix}
\text{ para }n\ge 2
</span></p>
<p>con la condici√≥n inicial</p>
<p><span class="math display">
\begin{pmatrix}
f_1 \\
g_1
\end{pmatrix}
=
\begin{pmatrix}
1 \\
0
\end{pmatrix}
</span></p>
<p>Este ecuaci√≥n es muy simple de resolver ‚Äúdesenrroll√°ndola,‚Äù y su soluci√≥n es</p>
<p><span class="math display">
\begin{pmatrix}
f_n \\
g_n
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 1\\
1 &amp; 0
\end{pmatrix}^{n-1}
\begin{pmatrix}
1 \\
0
\end{pmatrix}
</span></p>
<p>Por lo tanto, para resolver el problema del calcular&nbsp;<span class="math inline">f_n</span>, basta evaluar esta f√≥rmula matricial y luego tomar la primera componente del vector resultante.</p>
<p>Recordando que para la elevaci√≥n a potencia podemos usar el algoritmo binario, la evaluaci√≥n de la f√≥rmula se puede hacer en tiempo logar√≠tmico, y por lo tanto el problema de calcular&nbsp;<span class="math inline">f_n</span> se puede resolver en tiempo&nbsp;<span class="math inline">\Theta(\log{n})</span>.</p>
<p>La siguiente es una versi√≥n del algoritmo <code>potencia</code> adaptada para calcular&nbsp;<span class="math inline">B=A^n</span> cuando&nbsp;<span class="math inline">A</span> es una matriz cuadrada:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potencia(A, n):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    B<span class="op">=</span>np.eye(<span class="bu">len</span>(A),dtype<span class="op">=</span><span class="bu">int</span>) <span class="co"># matriz identidad</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>n</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    C<span class="op">=</span>A</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> k<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> k<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            C<span class="op">=</span>np.dot(C,C) <span class="co"># C=C**2</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            k<span class="op">//=</span><span class="dv">2</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        B<span class="op">=</span>np.dot(B,C) <span class="co"># B=C*C</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        k<span class="op">-=</span><span class="dv">1</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    F<span class="op">=</span>np.dot(potencia(np.array([[<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">0</span>]]),n<span class="op">-</span><span class="dv">1</span>), np.array([[<span class="dv">1</span>],[<span class="dv">0</span>]]))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F[<span class="dv">0</span>,<span class="dv">0</span>]</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fibonacci(<span class="dv">10</span>))</span></code></pre></div>
<pre><code>55</code></pre>
<hr />
</section>
<section id="ejercicio-3.2" class="level3">
<h3>Ejercicio 3.2</h3>
<p>Si&nbsp;<span class="math inline">f_n</span> son los n√∫meros de Fibonacci, demuestre que, para todo&nbsp;<span class="math inline">n\ge 1</span>,</p>
<p><span class="math display">
\begin{pmatrix}
1 &amp; 1\\
1 &amp; 0
\end{pmatrix}^n
=
\begin{pmatrix}
f_{n+1} &amp; f_n \\
f_n &amp; f_{n-1}
\end{pmatrix}
</span></p>
<hr />
</section>
<section id="ejemplo-encontrar-la-parentizaci√≥n-√≥ptima-para-multiplicaci√≥n-de-n-matrices" class="level3">
<h3>Ejemplo: Encontrar la parentizaci√≥n √≥ptima para multiplicaci√≥n de <span class="math inline">n</span> matrices</h3>
<p>Hemos visto que las t√©cnicas de <em>memoizaci√≥n</em> y de <em>tabulaci√≥n</em> nos permiten construir algoritmos eficientes en algunos problemas en que la recursividad aplicada directamente dar√≠a soluciones muy ineficientes.</p>
<p>Cuando estas t√©cnicas se aplican a problemas de optimizaci√≥n, hablamos de <em>programaci√≥n din√°mica</em>.</p>
<p>Consideremos el siguiente problema: Dadas tres matrices&nbsp;<span class="math inline">A</span>,&nbsp;<span class="math inline">B</span> y&nbsp;<span class="math inline">C</span> para las cuales se desea calcular su producto&nbsp;<span class="math inline">A B C</span>, ¬øqu√© es m√°s eficiente, calcular&nbsp;<span class="math inline">(A B)C</span> o calcular&nbsp;<span class="math inline">A (B C)</span>?</p>
<p>La respuesta depende de las dimensiones de las matrices involucradas. Si una matriz&nbsp;<span class="math inline">A</span> es de&nbsp;<span class="math inline">p\times q</span> y otra matriz&nbsp;<span class="math inline">B</span> es de&nbsp;<span class="math inline">q\times r</span>, calcular su producto&nbsp;<span class="math inline">A B</span> utilizando el algoritmo usual requiere hacer&nbsp;<span class="math inline">pqr</span> multiplicaciones escalares, y un n√∫mero similar de sumas.</p>
<p>Para nuestro problema de calcular&nbsp;<span class="math inline">ABC</span>, supongamos por ejemplo que&nbsp;<span class="math inline">A</span> es de&nbsp;<span class="math inline">100\times 10</span>,&nbsp;<span class="math inline">B</span> de&nbsp;<span class="math inline">10\times 100</span> y&nbsp;<span class="math inline">C</span> de&nbsp;<span class="math inline">100\times 10</span>, tenemos que</p>
<ul>
<li>Calcular <span class="math inline">(AB)C</span> requiere <span class="math inline">100\times 10\times 100+100\times 100\times 10=200.000</span> multiplicaciones</li>
<li>Calcular <span class="math inline">A(BC)</span> requiere <span class="math inline">10\times 100\times 10+100\times 10\times 10=20.000</span> multiplicaciones</li>
</ul>
<p>La respuesta, por lo tanto, es que para las dimensiones dadas, la parentizaci√≥n √≥ptima es&nbsp;<span class="math inline">A(BC)</span>.</p>
<p>Consideremos ahora el problema general. Dadas&nbsp;<span class="math inline">n</span> matrices&nbsp;<span class="math inline">A_1, A_2, \ldots, A_n</span> y n√∫meros&nbsp;<span class="math inline">p[0], p[1], \ldots, p[n]</span> tales que la matriz&nbsp;<span class="math inline">A_i</span> es de&nbsp;<span class="math inline">p[i-1]\times p[i]</span>, encontrar el costo (en n√∫mero de multiplicaciones) de la parentizaci√≥n √≥ptima para calcular el producto</p>
<p><span class="math display">
A_1 A_2 \cdots A_n
</span></p>
<p>Generalicemos el problema para poder abordarlo recursivamente (o inductivamente). Supongamos que el problema es encontrar el costo de la parentizaci√≥n √≥ptima para calcular el producto</p>
<p><span class="math display">
A_i \cdots A_j
</span></p>
<p>para&nbsp;<span class="math inline">1\le i\le j\le n</span>. Llamemos&nbsp;<span class="math inline">m[i,j]</span> a este costo √≥ptimo.</p>
<p>En el caso&nbsp;<span class="math inline">i=j</span> el producto involucra a una sola matriz, as√≠ que, trivialmente,&nbsp;<span class="math inline">m[i,i]=0</span>. En el caso&nbsp;<span class="math inline">i&lt;j</span>, supongamos que parentizamos de modo que el producto se factorice como</p>
<p><span class="math display">
(A_i \cdots A_k)(A_{k+1}\cdots A_j)
</span></p>
<p>para alg√∫n&nbsp;<span class="math inline">k\in [i..j-1]</span>. Suponiendo que cada producto parentizado se ha calculado en forma √≥ptima, el costo total ser√≠a</p>
<p><span class="math display">
m[i,k]+m[k+1,j]+p[i-1]\times p[k]\times p[j]
</span></p>
<p>Esto no es necesariamente √≥ptimo para el producto&nbsp;<span class="math inline">A_i \cdots A_j</span>, porque podr√≠amos haber elegido el valor equivocado de&nbsp;<span class="math inline">k</span>. Para asegurarnos de alcanzar el √≥ptimo, tenemos que minimizar sobre todo&nbsp;<span class="math inline">k</span>:</p>
<p><span class="math display">
m[i,j] = \min_{i\le k\le j-1} \left\{ m[i,k]+m[k+1,j]+p[i-1]\times p[k]\times p[j] \right\}
</span></p>
<p>Esto lo podr√≠amos implementar mediante una funci√≥n recursiva, pero, tal como suced√≠a en el ejemplo de Fibonacci, √©sta demorar√≠a un tiempo exponencial en ejecutarse, porque generar√≠a y evaluar√≠a todas las parentizaciones posibles. Esta b√∫squeda exhaustiva es un m√©todo que encuentra la respuesta correcta (se le suele llamar ‚Äúm√©todo fuerza bruta‚Äù), pero usualmente es demasiado ineficiente.</p>
<p>Afortunadamente, en este caso podemos usar tabulaci√≥n, porque hay solo alrededor de&nbsp;<span class="math inline">n^2/2</span> casilleros que llenar en la matriz&nbsp;<span class="math inline">m</span>, y los podemos ir llenando en un orden tal que al calcular el m√≠nimo sobre todo&nbsp;<span class="math inline">k</span>, los casilleros necesarios ya han sido llenados previamente.</p>
<p>En efecto, introduzcamos una nueva variable&nbsp;<span class="math inline">d=j-i+1</span>. Esto es el n√∫mero de matrices involucradas en el producto&nbsp;<span class="math inline">A_i \cdots A_j</span>. Lo que haremos ser√° ir llenando la matriz en orden ascendente de la variable&nbsp;<span class="math inline">d</span>, comenzando con el caso trivial&nbsp;<span class="math inline">d=1</span>, hasta terminar con el caso&nbsp;<span class="math inline">d=n</span>, que corresponde a la soluci√≥n del problema original.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> opti_multi_mat(p):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(p)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)) <span class="co"># Esto ya deja la diagonal en cero</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">-</span>d<span class="op">+</span><span class="dv">2</span>):</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i<span class="op">+</span>d<span class="op">-</span><span class="dv">1</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            m[i,j]<span class="op">=</span>math.inf <span class="co"># +infinito</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i,j):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>                q<span class="op">=</span>m[i,k]<span class="op">+</span>m[k<span class="op">+</span><span class="dv">1</span>,j]<span class="op">+</span>p[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>p[k]<span class="op">*</span>p[j]</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> q<span class="op">&lt;</span>m[i,j]:</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>                    m[i,j]<span class="op">=</span>q</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m[<span class="dv">1</span>,n]</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>p<span class="op">=</span>np.array([<span class="dv">100</span>,<span class="dv">10</span>,<span class="dv">100</span>,<span class="dv">10</span>])</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(opti_multi_mat(p))</span></code></pre></div>
<pre><code>20000.0</code></pre>
<p>Es f√°cil ver que este algoritmo corre en tiempo&nbsp;<span class="math inline">O(n^3)</span>, porque debe rellenar&nbsp;<span class="math inline">\Theta(n^2)</span> casilleros, y cada uno puede requerir examinar&nbsp;<span class="math inline">n</span> valores posibles de&nbsp;<span class="math inline">k</span> en el peor caso. Esto es significativamente mejor que el algoritmo de fuerza bruta.</p>
<p>Esta cota c√∫bica podr√≠a, sin embargo, ser un poco exagerada, porque en muchos casos la variable&nbsp;<span class="math inline">k</span> toma mucho menos que&nbsp;<span class="math inline">n</span> valores. Un c√°lculo m√°s preciso nos se√±ala que el n√∫mero total de veces que se ejecuta el cuerpo del ciclo <code>for k</code> es igual a</p>
<p><span class="math display">
\sum_{1\le i\le k&lt;j\le n} 1 =\frac{n(n-1)(n+1)}{6} = \Theta(n^3)
</span></p>
<p>Por lo tanto el algoritmo en realidad demora un tiempo c√∫bico.</p>
<p>Como vemos, el resultado del proceso es el costo √≥ptimo, pero eso no nos da ninguna informaci√≥n sobre cu√°l es la parentizaci√≥n √≥ptima. Pero en realidad la informaci√≥n est√° ah√≠, porque el valor de&nbsp;<span class="math inline">k</span> para el cual se alcanza el m√≠nimo nos dice d√≥nde separar la parentizaci√≥n en cada caso. Basta entonces con que dejemos anotado, para cada&nbsp;<span class="math inline">i,j</span> cu√°l es el valor de&nbsp;<span class="math inline">k</span> para el que se alcanza el m√≠nimo. Llamemos&nbsp;<span class="math inline">s[i,j]</span> a ese valor de&nbsp;<span class="math inline">k</span>.</p>
<p>Modifiquemos nuestra funci√≥n para que construya y retorne la matriz&nbsp;<span class="math inline">s</span> adem√°s del costo √≥ptimo, y escribamos otra funci√≥n que, dada esa matriz&nbsp;<span class="math inline">s</span>, imprima la f√≥rmula parentizada de la manera √≥ptima.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> opti_multi_mat(p):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(p)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)) <span class="co"># Esto ya deja la diagonal en cero</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>),dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">-</span>d<span class="op">+</span><span class="dv">2</span>):</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i<span class="op">+</span>d<span class="op">-</span><span class="dv">1</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>            m[i,j]<span class="op">=</span>math.inf <span class="co"># +infinito</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i,j):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                q<span class="op">=</span>m[i,k]<span class="op">+</span>m[k<span class="op">+</span><span class="dv">1</span>,j]<span class="op">+</span>p[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>p[k]<span class="op">*</span>p[j]</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> q<span class="op">&lt;</span>m[i,j]:</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>                    m[i,j]<span class="op">=</span>q</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>                    s[i,j]<span class="op">=</span>k <span class="co"># anotamos d√≥nde se alcanza el min</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (m[<span class="dv">1</span>,n],s)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paren_desde_hasta(s,i,j):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">==</span>j:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;A&quot;</span><span class="op">+</span><span class="bu">str</span>(i)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span>paren_desde_hasta(s,i,s[i,j])<span class="op">+</span><span class="st">&quot; &quot;</span>\</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">+</span>paren_desde_hasta(s,s[i,j]<span class="op">+</span><span class="dv">1</span>,j)<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parentizacion(s):</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(s)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> paren_desde_hasta(s,<span class="dv">1</span>,n)</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>p<span class="op">=</span>np.array([<span class="dv">100</span>,<span class="dv">10</span>,<span class="dv">100</span>,<span class="dv">10</span>])</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>(opt,s)<span class="op">=</span>opti_multi_mat(p)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(parentizacion(s))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Costo=&quot;</span>, opt)</span></code></pre></div>
<pre><code>(A1 (A2 A3))
Costo= 20000.0</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>p<span class="op">=</span>np.array([<span class="dv">30</span>,<span class="dv">35</span>,<span class="dv">15</span>,<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">25</span>])</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>(opt,s)<span class="op">=</span>opti_multi_mat(p)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(parentizacion(s))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Costo=&quot;</span>, opt)</span></code></pre></div>
<pre><code>((A1 (A2 A3)) ((A4 A5) A6))
Costo= 15125.0</code></pre>
<p>Para recapitular, la t√©cnica de dise√±o de programaci√≥n din√°mica divide un problema en varios subproblemas con la misma estructura que el problema original, luego se resuelven dichos subproblemas y finalmente, a partir de √©stos, se obtiene la soluci√≥n al problema original. La diferencia radica en que la programaci√≥n din√°mica se ocupa cuando los subproblemas se repiten, como en el c√°lculo de los n√∫meros de Fibonacci. En este caso, en vez de usar recursi√≥n para obtener las soluciones a los subproblemas √©stas se van tabulando en forma bottom-up, y luego estos resultados son utilizados para resolver subproblemas m√°s grandes. De esta forma, se evita el tener que realizar el mismo llamado recursivo varias veces.</p>
<p>La programaci√≥n din√°mica se ocupa en general para resolver problemas de optimizaci√≥n (maximizaci√≥n o minimizaci√≥n de alguna funci√≥n objetivo). Estos problemas pueden tener una o varias soluciones √≥ptimas, y el objetivo es encontrar alguna de ellas. Los pasos generales para utilizar programaci√≥n din√°mica en la resoluci√≥n de un problema son los siguientes:</p>
<ul>
<li><p>Encontrar la subestructura √≥ptima del problema, es decir, encontrar aquellos subproblemas en los que se compone el problema original, tal que si uno encuentra sus soluciones √≥ptimas entonces es posible obtener la soluci√≥n √≥ptima al problema original.</p></li>
<li><p>Definir el valor de la soluci√≥n √≥ptima en forma recursiva.</p></li>
<li><p>Calcular el valor de la soluci√≥n partiendo primero por los subproblemas m√°s peque√±os y tabul√°ndo las soluciones, lo que luego permite obtener la soluci√≥n de subproblemas m√°s grandes. Terminar cuando se tiene la soluci√≥n al problema original.</p></li>
</ul>
<p>Estos pasos permiten obtener el valor √≥ptimo de la soluci√≥n al problema. Tambi√©n es posible ir guardando informaci√≥n extra en cada paso del algoritmo, que luego permita reconstruir el camino realizado para hallar la soluci√≥n √≥ptima (por ejemplo, para obtener la instancia espec√≠fica de la soluci√≥n √≥ptima, y no s√≥lo el valor √≥ptimo de la funci√≥n objetivo).</p>
</section>
<section id="ejemplo-encontrar-la-subsecuencia-com√∫n-m√°s-larga" class="level3">
<h3>Ejemplo: Encontrar la subsecuencia com√∫n m√°s larga</h3>
<p>Dadas dos secuencias de datos&nbsp;<span class="math inline">a</span> y&nbsp;<span class="math inline">b</span>, de largo&nbsp;<span class="math inline">m</span> y&nbsp;<span class="math inline">n</span> respectivamente (pueden ser listas o strings), una subsecuencia com√∫n es una subsecuencia de elementos (posiblemente saltados) de&nbsp;<span class="math inline">a</span> que coincide con una subsecuencia de&nbsp;<span class="math inline">b</span>. Nos interesa encontrar el largo de la subsecuencia com√∫n m√°s larga (en ingl√©s <em>LCS</em>, por <em>longest common subsequence</em>).</p>
<p>Este problema se puede resolver recursivamente. La condici√≥n de borde es que la subsecuencia com√∫n m√°s larga entre dos secuencias en que al menos una de ellas es vac√≠a (de largo cero) es la secuencia vac√≠a. Si ambas secuencias son no vac√≠as, observamos que una subsecuencia com√∫n m√°s larga entre&nbsp;<span class="math inline">a[0:i]</span> y&nbsp;<span class="math inline">b[0:j]</span> se puede obtener de la siguiente manera:</p>
<ul>
<li>Si ambas secuencias terminan en el mismo elemento, agregamos ese elemento al final de la subsecuencia com√∫n m√°s larga entre <span class="math inline">a[0:i-1]</span> y <span class="math inline">b[0:j-1]</span></li>
<li>Si no terminan en el mismo elemento, tomamos lo m√°s largo que resulte entre ignorar el √∫ltimo elemento de <span class="math inline">a[0:i]</span> y buscar una subsecuencia com√∫n m√°s larga entre <span class="math inline">a[0:i-1]</span> y <span class="math inline">b[0:j]</span>, o ignorar el √∫ltimo elemento de <span class="math inline">b[0:j]</span> y buscar una subsecuencia com√∫n m√°s larga entre <span class="math inline">a[0:i]</span> y <span class="math inline">b[0:j-1]</span></li>
</ul>
<p>Si llamamos&nbsp;<span class="math inline">L_{i,j}</span> al largo de la subsecuencia com√∫n m√°s larga entre&nbsp;<span class="math inline">a[0:i]</span> y&nbsp;<span class="math inline">b[0:j]</span>, tenemos que&nbsp;<span class="math inline">L_{0,j}=L_{i,0}=0</span>, y que para&nbsp;<span class="math inline">i,j&gt;0</span></p>
<p><span class="math display">
L_{i,j}=
\begin{cases}
1+L_{i-1,j-1} &amp; \text{si } a[i-1]=b[j-1]\\
\max\{L_{i,j-1},L_{i-1,j}\} &amp; \text{si } a[i-1] \ne b[j-1]
\end{cases}
</span></p>
<p>El resultado buscado es&nbsp;<span class="math inline">L_{m,n}</span>.</p>
<p>Una implementaci√≥n eficiente de este algoritmo se puede lograr usando tabulaci√≥n:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> LCS(a,b):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Encuentra el largo de la subsecuencia com√∫n m√°s larga entre a y b</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    m<span class="op">=</span><span class="bu">len</span>(a)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(b)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    L<span class="op">=</span>np.zeros((m<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>),dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[i<span class="op">-</span><span class="dv">1</span>]<span class="op">==</span>b[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>                L[i,j]<span class="op">=</span><span class="dv">1</span><span class="op">+</span>L[i<span class="op">-</span><span class="dv">1</span>,j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>                L[i,j]<span class="op">=</span><span class="bu">max</span>(L[i<span class="op">-</span><span class="dv">1</span>,j],L[i,j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> L[m,n] </span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(LCS(<span class="st">&quot;abracadabra&quot;</span>,<span class="st">&quot;pasapalabra&quot;</span>))</span></code></pre></div>
<pre><code>7</code></pre>
<hr />
</section>
<section id="ejercicio-3.3" class="level3">
<h3>Ejercicio 3.3</h3>
<p>Modifique la funci√≥n <code>LCS</code> para que retorne una subsecuencia com√∫n m√°s larga, en lugar de retornar su longitud.</p>
<hr />
</section>
</section>
<section id="algoritmos-avaros-greedy-algorithms" class="level2">
<h2>Algoritmos Avaros (<em>Greedy Algorithms</em>)</h2>
<p>Se dice que un algoritmo de optimizaci√≥n es <em>avaro</em> si siempre toma la decisi√≥n √≥ptima de corto plazo. Por ejemplo, un algoritmo avaro que intenta llegar a la cima del cerro m√°s alto, dar√≠a siempre un paso en la direcci√≥n que le permite subir m√°s con ese paso.</p>
<p>En general, la estrategia avara no garantiza llegar a un √≥ptimo global, porque es f√°cil quedarse atrapado en un √≥ptimo local (en nuestro ejemplo, llegar a la cima de un cerro peque√±o y no poder salir de ah√≠).</p>
<p>Sin embargo, hay problemas para los cuales la estrategia avara s√≠ encuentra un √≥ptimo global:</p>
<section id="ejemplo-asignaci√≥n-de-actividades" class="level3">
<h3>Ejemplo: Asignaci√≥n de actividades</h3>
<p>Supongamos que hay un conjunto&nbsp;<span class="math inline">n</span> de actividades&nbsp;<span class="math inline">a_1, \ldots, a_n</span> que para poder realizarse necesitan acceso a un recurso que no puede ser compartido. Por ejemplo,&nbsp;<span class="math inline">n</span> reuniones que solo se pueden realizar en una √∫nica sala.</p>
<p>Cada actividad tiene un tiempo de inicio&nbsp;<span class="math inline">t_i</span> y un tiempo de t√©rmino&nbsp;<span class="math inline">t_f</span>, lo que se interpreta como que necesita ocupar el recurso en el intervalo&nbsp;<span class="math inline">[t_i,t_f)</span>, cerrado a la izquierda, abierto a la derecha. Se dice que dos actividades son compatibles si sus respectivos intervalos no se traslapan. El problema de asignaci√≥n de actividades consiste en encontrar un conjunto maximal de actividades compatibles.</p>
<p>Por ejemplo, para el siguiente conjunto de actividades,</p>
<figure>
<img src="recursos/actividades.png" alt="actividades" /><figcaption aria-hidden="true">actividades</figcaption>
</figure>
<p>un conjunto compatible maximal es&nbsp;<span class="math inline">\{a_1,a_3,a_4,a_6,a_7\}</span>.</p>
<p>Un problema de optimizaci√≥n de este tipo siempre se puede resolver por fuerza bruta, porque el n√∫mero de soluciones posibles es finito, pero tratamos de evitarlo a menos que no haya alternativa, porque puede demorar un tiempo exponencial.</p>
<p>En este caso, podemos resolver el problema de manera mucho m√°s eficiente (tiempo&nbsp;<span class="math inline">\Theta(n)</span>) usando una estrategia avara.</p>
<p>Supongamos que las actividades est√°n ordenadas en forma ascendente por su hora de t√©rmino&nbsp;<span class="math inline">t_f</span>. El algoritmo escoge la primera actividad disponible en este orden, luego elimina todas las actividades que se superponen con ella, y a continuaci√≥n repite el proceso con las actividades restantes:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input es una matriz con filas de la forma [ti,tf]</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ordenada ascendente por tf</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>A<span class="op">=</span>np.array([ [<span class="dv">0</span>,<span class="dv">0</span>], <span class="co"># la fila 0 se ignora</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">3</span>],</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">6</span>],</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">5</span>,<span class="dv">7</span>],</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">7</span>,<span class="dv">8</span>],</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>,<span class="dv">9</span>],</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">10</span>,<span class="dv">11</span>],</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">11</span>,<span class="dv">12</span>],</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">9</span>,<span class="dv">12</span>]</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>])</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> asigna_avaro(A):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(A)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    sol<span class="op">=</span>[<span class="dv">1</span>] <span class="co"># la primera tarea es siempre parte de la soluci√≥n</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span><span class="dv">1</span>     <span class="co"># j identifica a la m√°s reciente tarea seleccionada</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A[i,<span class="dv">0</span>]<span class="op">&gt;=</span>A[j,<span class="dv">1</span>]: <span class="co"># ti[i]&gt;=tf[j] ==&gt; i es la primera tarea</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>            sol.append(i)  <span class="co"># que es compatible con j, se agrega</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i            <span class="co"># a la soluci√≥n y pasa a ser la m√°s reciente</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sol</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>asigna_avaro(A)</span></code></pre></div>
<pre><code>[1, 3, 4, 6, 7]</code></pre>
<p>El algoritmo resultante se llama ‚Äú<em>Earliest-Finish-First</em>‚Äù (<em>EFF</em>).</p>
<p>¬øC√≥mo podemos estar seguros que la soluci√≥n encontrada es realmente √≥ptima?</p>
<p>Demostraremos por inducci√≥n sobre&nbsp;<span class="math inline">n</span> que el algoritmo avaro encuentra una soluci√≥n √≥ptima.</p>
<p>Trivialmente el algoritmo encuentra la soluci√≥n correcta en el caso&nbsp;<span class="math inline">n=1</span>.</p>
<p>Consideremos entonces el caso&nbsp;<span class="math inline">n&gt;1</span> y supongamos, por contradicci√≥n, que no existe ninguna soluci√≥n √≥ptima que incluya a la actividad&nbsp;<span class="math inline">a_1</span>. Consideremos una soluci√≥n √≥ptima y supongamos que su actividad con menor&nbsp;<span class="math inline">t_f</span> es la actividad&nbsp;<span class="math inline">a_k</span>. Dado que la lista est√° ordenada por&nbsp;<span class="math inline">t_f</span>, se tiene que&nbsp;<span class="math inline">t_f[1]\le t_f[k]</span>. Como la soluci√≥n no puede contener ninguna otra actividad que comience antes de&nbsp;<span class="math inline">t_f[k]</span>, entonces podemos reemplazar la actividad&nbsp;<span class="math inline">a_k</span> por la actividad&nbsp;<span class="math inline">a_1</span> y obtenemos otra soluci√≥n v√°lida y que tiene el mismo n√∫mero de actividades, por lo tanto tambi√©n es √≥ptima: contradicci√≥n con la hip√≥tesis que&nbsp;<span class="math inline">a_1</span> no pod√≠a ser parte de ninguna soluci√≥n √≥ptima.</p>
<p>Por lo tanto,&nbsp;<span class="math inline">a_1</span> puede ser parte de una soluci√≥n √≥ptima, y en consecuencia ninguna actividad que se superponga con ella puede estar inclu√≠da. Si las eliminamos, lo que queda es un problema de optimizaci√≥n del mismo tipo, pero con un n√∫mero estrictamente menor de actividades, el cual lo resuelve correctamente el algoritmo avaro por hip√≥tesis de inducci√≥n.</p>
</section>
</section>
<section id="backtracking" class="level2">
<h2>Backtracking</h2>
<p>Hay ocasiones en que no tenemos m√°s alternativa que resolver un problema por prueba y error, explorando un espacio de soluciones en forma exhaustiva. Una forma de hacerlo es en forma recursiva, probando distintas v√≠as de soluci√≥n hasta que alguna funcione, o hasta agotar las posibilidades.</p>
<section id="el-laberinto" class="level3">
<h3>El laberinto</h3>
<p>Supongamos que nos encontramos al interior de un laberinto y queremos encontrar la salida. Si no tenemos ninguna informaci√≥n adicional, lo que podemos hacer es intentar salir en una direcci√≥n, si eso no funciona intentar en otras, etc.</p>
<p>Para fijar las ideas, supongamos que el laberinto se dibuja usando caracteres del teclado, donde los espacios en blanco son lugares por donde se puede pasar, y el sigo ‚Äúigual‚Äù representa la salida. Todos los dem√°s s√≠mbolos representan murallas. Por ejemplo,</p>
<pre><code>+--+-----+--+
|  |     |  |
|  +--+     =
|     |  |  |
+--+  |  |  |
|  |        |
|  |     |  |
+--+-----+--+</code></pre>
<p>Almacenaremos el laberinto en una lista de strings (de a uno por l√≠nea):</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  +--+     =&quot;</span>,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|     |  |  |&quot;</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+  |  |  |&quot;</span>,</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |        |&quot;</span>,</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>El problema es determinar si existe una manera de salir si uno comienza en el casillero&nbsp;<span class="math inline">[i][j]</span>. Solo est√° permitido moverse en direcci√≥n horizontal o vertical, no en diagonal.</p>
<p>Resolveremos este problema escribiendo una funci√≥n booleana&nbsp;<span class="math inline">salida(i,j)</span> que retorna verdadero si existe un camino hacia la salida a partir de la coordenada&nbsp;<span class="math inline">i,j</span>. Esto lo hace intentando en las cuatro direcciones:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> salida(i,j):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L[i][j]<span class="op">==</span><span class="st">&quot;=&quot;</span>: <span class="co"># encontramos la salida</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L[i][j]<span class="op">!=</span><span class="st">&quot; &quot;</span>: <span class="co"># espacio ocupado</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> salida(i,j<span class="op">-</span><span class="dv">1</span>) <span class="op">\</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i,j<span class="op">+</span><span class="dv">1</span>) <span class="op">\</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i<span class="op">-</span><span class="dv">1</span>,j) <span class="op">\</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i<span class="op">+</span><span class="dv">1</span>,j):</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span>  </span></code></pre></div>
<p>Probemos si es posible salir desde la posici√≥n&nbsp;<span class="math inline">5,2</span> (¬°pero por si acaso estemos atentos al bot√≥n para interrumpir el proceso!)</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span>,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  +--+     =&quot;</span>,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|     |  |  |&quot;</span>,</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+  |  |  |&quot;</span>,</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |        |&quot;</span>,</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(salida(<span class="dv">5</span>,<span class="dv">2</span>))</span></code></pre></div>
<pre><code>---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)

&lt;ipython-input-19-0ea1bd4da578&gt; in &lt;module&gt;
      9 &quot;+--+-----+--+&quot;
     10 ]
---&gt; 11 print(salida(5,2))


&lt;ipython-input-18-ba8a4ad77a65&gt; in salida(i, j)
      4     if L[i][j]!=&quot; &quot;: # espacio ocupado
      5         return False
----&gt; 6     if salida(i,j-1) \
      7     or salida(i,j+1) \
      8     or salida(i-1,j) \


&lt;ipython-input-18-ba8a4ad77a65&gt; in salida(i, j)
      5         return False
      6     if salida(i,j-1) \
----&gt; 7     or salida(i,j+1) \
      8     or salida(i-1,j) \
      9     or salida(i+1,j):


... last 2 frames repeated, from the frame below ...


&lt;ipython-input-18-ba8a4ad77a65&gt; in salida(i, j)
      4     if L[i][j]!=&quot; &quot;: # espacio ocupado
      5         return False
----&gt; 6     if salida(i,j-1) \
      7     or salida(i,j+1) \
      8     or salida(i-1,j) \


RecursionError: maximum recursion depth exceeded in comparison</code></pre>
<p>Lo m√°s probable es que el programa se haya ca√≠do por exceso de recursividad antes de que tuvi√©ramos que interrumpirlo a mano.</p>
<p>Lo que sucede es que olvidamos incluir algo que impidiera que el programa explorara de nuevo un camino que ya antes hab√≠a recorrido sin √©xito, y eso lo condujo a entrar en un ‚Äúloop‚Äù infinito.</p>
<p>Para evitar esto, iremos marcando con un s√≠mbolo ‚Äúx‚Äù los casilleros a medida que van siendo visitados. De esta forma, ninguno se puede visitar m√°s de una vez:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> salida(i,j):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L[i][j]<span class="op">==</span><span class="st">&quot;=&quot;</span>: <span class="co"># encontramos la salida</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L[i][j]<span class="op">!=</span><span class="st">&quot; &quot;</span>: <span class="co"># espacio ocupado</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    L[i]<span class="op">=</span>L[i][:j]<span class="op">+</span><span class="st">&quot;x&quot;</span><span class="op">+</span>L[i][j<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> salida(i,j<span class="op">-</span><span class="dv">1</span>) <span class="op">\</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i,j<span class="op">+</span><span class="dv">1</span>) <span class="op">\</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i<span class="op">-</span><span class="dv">1</span>,j) <span class="op">\</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or</span> salida(i<span class="op">+</span><span class="dv">1</span>,j):</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span>  </span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span>,</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  +--+     =&quot;</span>,</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|     |  |  |&quot;</span>,</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+  |  |  |&quot;</span>,</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |        |&quot;</span>,</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(salida(<span class="dv">5</span>,<span class="dv">2</span>))</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> linea <span class="kw">in</span> L:</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(linea)</span></code></pre></div>
<pre><code>False
+--+-----+--+
|  |     |  |
|  +--+     =
|     |  |  |
+--+  |  |  |
|xx|        |
|xx|     |  |
+--+-----+--+</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span>,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  +--+     =&quot;</span>,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|     |  |  |&quot;</span>,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+  |  |  |&quot;</span>,</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |        |&quot;</span>,</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;|  |     |  |&quot;</span>,</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;+--+-----+--+&quot;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(salida(<span class="dv">4</span>,<span class="dv">10</span>))</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> linea <span class="kw">in</span> L:</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(linea)</span></code></pre></div>
<pre><code>True
+--+-----+--+
|xx|xxxxx|  |
|xx+--+xxxxx=
|xxxxx|xx|xx|
+--+xx|xx|xx|
|  |xxxxxxxx|
|  |xxxxx|xx|
+--+-----+--+</code></pre>
<hr />
</section>
<section id="ejercicio-3.4" class="level3">
<h3>Ejercicio 3.4</h3>
<p>Modifique la funci√≥n para que marque con <code>"."</code> los casilleros por donde hubo intentos no exitosos de salir, y con <code>"x"</code> los casilleros que finalmente condujeron a la salida.</p>
<hr />
</section>
</section>
</section>

<div id="lastupdate">
Last updated: jue mar  4 15:10:55 -05 2021
</div>
</article>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</body>
</html>
