<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>shared-macros</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>



<div id="collapsiblemenu">
  <button class="collapsible">
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
    <div class="shortthickbar"></div>
  </button>
  <div class="content">
    <ul>
    <li><a href="index.html">Home</a></li>
    </ul>
    <ul>
    <li><a href="#diccionarios">6 Diccionarios</a>
    <ul>
    <li><a href="#diccionarios-de-python">Diccionarios de Python</a></li>
    <li><a href="#búsqueda-secuencial">Búsqueda secuencial</a></li>
    <li><a href="#búsqueda-secuencial-con-probabilidades-de-acceso-no-uniformes">Búsqueda secuencial con probabilidades de acceso no uniformes</a></li>
    <li><a href="#búsqueda-en-un-arreglo-ordenado-búsqueda-binaria">Búsqueda en un arreglo ordenado: Búsqueda Binaria</a></li>
    <li><a href="#árboles-de-búsqueda-binaria-abbs">Árboles de Búsqueda Binaria (ABBs)</a></li>
    <li><a href="#rotaciones-en-un-abb">Rotaciones en un ABB</a></li>
    <li><a href="#árboles-avl">Árboles AVL</a></li>
    <li><a href="#árboles-2-3">Árboles 2-3</a></li>
    <li><a href="#árboles-b-b-trees">Árboles B (<em>B-trees</em>)</a></li>
    <li><a href="#árboles-digitales">Árboles Digitales</a></li>
    <li><a href="#listas-saltadas-skip-lists">Listas Saltadas (<em>Skip Lists</em>)</a></li>
    <li><a href="#árboles-de-búsqueda-binaria-óptimos">Árboles de búsqueda binaria óptimos</a></li>
    <li><a href="#splay-trees">Splay Trees</a></li>
    <li><a href="#hashing">Hashing</a></li>
    <li><a href="#hashing-con-encadenamiento">Hashing con Encadenamiento</a></li>
    <li><a href="#hashing-con-direccionamiento-abierto">Hashing con Direccionamiento abierto</a></li>
    <li><a href="#linear-probing">Linear Probing</a></li>
    <li><a href="#hashing-doble">Hashing Doble</a></li>
    </ul></li>
    </ul>
  </div>
</div>


<section id="diccionarios" class="level1">
<h1>6 Diccionarios</h1>
<p>El TDA Diccionario es uno de los más usados en la práctica, y se conocen mucha formas distintas de implementarlo.</p>
<p>Un Diccionario es un conjunto de&nbsp;<span class="math inline">n</span> elementos, cada uno de los cuales tiene un campo que permite identificarlo de manera única (ese campo se llama su <em>llave primaria</em>), sobre el cual están definidas las operaciones de buscar, insertar, eliminar, y ocasionalmente otras que definiremos más adelante. Más precisamente, si&nbsp;<span class="math inline">d</span> es un diccionario, existirán las operaciones:</p>
<ul>
<li><code>r=d.search(x)</code>: buscar el elemento de llave <code>x</code>, retornar un resultado que permita ubicarlo, o <code>None</code> si no está</li>
<li><code>d.insert(x)</code>: insertar un elemento de llave <code>x</code>, evitando crear una llave duplicada</li>
<li><code>d.delete(x)</code>: eliminar el elemento de llave <code>x</code>, el cual debe estar en el diccionario</li>
</ul>
<section id="diccionarios-de-python" class="level2">
<h2>Diccionarios de Python</h2>
<p>El lenguaje Python posee un tipo <code>dict</code> que implementa la funcionalidad de diccionarios que hemos descrito (más operaciones adicionales). En un diccionario se busca por una llave y se obtiene un valor asociado.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>distancia <span class="op">=</span> {<span class="st">&#39;Valparaíso&#39;</span>:<span class="dv">102</span>, <span class="st">&#39;Concepción&#39;</span>: <span class="dv">433</span>, <span class="st">&#39;Arica&#39;</span>: <span class="dv">1664</span>, <span class="st">&#39;Puerto Montt&#39;</span>: <span class="dv">912</span>, <span class="st">&#39;Rancagua&#39;</span>: <span class="dv">80</span>}</span></code></pre></div>
<p>La forma de buscar es simplemente usando la llave como subíndice:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(distancia[<span class="st">&#39;Arica&#39;</span>])</span></code></pre></div>
<pre><code>1664</code></pre>
<p>Y la forma de agregar una nueva llave es asignándole un valor:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>distancia[<span class="st">&#39;Talca&#39;</span>]<span class="op">=</span><span class="dv">237</span></span></code></pre></div>
<p>Al buscar una llave inexistente se produce una excepción:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(distancia[<span class="st">&#39;La Serena&#39;</span>])</span></code></pre></div>
<pre><code>---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-14-0078e5a2585d&gt; in &lt;module&gt;
----&gt; 1 print(distancia[&#39;La Serena&#39;])


KeyError: &#39;La Serena&#39;</code></pre>
<p>Pero hay una forma de buscar sin que dé un error, sino que retorne <code>None</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(distancia.get(<span class="st">&#39;Rancagua&#39;</span>), distancia.get(<span class="st">&#39;La Serena&#39;</span>))</span></code></pre></div>
<pre><code>80 None</code></pre>
<p>Para eliminar un dato, se usa <code>pop</code> (lo elimina y retorna su valor):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>distancia.pop(<span class="st">&#39;Rancagua&#39;</span>)</span></code></pre></div>
<pre><code>80</code></pre>
<p>Aparte de esto, hay muchas otras operaciones que permiten obtener la lista de todas las llaves, etc.</p>
<p>Dado que en Python ya existe una implementación de diccionarios, ¿por qué querríamos estudiar nosotros cómo implementarlos?</p>
<p>La respuesta está en que, si nosotros controlamos todos los detalles de una implementación, sabremos exactamente cuan eficiente es, y para qué tipo de aplicaciones es más apropiada. Lo último es particularmente importante, porque no hay ninguna implementación de diccionarios que sea uniformemente mejor que las otras para todas las aplicaciones.</p>
<p>Estudiaremos entonces cómo se puede implementar un diccionario, comenzando por las estrategias más sencillas, y avanzando hacia enfoques más sofisticados.</p>
<p>En nuestros ejemplos supondremos que solo almacenamos la llave, pero en la práctica siempre habrá información adicional asociada a cada llave. También por simplicidad a menudo usaremos llaves numéricas, aunque en la práctica es más frecuente que las llaves sean strings.</p>
</section>
<section id="búsqueda-secuencial" class="level2">
<h2>Búsqueda secuencial</h2>
<p>La manera más simple de implementar un diccionario es con una lista desordenada de llaves, en la cual se hace búsqueda secuencial. La inserción es especialmente eficiente si obviamos chequear por duplicados, y la eliminación es eficiente una vez que sabemos dónde está la llave.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Lista_secuencial:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, size<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a<span class="op">=</span>np.zeros(size,dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n<span class="op">=</span><span class="dv">0</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.n<span class="op">&lt;</span><span class="bu">len</span>(<span class="va">self</span>.a)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a[<span class="va">self</span>.n]<span class="op">=</span>x</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="va">self</span>.n):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.a[k]<span class="op">==</span>x:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> k</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete(<span class="va">self</span>,x):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span><span class="va">self</span>.search(x)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a[k]<span class="op">=</span><span class="va">self</span>.a[<span class="va">self</span>.n<span class="op">-</span><span class="dv">1</span>] <span class="co"># movemos el último al lugar vacante</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n<span class="op">-=</span><span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>d<span class="op">=</span>Lista_secuencial()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>d.insert(<span class="dv">30</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>d.insert(<span class="dv">10</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>d.insert(<span class="dv">25</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(d.search(<span class="dv">10</span>))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(d.search(<span class="dv">80</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>d.delete(<span class="dv">30</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(d.search(<span class="dv">30</span>))</span></code></pre></div>
<pre><code>1
None
None</code></pre>
<p>La búsqueda secuencial también se puede implementar con una lista enlazada, en cuyo caso será más simple insertar al inicio.</p>
<p>En cualquier caso, la búsqueda demora tiempo&nbsp;<span class="math inline">\Theta(n)</span>. Para estimar el costo promedio, suponemos que todos los elementos son igualmente probables de ser accesados y que el costo de buscar a un elemento que es el&nbsp;<span class="math inline">k</span>-ésimo de la lista es&nbsp;<span class="math inline">k</span>. Por lo tanto, el costo promedio es</p>
<p><span class="math display">
\frac{1}{n}\sum_{1\le k \le n} k = \frac{n+1}{2}=\Theta(n)
</span></p>
<p>Por lo tanto, este tipo de implementación solo será adecuada para conjuntos muy pequeños.</p>
</section>
<section id="búsqueda-secuencial-con-probabilidades-de-acceso-no-uniformes" class="level2">
<h2>Búsqueda secuencial con probabilidades de acceso no uniformes</h2>
<p>En la práctica, es muy raro que las probabilidades de acceso a los elementos sean uniformes. Con frecuencia hay algunos elementos que son mucho más populares que otros, y empíricamente a menudo se observan distribuciones de tipo “ley de potencias,” con probabilidades de tipo</p>
<p><span class="math display">
p_k \propto \frac{1}{k^{\alpha}}
</span></p>
<p>para algún&nbsp;<span class="math inline">\alpha</span>. Para el caso&nbsp;<span class="math inline">\alpha=1</span> esto se llama Ley de Zipf.</p>
<p>Si un conjunto de datos tiene elementos con probabilidades de acceso diferentes, entonces para la búsqueda secuencial el orden en que estén los elementos en la lista hace una diferencia.</p>
<section id="caso-1.-probabilidades-conocidas" class="level3">
<h3>Caso 1. Probabilidades conocidas</h3>
<p>Si las probabilidades de acceso son conocidas, es fácil ver que el orden óptimo es en orden decreciente de probabilidad.</p>
<p>Más precisamente, si los elementos son&nbsp;<span class="math inline">X_1, X_2,\ldots,X_n</span> con probabilidades de acceso&nbsp;<span class="math inline">p_1,p_2,\ldots,p_n</span> respectivamente, y si están ordenados de modo que&nbsp;<span class="math inline">p_1\ge p_2\ge p_3\ge \cdots</span>, entonces el costo esperado de búsqueda óptimo es</p>
<p><span class="math display">
C_{OPT} = \sum_{1\le k\le n} k p_k
</span></p>
<p>Tomemos como ejemplo el capítulo 1 de “El Quijote” (en minúsculas y sin puntuación para simplificar su proceso), cuyo texto está en el archivo <code>cap1.txt</code>:</p>
<pre><code>en un lugar de la mancha de cuyo nombre no quiero acordarme no ha mucho
tiempo que vivía un hidalgo de los de lanza en astillero adarga antigua
...
peregrino y significativo como todos los demás que a él y a sus cosas
había puesto</code></pre>
<section id="acceso-al-archivo-desde-colab" class="level4">
<h4>Acceso al archivo desde Colab</h4>
<p>Si este notebook está usándose en Google Colab, el archivo se debe almacenar en la carpeta <code>Colab Notebooks</code> de Google Drive, y para que el código en Python pueda tener acceso a él se debe quitar los comentarios y ejecutar la siguiente celda:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">#from google.colab import drive</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">#drive.mount(&quot;/content/gdrive&quot;)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">#%cd &quot;/content/gdrive/My Drive/Colab Notebooks/&quot;</span></span></code></pre></div>
<p>El costo óptimo para un archivo dado se puede obtener con el siguiente código en Python, en el cual hacemos uso de los diccionarios provistos por el lenguaje:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_costo_optimo(archivo): <span class="co"># lee el archivo, calcula frecuencias en orden descendente</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    f<span class="op">=</span><span class="bu">open</span>(archivo,<span class="st">&quot;r&quot;</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    texto<span class="op">=</span>f.read()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    palabras<span class="op">=</span>texto.split()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    frec<span class="op">=</span>{}</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> palabras:</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        frec[x] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> <span class="kw">not</span> x <span class="kw">in</span> frec <span class="cf">else</span> frec[x]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    lista<span class="op">=</span>[]</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    Copt<span class="op">=</span><span class="dv">0</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    costo<span class="op">=</span><span class="dv">0</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">sorted</span>(frec,key<span class="op">=</span>frec.get,reverse<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        costo<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        Copt<span class="op">+=</span>costo<span class="op">*</span>frec[x]</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        lista.append((frec[x],x))</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    Copt<span class="op">/=</span><span class="bu">len</span>(palabras)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    f.close()</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (Copt,lista)</span></code></pre></div>
<p>Como resultado, mostramos el costo esperado de búsqueda en una lista ordenada de manera óptima (C_OPT) y las palabras más frecuentes:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(c,L)<span class="op">=</span>calcula_costo_optimo(<span class="st">&quot;cap1.txt&quot;</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;C_OPT=</span><span class="sc">{:6.2f}</span><span class="ch">\n</span><span class="st">&#39;</span>.<span class="bu">format</span>(c))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">9</span>):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(L[k])</span></code></pre></div>
<pre><code>C_OPT=157.81

(120, &#39;de&#39;)
(105, &#39;y&#39;)
(88, &#39;que&#39;)
(44, &#39;a&#39;)
(40, &#39;el&#39;)
(38, &#39;en&#39;)
(35, &#39;su&#39;)
(33, &#39;la&#39;)
(30, &#39;se&#39;)</code></pre>
</section>
</section>
<section id="caso-2-probabilidades-desconocidas" class="level3">
<h3>Caso 2: Probabilidades desconocidas</h3>
<p>Cuando las probabilidades son desconocidas, existen estrategias adaptativas, que van reordenando la lista dinámicamente a medida que los elementos son buscados, de modo de tratar de aproximar el orden óptimo. Hay dos técnicas que dan buenos resultados: “traspose” (TR) y “move to front” (MTF).</p>
</section>
<section id="transpose" class="level3">
<h3>Transpose</h3>
<p>Esta técnica consiste en que cada vez que un elemento es accesado, se le mueve un lugar más adelante en la lista (a menos que ya esté en el primer lugar). Esto se puede implementar ya sea en un arreglo o en una lista enlazada. En la siguiente implementación usaremos una lista enlazada con cabecera.</p>
<p>Si un elemento no se encuentra, simulamos como si hubiese estado al final de la lista. Para esto, mantendremos siempre disponible un nodo extra al final de la lista, en donde almacenaremos tentativamente la llave de búsqueda. Si finalmente se encuentra en ese nodo, se le incorpora a la lista y se crea un nuevo nodo extra.</p>
<p>Para contabilizar el costo, el método <code>search</code> retorna el número de comparaciones de llaves que se hizo en la búsqueda.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NodoLista:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,info,sgte<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sgte<span class="op">=</span>sgte</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Lista_TR:</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.extra<span class="op">=</span>NodoLista(<span class="dv">0</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cabecera<span class="op">=</span>NodoLista(<span class="dv">0</span>,<span class="va">self</span>.extra)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x): <span class="co"># busca x (si no está lo inserta al final) y lo adelanta un lugar</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># retorna el costo de búsqueda</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.extra.info<span class="op">=</span>x <span class="co"># agregamos x al final, en caso que no estuviera antes</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.cabecera</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        q<span class="op">=</span>p.sgte</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># k cuenta el número de comparaciones de llaves</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> q.info<span class="op">==</span>x: <span class="co"># x ya está primero en la lista, no hacemos nada</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>            k<span class="op">=</span><span class="dv">1</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># buscamos del segundo en adelante</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>            r<span class="op">=</span>q.sgte</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            k<span class="op">=</span><span class="dv">2</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> r.info<span class="op">!=</span>x:</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>                (p,q,r)<span class="op">=</span>(q,r,r.sgte)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>                k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># r apunta al elemento buscado, lo movemos un lugar hacia adelante</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>            (p.sgte,q.sgte,r.sgte)<span class="op">=</span>(r,r.sgte,q)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> q.sgte <span class="kw">is</span> <span class="va">None</span>: <span class="co"># se utilizó el nodo extra, agregamos uno nuevo</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.extra<span class="op">=</span>NodoLista(<span class="dv">0</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>            q.sgte<span class="op">=</span><span class="va">self</span>.extra</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> imprimir(<span class="va">self</span>):</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.cabecera.sgte</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;[&quot;</span>,end<span class="op">=</span><span class="st">&quot; &quot;</span>)</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> p <span class="kw">is</span> <span class="kw">not</span> <span class="va">self</span>.extra:</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(p.info,end<span class="op">=</span><span class="st">&quot; &quot;</span>)</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span>p.sgte</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;]&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test(Lista_adaptativa): <span class="co"># test interactivo</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">=</span>Lista_adaptativa()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="bu">input</span>(<span class="st">&quot;x=&quot;</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">==</span><span class="st">&quot;fin&quot;</span>:</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;costo=&quot;</span>,a.search(x),end<span class="op">=</span><span class="st">&quot; &quot;</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        a.imprimir()</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>test(Lista_TR)</span></code></pre></div>
<pre><code>x=hola
costo= 1 [ hola ]
x=chao
costo= 2 [ chao hola ]
x=casa
costo= 3 [ chao casa hola ]
x=hola
costo= 3 [ chao hola casa ]
x=hola
costo= 2 [ hola chao casa ]
x=hola
costo= 1 [ hola chao casa ]
x=gato
costo= 4 [ hola chao gato casa ]
x=fin</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> procesa(archivo,Lista_adaptativa): <span class="co"># lee el archivo y calcula costo promedio de búsqueda</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    f<span class="op">=</span><span class="bu">open</span>(archivo,<span class="st">&quot;r&quot;</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    texto<span class="op">=</span>f.read()</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    palabras<span class="op">=</span>texto.split()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    npalabras<span class="op">=</span><span class="dv">0</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    costo_acum<span class="op">=</span><span class="dv">0</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    a<span class="op">=</span>Lista_adaptativa()</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> palabras:</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        costo_acum<span class="op">+=</span>a.search(x)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        npalabras<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Costo promedio de búsqueda= </span><span class="sc">{:6.2f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(costo_acum<span class="op">/</span>npalabras))</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    f.close()</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>procesa(<span class="st">&quot;cap1.txt&quot;</span>,Lista_TR)</span></code></pre></div>
<pre><code>Costo promedio de búsqueda= 208.74</code></pre>
</section>
<section id="move-to-front" class="level3">
<h3>Move-To-Front</h3>
<p>Esta técnica consiste en que cada vez que un elemento es accesado, se le mueve al primer lugar de la lista (a menos que ya esté en el primer lugar). Si un elemento no se encuentra, simulamos como si hubiese estado al final de la lista.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Lista_MTF:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.extra<span class="op">=</span>NodoLista(<span class="dv">0</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cabecera<span class="op">=</span>NodoLista(<span class="dv">0</span>,<span class="va">self</span>.extra)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x): <span class="co"># busca x (si no está lo inserta al final) y luego lo mueve al primer lugar</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># retorna el costo de búsqueda</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.extra.info<span class="op">=</span>x <span class="co"># agregamos x al final, en caso que no estuviera antes</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.cabecera</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        q<span class="op">=</span>p.sgte</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        k<span class="op">=</span><span class="dv">1</span> <span class="co"># cuenta el número de comparaciones de llaves</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q.info<span class="op">!=</span>x:</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>            (p,q)<span class="op">=</span>(q,q.sgte)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>            k<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> q.sgte <span class="kw">is</span> <span class="va">None</span>: <span class="co"># se utilizó el nodo extra, agregamos uno nuevo</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.extra<span class="op">=</span>NodoLista(<span class="dv">0</span>)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>            q.sgte<span class="op">=</span><span class="va">self</span>.extra</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">&gt;</span><span class="dv">1</span>:  <span class="co"># x no está primero, move to front</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>            (<span class="va">self</span>.cabecera.sgte,p.sgte,q.sgte)<span class="op">=</span>(q,q.sgte,<span class="va">self</span>.cabecera.sgte)         </span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> imprimir(<span class="va">self</span>):</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.cabecera.sgte</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;[&quot;</span>,end<span class="op">=</span><span class="st">&quot; &quot;</span>)</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> p <span class="kw">is</span> <span class="kw">not</span> <span class="va">self</span>.extra:</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(p.info,end<span class="op">=</span><span class="st">&quot; &quot;</span>)</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span>p.sgte</span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;]&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>test(Lista_MTF)</span></code></pre></div>
<pre><code>x=hola
costo= 1 [ hola ]
x=casa
costo= 2 [ casa hola ]
x=chao
costo= 3 [ chao casa hola ]
x=hola
costo= 3 [ hola chao casa ]
x=casa
costo= 3 [ casa hola chao ]
x=casa
costo= 1 [ casa hola chao ]
x=gato
costo= 4 [ gato casa hola chao ]
x=fin</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>procesa(<span class="st">&quot;cap1.txt&quot;</span>,Lista_MTF)</span></code></pre></div>
<pre><code>Costo promedio de búsqueda= 188.82</code></pre>
<p>En resumen, tenemos que para este texto en particular, el costo óptimo es 157.81, el costo promedio de TR es 208.74 y el de MTF es 188.82.</p>
<p>Si en lugar de considerar un caso se analiza matemáticamente el caso general, suponiendo que los accesos llegan independientemente siguiendo la distribución dada y que el algoritmo corre durante un tiempo que tiende a infinito, se puede demostrar que</p>
<p><span class="math display">
C_{OPT} \le C_{TR} \le C_{MTF} \le \frac{\pi}{2} C_{OPT}
</span></p>
</section>
</section>
<section id="búsqueda-en-un-arreglo-ordenado-búsqueda-binaria" class="level2">
<h2>Búsqueda en un arreglo ordenado: Búsqueda Binaria</h2>
<p>Ya hemos visto anteriormente que si los datos están en un arreglo ordenado, podemos hacer una búsqueda binaria, la que demora tiempo&nbsp;<span class="math inline">\lceil\log_2{(n+1)}\rceil=\Theta(\log{n})</span> en el peor caso.</p>
<p>Esto es bastante eficiente, pero tiene el problema que agregar o eliminar datos del arreglo toma tiempo&nbsp;<span class="math inline">\Theta(n)</span> en el peor caso, por la necesidad de mantener el conjunto ordenado y compacto. Un objetivo que perseguiremos en el resto de este capítulo es tratar de encontrar estructuras de datos que nos permitan buscar de manera tan eficiente como la búsqueda binaria, junto con inserciones y eliminaciones igualmente eficientes.</p>
<p>Pero antes de avanzar en esa dirección, consideremos la pregunta de si es posible buscar má rápido que la búsqueda binaria en el peor caso.</p>
<section id="cota-inferior-para-la-búsqueda-por-comparaciones" class="level3">
<h3>Cota inferior para la búsqueda por comparaciones</h3>
<p>Consideremos el problema de buscar una llave&nbsp;<span class="math inline">x</span> en un conjunto de tamaño 4, digamos&nbsp;<span class="math inline">\{a,b,c,d\}</span>, con&nbsp;<span class="math inline">a&lt;b&lt;c&lt;d</span>. La siguiente figura ilustra una manera como podría hacerse esa búsqueda:</p>
<figure>
<img src="recursos/decision-tree.png" alt="decision-tree" /><figcaption aria-hidden="true">decision-tree</figcaption>
</figure>
<p>Este tipo de figura se llama un <em>árbol de decisión</em>, y en él los rombos representan preguntas y los rectángulos, las salidas (outputs) del algoritmo.</p>
<p>Este árbol de decisión es uno entre la infinidad de árboles que podrían resolver el problema de la búsqueda. Lo importante que hay que observar es que todo algoritmo que funcione mediante comparaciones binarias (comparaciones con salidas “Sí/No”) se puede representar por un árbol de decisión.</p>
<p>En este tipo de árbol tenemos que:</p>
<ul>
<li>La altura representa el número de comparaciones que hace el algoritmo en el peor caso, y</li>
<li>El número de hojas (cajas rectangulares) debe ser mayor o igual al número de respuestas posibles que debe ser capaz de emitir el algoritmo.</li>
</ul>
<p>Recordemos que si&nbsp;<span class="math inline">N</span> es el número de hojas y&nbsp;<span class="math inline">h</span> la altura, siempre se tiene&nbsp;<span class="math inline">N\le 2^h</span>, de donde se deduce que <span class="math inline">h \ge \lceil\log_2{N}\rceil</span> (porque la altura es un número entero), y en consecuencia, tenemos que</p>
<p><span class="math display">
\text{Peor caso} \ge \lceil\log_2{(\text{número de respuestas distintas})}\rceil
</span></p>
<p>Para el caso de la búsqueda binaria, tenemos que&nbsp;<span class="math inline">N=n+1</span>, porque el algoritmo de búsqueda debe poder identificar a cada uno de los&nbsp;<span class="math inline">n</span> elementos, más la respuesta negativa cuando el elemento buscado no está. En consecuencia:</p>
<p><strong>Todo algoritmo que busque en un conjunto de tamaño <span class="math inline">n</span> mediante comparaciones binarias debe hacer al menos <span class="math inline">\lceil\log_2{(n+1)}\rceil</span> comparaciones en el peor caso.</strong></p>
<p>Por lo tanto, la búsqueda binaria es óptima.</p>
</section>
</section>
<section id="árboles-de-búsqueda-binaria-abbs" class="level2">
<h2>Árboles de Búsqueda Binaria (ABBs)</h2>
<p>Un <em>árbol de búsqueda binaria</em> (<em>ABB</em>) es un árbol binario en que todos sus nodos internos cumplen la siguiente propiedad: Si la llave almacenada en el nodo es&nbsp;<span class="math inline">x</span>, entonces todas las llaves en su subárbol izquierdo son menores que&nbsp;<span class="math inline">x</span>, y las llaves en el subárbol derecho son mayores que&nbsp;<span class="math inline">x</span>.</p>
<figure>
<img src="recursos/esquema-ABB2.png" alt="esquema-ABB2" /><figcaption aria-hidden="true">esquema-ABB2</figcaption>
</figure>
<p>Los ABBs permiten realizar de manera eficiente (en promedio) las operaciones de inserción y búsqueda.</p>
<section id="búsqueda-en-un-abb" class="level3">
<h3>Búsqueda en un ABB</h3>
<p>La búsqueda es similar a una búsqueda binaria (de ahí el nombre de estos árboles). Para buscar una llave&nbsp;<span class="math inline">x</span> se comienza en la raíz. Si&nbsp;<span class="math inline">x</span> se encuentra ahí, la búsqueda termina exitosamente. Si no está ahí, se continúa buscando en el subárbol izquierdo si&nbsp;<span class="math inline">x</span> es menor que la raíz, o en el subárbol derecho si&nbsp;<span class="math inline">x</span> es mayor que la raíz. Si se llega a una hoja (nodo externo), la búsqueda concluye infructuosamente.</p>
</section>
<section id="inserción-en-un-abb" class="level3">
<h3>Inserción en un ABB</h3>
<p>Para insertar una llave&nbsp;<span class="math inline">x</span> en un ABB, se realiza una búsqueda, que debe ser infructuosa, y la hoja en donde termina la búsqueda se reemplaza por un nodo interno conteniendo la llave&nbsp;<span class="math inline">x</span>, con dos nuevas hojas como hijos.</p>
<figure>
<img src="recursos/insercionABB.gif" alt="insercioABB" /><figcaption aria-hidden="true">insercioABB</figcaption>
</figure>
</section>
<section id="implementación-recursiva" class="level3">
<h3>Implementación recursiva</h3>
<p>Los algoritmos de un ABB se prestan de manera natural a ser programados de manera recursiva, especialmente con la representación explícita de los nodos externos:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x):</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">==</span><span class="va">self</span>.info:</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&lt;</span><span class="va">self</span>.info:</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.izq.search(x)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.der.search(x)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> x<span class="op">!=</span><span class="va">self</span>.info</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&lt;</span><span class="va">self</span>.info:</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Nodoi(<span class="va">self</span>.izq.insert(x),<span class="va">self</span>.info,<span class="va">self</span>.der)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Nodoi(<span class="va">self</span>.izq,<span class="va">self</span>.info,<span class="va">self</span>.der.insert(x))</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x):</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span><span class="va">self</span>.raiz.insert(x)</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x):</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.search(x)</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<p>Hemos incluído una función <code>__str__</code> para poder visualizar (de forma algo rudimentaria) el árbol construído.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>Arbol()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">42</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">77</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">50</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">10</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>((☐10☐)42((☐50☐)77☐))</code></pre>
<p>Para probar nuestra implementación, definiremos una función <code>test</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test(a,x):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x, <span class="st">&quot;está&quot;</span> <span class="cf">if</span> a.search(x) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="st">&quot;no está&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">50</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">90</span>)</span></code></pre></div>
<pre><code>50 está
90 no está</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">90</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">90</span>)</span></code></pre></div>
<pre><code>((☐10☐)42((☐50☐)77(☐90☐)))
90 está</code></pre>
</section>
<section id="implementación-no-recursiva" class="level3">
<h3>Implementación no recursiva</h3>
<p>Las operaciones de búsqueda e inserción en el árbol no necesitan programarse recursivamente, porque se pueden realizar en una sola pasada de arriba a abajo, sin necesidad de volver hacia arriba. En este caso, toda esa funcionalidad se implementa dentro de la clase <code>Arbol</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.raiz, Nodoe):</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.raiz<span class="op">=</span>Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.raiz</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">assert</span> x<span class="op">!=</span>p.info</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> x<span class="op">&lt;</span>p.info:</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">isinstance</span>(p.izq, Nodoe):</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>                    p.izq<span class="op">=</span>Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>                p<span class="op">=</span>p.izq</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co"># x&gt;p.info</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">isinstance</span>(p.der, Nodoe):</span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>                    p.der<span class="op">=</span>Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>                p<span class="op">=</span>p.der</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>,x):</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span><span class="va">self</span>.raiz</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> <span class="bu">isinstance</span>(p, Nodoe):</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> x<span class="op">==</span>p.info:</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> p</span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span>p.izq <span class="cf">if</span> x<span class="op">&lt;</span>p.info <span class="cf">else</span> p.der</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>Arbol()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">42</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">77</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">50</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">10</span>)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>((☐10☐)42((☐50☐)77☐))</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">50</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">90</span>)</span></code></pre></div>
<pre><code>50 está
90 no está</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">90</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>test(a,<span class="dv">90</span>)</span></code></pre></div>
<pre><code>((☐10☐)42((☐50☐)77(☐90☐)))
90 está</code></pre>
</section>
<section id="costo-de-búsqueda-en-un-abb" class="level3">
<h3>Costo de búsqueda en un ABB</h3>
<section id="peor-caso" class="level4">
<h4>Peor caso</h4>
<p>El peor caso para un árbol dado es la altura del árbol, y el peor árbol posible tiene altura&nbsp;<span class="math inline">n</span>. Por lo tanto, el costo de búsqueda en el peor caso es&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Lo anterior ocurre, por ejemplo, si los elementos se insertan en orden ascendente, o descendente, o en algún orden tipo “zig-zag.” Es muy improbable que esto ocurra por casualidad, pero sí puede suceder si los datos provienen de algún otro proceso en que resultan naturalmente ordenados, o bien porque la secuencia de inserciones es generada por un adversario malicioso que busca hacer que el algoritmo funcione de la manera más lenta posible.</p>
</section>
<section id="caso-promedio" class="level4">
<h4>Caso promedio</h4>
<p>Para analizar el costo esperado de búsqueda en un ABB con&nbsp;<span class="math inline">n</span> nodos, supondremos que en una inserción y en una búsqueda infructuosa, los&nbsp;<span class="math inline">n+1</span> nodos externos son igualmente probables como punto de destino de la búsqueda y de la inserción, y que en una búsqueda exitosa, los&nbsp;<span class="math inline">n</span> nodos internos son igualmente probables como punto de destino de la búsqueda.</p>
<p>Recordemos que anteriormente definimos el <em>largo de caminos internos</em> (<em>LCI</em>) como $ I_n=<em>{x}(,x) $, y el <em>largo de caminos externos</em> (<em>LCE</em>) como $ E_n=</em>{y}(,y) $, para los cuales se cumple que $ E_n=I_n+2n $.</p>
<p>Utilizaremos las notaciones&nbsp;<span class="math inline">C_n</span> y&nbsp;<span class="math inline">C&#39;_n</span> para el número esperado de comparaciones de llaves en una búsqueda exitosa e infructuosa, respectivamente. Entonces, tenemos que</p>
<p><span class="math display">
\begin{align}
C_n &amp;= 1 + \frac{I_n}{n}\\
C&#39;_n &amp;= \frac{E_n}{n+1}
\end{align}
</span></p>
<p>Reemplazando&nbsp;<span class="math inline">E_n=I_n+2n</span> en la fórmula para&nbsp;<span class="math inline">C_n</span>, tenemos que</p>
<p><span class="math display">
C_n=1+\frac{E_n-2n}{n}=\frac{E_n}{n}-1=\frac{n+1}{n}C&#39;_n-1
</span></p>
<p>Por lo tanto, tenemos la siguiente relación entre los costos esperados de búsqueda exitoso e infructuoso:</p>
<p><span class="math display">
C_n=\left( 1 +\frac{1}{n}\right) C&#39;_n - 1
</span></p>
<p>de modo que, cuando&nbsp;<span class="math inline">n \rightarrow \infty</span></p>
<p><span class="math display">
C_n \approx C&#39;_n-1
</span></p>
<p>Para poder completar este análisis necesitamos una segunda ecuación que vincule a estas incógnitas. Para esto, observemos que <em>el costo de buscar un elemento que acaba de ser insertado es exactamente 1 más que el costo de buscarlo infructuosamente antes de su inserción</em>. Por lo tanto, si consideramos y promediamos los costos de búsqueda de los elementos en orden de inserción, tenemos que</p>
<p><span class="math display">
C_n=\frac{(1+C&#39;_0)+(1+C&#39;_1)+\cdots+(1+C&#39;_{n-1})}{n}=1+\frac{1}{n}\sum_{0\le k \le n-1}C&#39;_k
</span></p>
<p>Multiplicando ambos lados por&nbsp;<span class="math inline">n</span>, tenemos</p>
<p><span class="math display">
nC_n=n+\sum_{0\le k \le n-1}C&#39;_k
</span></p>
<p>Sustituyendo&nbsp;<span class="math inline">n</span> por&nbsp;<span class="math inline">n+1</span> en esta ecuación, tenemos</p>
<p><span class="math display">
(n+1)C_{n+1}=n+1+\sum_{0\le k \le n}C&#39;_k
</span></p>
<p>Restando ambas ecuaciones, tenemos:</p>
<p><span class="math display">
(n+1)C_{n+1} - nC_n = 1+C&#39;_n
</span></p>
<p>La relación que habíamos obtenido antes entre&nbsp;<span class="math inline">C_c</span> y&nbsp;<span class="math inline">C&#39;_n</span> se puede reescribir como</p>
<p><span class="math display">
nC_n=(n+1)C&#39;_n-n
</span></p>
<p>Reemplazando en la ecuación anterior, obtenemos:</p>
<p><span class="math display">
(n+2)C&#39;_{n+1}-(n+1)-(n+1)C&#39;_n+n=1+C&#39;_n
</span></p>
<p>Lo que se simplifica a</p>
<p><span class="math display">
(n+2)(C&#39;_{n+1}-C&#39;_n)=2
</span></p>
<p>obteniéndose la ecuación de recurrencia</p>
<p><span class="math display">
\begin{align}
C&#39;_{n+1} &amp;= C&#39;_n+\frac{2}{n+2}\\
C&#39;_0 &amp;= 0
\end{align}
</span></p>
<p>Esta ecuación se puede resolver “desenrrollándola,” para obtener</p>
<p><span class="math display">
C&#39;_n=2\left(\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n+1}\right)
</span></p>
<p>Si definimos los <em>números armónicos</em> <span class="math inline">H_n=1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}</span>, podemos expresar la solución como</p>
<p><span class="math display">
C&#39;_n=2(H_{n+1}-1)
</span></p>
<p>Los números armónicos son muy cercanos al logaritmo natural. Se puede demostrar que</p>
<p><span class="math display">
\begin{align}
H_n &amp; \le 1+\int_1^n \frac{1}{x}dx = 1+\ln{n}\\
H_n &amp; \ge \int_1^{n+1} \frac{1}{x}dx = \ln{(n+1)}
\end{align}
</span></p>
<p>de donde obtenemos que</p>
<p><span class="math display">
\ln{(n+1)} \le H_n \le 1+\ln{n}
</span></p>
<p>Más precisamente, se puede demostrar que</p>
<p><span class="math display">
H_n = \ln{n} + \gamma + O\left(\frac{1}{n}\right)
</span></p>
<p>donde&nbsp;<span class="math inline">\gamma\approx 0.577\ldots</span> es la constante de Euler-Mascheroni.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pylab inline</span></code></pre></div>
<pre><code>Populating the interactive namespace from numpy and matplotlib</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>H<span class="op">=</span>np.zeros(<span class="dv">100</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">101</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>H[<span class="dv">0</span>]<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">100</span>):</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    H[k]<span class="op">=</span>H[k<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span><span class="op">/</span>(k<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>plt.plot(n,H,label<span class="op">=</span><span class="st">&#39;$H_n$&#39;</span>)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>plt.plot(n,log(n), label<span class="op">=</span><span class="st">&#39;$\ln</span><span class="sc">{n}</span><span class="st">$&#39;</span>)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>leg<span class="op">=</span>plt.legend(loc<span class="op">=</span><span class="st">&#39;best&#39;</span>)</span></code></pre></div>
<figure>
<img src="06_Diccionarios_files/06_Diccionarios_55_0.png" alt="png" /><figcaption aria-hidden="true">png</figcaption>
</figure>
<p>Por lo tanto, el costo esperado de búsqueda (exitosa o infructuosa) en un ABB es aproximadamente&nbsp;<span class="math inline">2H_n \approx 2\ln{n} \approx 1.386 \log_2{n}</span>, lo cual es solo&nbsp;<span class="math inline">38.6</span> por cierto peor que un árbol óptimo, cuyo costo de búsqueda es&nbsp;<span class="math inline">\log_2{n}</span>.</p>
<p>Se puede demostrar que la varianza también es logarítmica, por lo que en la práctica el tiempo de búsqueda debería ser cercano al promedio.</p>
<p>Sin embargo, este análisis supone que las inserciones llegan en orden aleatorio, lo cual no necesariamente se cumple en la vida real.</p>
</section>
</section>
<section id="eliminación-en-un-abb" class="level3">
<h3>Eliminación en un ABB</h3>
<p>La eliminación de una llave&nbsp;<span class="math inline">x</span> es sencilla de efectuar en algunos casos, pero el caso complicado es cuando la llave tiene dos hijos:</p>
<section id="eliminación-de-una-llave-sin-hijos" class="level4">
<h4>Eliminación de una llave sin hijos</h4>
<p>En este caso, el nodo interno que contiene a&nbsp;<span class="math inline">x</span> desaparece y en su lugar queda un nodo externo:</p>
<figure>
<img src="recursos/eliminacionABB1.gif" alt="eliminacionABB1" /><figcaption aria-hidden="true">eliminacionABB1</figcaption>
</figure>
</section>
<section id="eliminación-de-una-llave-con-1-hijo" class="level4">
<h4>Eliminación de una llave con 1 hijo</h4>
<p>En este caso, el padre de la llave&nbsp;<span class="math inline">x</span> pasa a apuntar al único hijo de&nbsp;<span class="math inline">x</span>:</p>
<figure>
<img src="recursos/eliminacionABB2.gif" alt="eliminacionABB2" /><figcaption aria-hidden="true">eliminacionABB2</figcaption>
</figure>
</section>
<section id="eliminación-de-una-llave-con-2-hijos" class="level4">
<h4>Eliminación de una llave con 2 hijos</h4>
<p>Si&nbsp;<span class="math inline">x</span> tiene 2 hijos, no podemos eliminarla directamente, pero sí podemos eliminar a la que la sigue en orden ascendente, digamos&nbsp;<span class="math inline">y</span>. Se puede demostrar que&nbsp;<span class="math inline">y</span> necesariamente es unos de los dos casos anteriores, de modo que es fácil de eliminar. Luego de concluído ese proceso, escribimos&nbsp;<span class="math inline">y</span> en lugar de&nbsp;<span class="math inline">x</span> en el campo <code>info</code> del nodo respectivo.</p>
<figure>
<img src="recursos/eliminacionABB3.gif" alt="eliminacionABB3" /><figcaption aria-hidden="true">eliminacionABB3</figcaption>
</figure>
<p>Por simetría, esto mismo podría haberse hecho con la llave que sigue a&nbsp;<span class="math inline">x</span> en orden descendente.</p>
<p>El análisis del costo esperado de búqueda que hicimos anteriormente es válido si solo hay inserciones. El análisis en el caso en que se incluyen eliminaciones es un un problema matemáticamente muy complicado, y sigue siendo un problema abierto. La evidencia experimental indica que se obtienen mejores resultados si se alterna o si se aleatoriza al elegir entre sucesor o el predecesor de&nbsp;<span class="math inline">x</span> en caso que haya que elegir.</p>
</section>
</section>
<section id="implementación-recursiva-de-la-eliminación" class="level3">
<h3>Implementación recursiva de la eliminación</h3>
<p>Por simplicidad, omitimos el código para la inserción y búsqueda, y en el caso de un nodo con 2 hijos, eliminamos siempre el sucesor. También ignoramos las eliminaciones de llaves que no están en el árbol.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> deletemin(<span class="va">self</span>): <span class="co"># Elimina llave mínima del árbol, retorna (llave_min,raiz_arbol_restante)</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.izq,Nodoe): <span class="co"># No hay hijo izquierdo</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">self</span>.info,<span class="va">self</span>.der)</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># hay hijo izquierdo</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>        (llave_min,izq_sin_min)<span class="op">=</span><span class="va">self</span>.izq.deletemin()</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (llave_min,Nodoi(izq_sin_min,<span class="va">self</span>.info,<span class="va">self</span>.der))</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete(<span class="va">self</span>,x):</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&lt;</span><span class="va">self</span>.info:</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Nodoi(<span class="va">self</span>.izq.delete(x),<span class="va">self</span>.info,<span class="va">self</span>.der)</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&gt;</span><span class="va">self</span>.info:</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Nodoi(<span class="va">self</span>.izq,<span class="va">self</span>.info,<span class="va">self</span>.der.delete(x))</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># x==self.info</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.izq,Nodoe): <span class="co"># No hay hijo izquierdo</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.der</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.der,Nodoe): <span class="co"># No hay hijo derecho</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>. izq</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hay hijo izquierdo y derecho</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>        (y,der_sin_min)<span class="op">=</span><span class="va">self</span>.der.deletemin()</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(Nodoi(<span class="va">self</span>.izq,y,der_sin_min))</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete(<span class="va">self</span>,x):</span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete(<span class="va">self</span>,x):</span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span><span class="va">self</span>.raiz.delete(x)</span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<p>Para probar este algoritmo utilizaremos el árbol que vimos en el capítulo 4:</p>
<figure>
<img src="recursos/ejemplo-ABB.png" alt="ejemplo-ABB" /><figcaption aria-hidden="true">ejemplo-ABB</figcaption>
</figure>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>Arbol(</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    Nodoi(</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>        Nodoi(</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">15</span>,Nodoe()),</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>            <span class="dv">20</span>,</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>            Nodoi(</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                Nodoi(Nodoe(),<span class="dv">30</span>,Nodoe()),</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>                <span class="dv">35</span>,</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>                Nodoe()</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        <span class="dv">42</span>,</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        Nodoi(</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>            Nodoi(</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>                Nodoi(</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>                    Nodoi(Nodoe(),<span class="dv">65</span>,Nodoe()),</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">72</span>,</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>                    Nodoi(Nodoe(),<span class="dv">81</span>,Nodoe())</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>                ),</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>                <span class="dv">90</span>,</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>                Nodoe()</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>            <span class="dv">95</span>,</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>            Nodoe()</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20((☐30☐)35☐))42((((☐65☐)72(☐81☐))90☐)95☐))</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">30</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))42((((☐65☐)72(☐81☐))90☐)95☐))</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">95</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))42(((☐65☐)72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">42</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))65((☐72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">44</span>) <span class="co"># 44 no está en el árbol</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))65((☐72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">20</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)35☐)65((☐72(☐81☐))90☐))</code></pre>
</section>
<section id="implementación-no-recursiva-de-la-eliminación" class="level3">
<h3>Implementación no recursiva de la eliminación</h3>
<p>Al programar la eliminación de esta manera, necesitamos modificar el nodo padre de&nbsp;<span class="math inline">x</span>. Para simplificar, asegurando que todo nodo tenga un padre, incluso la raíz, durante el proceso de eliminación simularemos que la raíz es hija derecha de un nodo con llave “<span class="math inline">-\infty</span>.”</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete(<span class="va">self</span>,x):</span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>        cabecera<span class="op">=</span>Nodoi(<span class="va">None</span>,<span class="op">-</span>math.inf,<span class="va">self</span>.raiz)</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span>cabecera <span class="co"># padre del candidato a ser eliminado</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>        q<span class="op">=</span>cabecera.der <span class="co"># el candidato</span></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> <span class="bu">isinstance</span>(q,Nodoe):</span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> x<span class="op">&lt;</span>q.info:</span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>                (p,q)<span class="op">=</span>(q,q.izq)</span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> x<span class="op">&gt;</span>q.info:</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>                (p,q)<span class="op">=</span>(q,q.der)</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co"># encontramos x</span></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">isinstance</span>(q.izq,Nodoe): <span class="co"># no hay hijo izquierdo</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>                    r<span class="op">=</span>q.der</span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> <span class="bu">isinstance</span>(q.der,Nodoe): <span class="co"># no hay hijo derecho</span></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>                    r<span class="op">=</span>q.izq</span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>: <span class="co"># hay 2 hijos, eliminamos el mínimo del árbol derecho y lo movemos a q</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">=</span>q.der</span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="bu">isinstance</span>(s.izq,Nodoe): <span class="co"># encontramos el mín de inmediato</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a>                        q.info<span class="op">=</span>s.info</span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>                        q.der<span class="op">=</span>s.der</span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>: <span class="co"># el mín está más abajo</span></span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>                        t<span class="op">=</span>s.izq <span class="co"># s es el padre del candidato a min, t es el candidato</span></span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">while</span> <span class="kw">not</span> <span class="bu">isinstance</span>(t.izq,Nodoe): <span class="co"># mientras no encontremos el final de la rama izquierda</span></span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a>                            (s,t)<span class="op">=</span>(t,t.izq)</span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a>                        q.info<span class="op">=</span>t.info</span>
<span id="cb64-46"><a href="#cb64-46" aria-hidden="true" tabindex="-1"></a>                        s.izq<span class="op">=</span>t.der</span>
<span id="cb64-47"><a href="#cb64-47" aria-hidden="true" tabindex="-1"></a>                    r<span class="op">=</span>q</span>
<span id="cb64-48"><a href="#cb64-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x<span class="op">&lt;</span>p.info:</span>
<span id="cb64-49"><a href="#cb64-49" aria-hidden="true" tabindex="-1"></a>                    p.izq<span class="op">=</span>r</span>
<span id="cb64-50"><a href="#cb64-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb64-51"><a href="#cb64-51" aria-hidden="true" tabindex="-1"></a>                    p.der<span class="op">=</span>r</span>
<span id="cb64-52"><a href="#cb64-52" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.raiz<span class="op">=</span>cabecera.der</span>
<span id="cb64-53"><a href="#cb64-53" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span>        </span>
<span id="cb64-54"><a href="#cb64-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># si llegamos acá, x no estaba, no hacemos nada</span></span>
<span id="cb64-55"><a href="#cb64-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb64-56"><a href="#cb64-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb64-57"><a href="#cb64-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>Arbol(</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    Nodoi(</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        Nodoi(</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">15</span>,Nodoe()),</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>            <span class="dv">20</span>,</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>            Nodoi(</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>                Nodoi(Nodoe(),<span class="dv">30</span>,Nodoe()),</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>                <span class="dv">35</span>,</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>                Nodoe()</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>        <span class="dv">42</span>,</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>        Nodoi(</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>            Nodoi(</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>                Nodoi(</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>                    Nodoi(Nodoe(),<span class="dv">65</span>,Nodoe()),</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">72</span>,</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>                    Nodoi(Nodoe(),<span class="dv">81</span>,Nodoe())</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>                ),</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>                <span class="dv">90</span>,</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>                Nodoe()</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>            <span class="dv">95</span>,</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>            Nodoe()</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20((☐30☐)35☐))42((((☐65☐)72(☐81☐))90☐)95☐))</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">30</span>)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))42((((☐65☐)72(☐81☐))90☐)95☐))</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">95</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))42(((☐65☐)72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">42</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))65((☐72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">44</span>) <span class="co"># 44 no está en el árbol</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)20(☐35☐))65((☐72(☐81☐))90☐))</code></pre>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>a.delete(<span class="dv">20</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(((☐15☐)35☐)65((☐72(☐81☐))90☐))</code></pre>
</section>
</section>
<section id="rotaciones-en-un-abb" class="level2">
<h2>Rotaciones en un ABB</h2>
<p>Una operación que es la base de muchos algoritmos es la <em>rotación</em> (o rotación simple, para diferenciarla de la rotación doble, que veremos más adelante).</p>
<p>Una rotación entre los nodos&nbsp;<span class="math inline">b</span> y&nbsp;<span class="math inline">d</span> es la siguiente transformación:</p>
<figure>
<img src="recursos/rotacion-simple.png" alt="rotacion-simple" /><figcaption aria-hidden="true">rotacion-simple</figcaption>
</figure>
<p>Como lo sugiere la figura, por simetría esta operación también se puede hacer en la dirección inversa.</p>
<p>Esta operación tiene costo constante, porque solo requiere modificar tres punteros, y preserva el orden de izquierda a derecha que caracteriza a un ABB. Su efecto es que&nbsp;<span class="math inline">A</span> y&nbsp;<span class="math inline">b</span> suben un nivel, mientras que&nbsp;<span class="math inline">d</span> y&nbsp;<span class="math inline">E</span> bajan un nivel.</p>
<section id="aplicación-inserción-en-la-raíz" class="level3">
<h3>Aplicación: Inserción en la raíz</h3>
<p>El método estándar de inserción en un ABB es inserción en las hojas. Veremos a continuación que existe un método alternativo, que deja al nuevo elemento como raíz del árbol.</p>
<p>El método consiste en insertar el nuevo elemento de la manera usual, y luego hacer una secuencia de rotaciones que vayan haciéndolo ascender, hasta que llegue a estar en la raíz.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> right_rotation(<span class="va">self</span>):</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(Nodoi(<span class="va">self</span>.izq.izq,</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.izq.info,</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>                     Nodoi(<span class="va">self</span>.izq.der,<span class="va">self</span>.info,<span class="va">self</span>.der)))   </span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> left_rotation(<span class="va">self</span>):</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(Nodoi(Nodoi(<span class="va">self</span>.izq,<span class="va">self</span>.info,<span class="va">self</span>.der.izq),</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.der.info,</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.der.der))</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> root_insert(<span class="va">self</span>,x):</span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> x<span class="op">!=</span><span class="va">self</span>.info</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&lt;</span><span class="va">self</span>.info:</span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.izq<span class="op">=</span><span class="va">self</span>.izq.root_insert(x) <span class="co"># x queda como raíz del hijo izquierdo</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.right_rotation() <span class="co"># la rotación deja a x como raíz</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.der<span class="op">=</span><span class="va">self</span>.der.root_insert(x) <span class="co"># x queda como raíz del hijo derecho</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.left_rotation() <span class="co"># la rotación deja a x como raíz</span></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb78-30"><a href="#cb78-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> root_insert(<span class="va">self</span>,x):</span>
<span id="cb78-31"><a href="#cb78-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb78-32"><a href="#cb78-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb78-33"><a href="#cb78-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb78-34"><a href="#cb78-34" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb78-35"><a href="#cb78-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-36"><a href="#cb78-36" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb78-37"><a href="#cb78-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb78-38"><a href="#cb78-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb78-39"><a href="#cb78-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb78-40"><a href="#cb78-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> root_insert(<span class="va">self</span>,x):</span>
<span id="cb78-41"><a href="#cb78-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span><span class="va">self</span>.raiz.root_insert(x)</span>
<span id="cb78-42"><a href="#cb78-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb78-43"><a href="#cb78-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb78-44"><a href="#cb78-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>Arbol()</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>a.root_insert(<span class="dv">10</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>a.root_insert(<span class="dv">20</span>)</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>a.root_insert(<span class="dv">30</span>)</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>a.root_insert(<span class="dv">25</span>)</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>a.root_insert(<span class="dv">15</span>)</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(☐10☐)
((☐10☐)20☐)
(((☐10☐)20☐)30☐)
(((☐10☐)20☐)25(☐30☐))
((☐10☐)15((☐20☐)25(☐30☐)))</code></pre>
</section>
<section id="aplicación-árboles-cartesianos-y-treaps" class="level3">
<h3>Aplicación: Árboles cartesianos y “Treaps”</h3>
<p>Un <em>árbol cartesiano</em> es un árbol binario en que cada nodo interno contiene un par ordenado&nbsp;<span class="math inline">(x,y)</span>, tal que:</p>
<ul>
<li>Si se consideran las coordenadas <span class="math inline">x</span>, el árbol es un ABB</li>
<li>Si se consideran las coordenadas <span class="math inline">y</span>, el árbol es un árbol de prioridad</li>
</ul>
<p>La siguiente figura muestra a un árbol cartesiano en que la máxima prioridad corresponde al valor mínimo de&nbsp;<span class="math inline">y</span>:</p>
<figure>
<img src="recursos/cartesian-tree.png" alt="cartesian-tree" /><figcaption aria-hidden="true">cartesian-tree</figcaption>
</figure>
<p>Intuitivamente, podemos imaginar que la prioridad&nbsp;<span class="math inline">y</span> corresponde a la hora en que la llave&nbsp;<span class="math inline">x</span> ingresó al árbol. Esto explica que la raíz tenga el valor mínimo de&nbsp;<span class="math inline">y</span>, y que estos valores vayan creciendo a medida que descendemos en el árbol.</p>
<p>Sin embargo, <em>no estamos obligados a insertar las llaves en orden cronológico</em>. En efecto, veremos que un nuevo par&nbsp;<span class="math inline">(x,y)</span> se puede insertar en cualquier momento, aunque su&nbsp;<span class="math inline">y</span> no sea mayor que los de los nodos que ya están en el árbol..</p>
<p>Para insertar un nuevo par ordenado en un árbol cartesiano, primero efectuamos una inserción como si fuera un ABB, con lo cual el nuevo nodo cumple con las restricciones “izquierda-derecha” en su coordenada&nbsp;<span class="math inline">x</span>, pero posiblemente no con las restricciones de prioridad “arriba-abajo” de la coordenada&nbsp;<span class="math inline">y</span>. Para corregir esto último, a continuación, hacemos una serie de rotaciones hasta conseguir que el nuevo nodo cumpla con las restricciones de prioridad.</p>
<p>También es posible eliminar un nodo dado de un árbol cartesiano. Como al eliminar un nodo sus dos árboles hijos quedan “huérfanos,” es necesario fusionarlos en uno solo. Para esto, elegimos a la raíz de mejor prioridad para que quede como raíz del árbol resultante. De los tres subárboles restantes, uno va a un lado de la nueva raíz, y los otros dos deben fusionarse recursivamente.</p>
<p>Una vez que tenemos una implementación de árboles cartesianos, podemos utilizarla para obtener un nuevo tipo de diccionario, llamado un <em>Treap</em> (mezcla de “tree” y de “heap”), que posee las mismas características de desempeño promedio que un ABB, pero que es inmune a que las llaves lleguen ordenadas, o a que un adversario le entregue la secuencia de inserciones en un orden malicioso. Para esto, dado una nueva llave&nbsp;<span class="math inline">x</span> para insertar, generamos una prioridad&nbsp;<span class="math inline">y</span> <em>al azar</em>, e insertamos el par&nbsp;<span class="math inline">(x,y)</span> resultante. El efecto neto es equivalente a si las llaves hubieran llegado en un orden aleatorio.</p>
</section>
</section>
<section id="árboles-avl" class="level2">
<h2>Árboles AVL</h2>
<p>Veremos a continuación que es posible implementar diccionarios en que los costos de búsqueda, inserción y eliminación son garantizadamente&nbsp;<span class="math inline">O(\log{n})</span> <em>en el peor caso</em>.</p>
<p>Hay muchas maneras de conseguir esto a través de modificaciones del algoritmo básico de los ABBs, y hablamos en general de <em>árboles balanceados</em> para referirnos a este tipo de diccionarios.</p>
<p>Comenzaremos viendo el más antiguo de estos algoritmos, inventado por Adelson-Velskii y Landis y conocido por sus iniciales como <em>árboles AVL</em>.</p>
<p>Si queremos garantizar un costo de búsqueda logarítmico, lo ideal sería poder construir árboles perfectamente balanceados, en que siempre los elementos se repartieran en partes iguales a ambos lados de la raíz, y en que por lo tanto las alturas a ambos lados también fueran idénticas. Pero eso no es posible por varias razones. Por una parte, porque el costo de insertar un nuevo elemento en ese tipo de árbol sería muy grande en el peor caso, pero también porque a medida que bajamos en en árbol, a menos que el número de llaves sea exactamente uno menos que una potencia de&nbsp;<span class="math inline">2</span>, necesariamente terminaremos encontrando subárboles de tamaño&nbsp;<span class="math inline">2</span>, en los cuales a un lado hay un árbol de altura&nbsp;<span class="math inline">1</span>, y al otro lado un árbol de altura&nbsp;<span class="math inline">0</span>.</p>
<p>Por lo tanto, es necesario relajar un poco la exigencia, para acomodar a ese tipo de subárboles.</p>
<p>Los árboles AVL se definen como ABBs en que todos sus nodos internos cumplen además una condición de <em>altura balanceada</em>, que consiste en que sus subárboles hijos pueden tener alturas diferentes, pero la diferencia de sus alturas no puede ser mayor que 1.</p>
<figure>
<img src="recursos/condicion-AVL.png" alt="condicion-AVL" /><figcaption aria-hidden="true">condicion-AVL</figcaption>
</figure>
<p>Más precisamente, si la función&nbsp;<span class="math inline">h(T)</span> es la altura del árbol&nbsp;<span class="math inline">T</span>, para cada nodo interno sus subárboles hijos, digamos&nbsp;<span class="math inline">A</span> y&nbsp;<span class="math inline">B</span>, deben cumplir que&nbsp;<span class="math inline">|h(A)-h(B)|\le 1</span>.</p>
<p>El siguiente ejemplo muestra un árbol en que en cada nodo (interno o externo) se ha anotado la altura del subárbol que lo tiene como raíz. Este árbol cumple la condición AVL en todos sus nodos, excepto en el que aparece marcado con asterisco, cuyos hijos tienen diferencia de altura 2, y por lo tanto el árbol no es AVL.</p>
<figure>
<img src="recursos/ejemplo-no-AVL.png" alt="ejemplo-no-AVL" /><figcaption aria-hidden="true">ejemplo-no-AVL</figcaption>
</figure>
<p>En cambio, este otro árbol, muy similar, sí cumple la condición en todos sus nodos, y es por lo tanto un árbol AVL.</p>
<figure>
<img src="recursos/ejemplo-AVL.png" alt="ejemplo-AVL" /><figcaption aria-hidden="true">ejemplo-AVL</figcaption>
</figure>
<section id="chequeando-si-un-árbol-es-avl" class="level3">
<h3>Chequeando si un árbol es AVL</h3>
<p>Para determinar si un árbol es AVL, debemos calcular la altura de cada subárbol y comparar las alturas de todos los subárboles “hermanos” para ver si su diferencia excede o no 1. La siguiente implementación lo hace, pero veremos que de una manera ineficiente:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> altura(<span class="va">self</span>):</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">+</span><span class="bu">max</span>(<span class="va">self</span>.izq.altura(),<span class="va">self</span>.der.altura())</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> es_AVL(<span class="va">self</span>):</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">abs</span>(<span class="va">self</span>.izq.altura()<span class="op">-</span><span class="va">self</span>.der.altura())<span class="op">&lt;=</span><span class="dv">1</span> <span class="op">\</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>                <span class="kw">and</span> <span class="va">self</span>.izq.es_AVL() <span class="kw">and</span> <span class="va">self</span>.der.es_AVL()</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> altura(<span class="va">self</span>):</span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> es_AVL(<span class="va">self</span>):</span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Arbol:</span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> es_AVL(<span class="va">self</span>):</span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.es_AVL()</span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>a1<span class="op">=</span>Arbol(Nodoi(Nodoi(Nodoe(),<span class="dv">1</span>,Nodoe()),</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>            <span class="dv">2</span>,</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">3</span>,Nodoi(Nodoe(),<span class="dv">4</span>,Nodoe()))))</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a1)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a1.es_AVL())</span></code></pre></div>
<pre><code>((☐1☐)2(☐3(☐4☐)))
True</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>a2<span class="op">=</span>Arbol(Nodoi(Nodoi(Nodoe(),<span class="dv">1</span>,Nodoe()),</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>            <span class="dv">2</span>,</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">3</span>,Nodoi(Nodoe(),<span class="dv">4</span>,Nodoi(Nodoe(),<span class="dv">5</span>,Nodoe())))))</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a2)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a2.es_AVL())</span></code></pre></div>
<pre><code>((☐1☐)2(☐3(☐4(☐5☐))))
False</code></pre>
<p>Lo anterior funciona, pero puede ser ineficiente. Por ejemplo, si el árbol fuera perfectamente balanceado, tendríamos que el costo de calcular la altura de un árbol de tamaño&nbsp;<span class="math inline">n</span> sería</p>
<p><span class="math display">
h(n)=1+2h\left(\frac{n}{2}\right)
</span></p>
<p>que tiene solución&nbsp;<span class="math inline">h(n)=\Theta(n)</span>, lo cual es razonable, porque para calcular la altura se requiere recorrer todo el árbol. Pero determinar si el árbol es AVL demora un tiempo&nbsp;<span class="math inline">a(n)</span>, donde</p>
<p><span class="math display">
a(n)= 2a\left(\frac{n}{2}\right) + 2h\left(\frac{n}{2}\right)
</span></p>
<p>y esto tiene solución&nbsp;<span class="math inline">a(n)=\Theta(n\log{n})</span> por el Teorema Maestro.</p>
<p>Veremos a continuación que esto se puede hacer más eficientemente, en tiempo lineal.</p>
<hr />
</section>
<section id="ejercicio-6.1-chequear-si-un-árbol-es-avl-en-tiempo-lineal" class="level3">
<h3>Ejercicio 6.1 (Chequear si un árbol es AVL en tiempo lineal)</h3>
<p>En este ejercicio usted debe modificar la implementación anterior para asegurar que cada nodo del árbol se visite solo una vez, asegurando de esta manera que el costo de determinar si un árbol es AVL sea&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Para esto, usted debe fusionar las funciones <code>altura</code> y <code>es_AVL</code>en una sola función <code>altura_AVL</code>, que retorne una tupla&nbsp;<span class="math inline">(h,a)</span>, donde&nbsp;<span class="math inline">h</span> es la altura y&nbsp;<span class="math inline">a</span> es un booleano que dice si el árbol es AVL. De esta manera, al invocar la función se tiene de una sola vez toda la información necesaria.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Escriba aquí la nueva definición de nodos y árbol</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Los nodos deben implementar la función altura_AVL</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co"># pero la clase Arbol debe seguir implemmentando una función es_AVL</span></span></code></pre></div>
<p>A continuación, pruébela con los dos árboles utilizados anteriormente:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>a1<span class="op">=</span>Arbol(Nodoi(Nodoi(Nodoe(),<span class="dv">1</span>,Nodoe()),</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>            <span class="dv">2</span>,</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">3</span>,Nodoi(Nodoe(),<span class="dv">4</span>,Nodoe()))))</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a1)</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a1.es_AVL())</span></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>a2<span class="op">=</span>Arbol(Nodoi(Nodoi(Nodoe(),<span class="dv">1</span>,Nodoe()),</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>            <span class="dv">2</span>,</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>            Nodoi(Nodoe(),<span class="dv">3</span>,Nodoi(Nodoe(),<span class="dv">4</span>,Nodoi(Nodoe(),<span class="dv">5</span>,Nodoe())))))</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a2)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a2.es_AVL())</span></code></pre></div>
<hr />
</section>
<section id="altura-mínima-y-máxima-de-un-árbol-avl" class="level3">
<h3>Altura mínima y máxima de un árbol AVL</h3>
<p>Consideremos un árbol AVL con&nbsp;<span class="math inline">n</span> llaves y altura&nbsp;<span class="math inline">h</span>. Sabemos que su número de hojas es&nbsp;<span class="math inline">n+1</span>, y también sabemos que el número de hojas es menor o igual a&nbsp;<span class="math inline">2^h</span>. Por lo tanto,&nbsp;<span class="math inline">h \ge \lceil\log_2{(n+1)}\rceil</span>.</p>
<p>Para encontrar una cota superior, consideremos la familia&nbsp;<span class="math inline">A_h</span> de los árboles AVL de altura&nbsp;<span class="math inline">h</span> con el mínimo número de hojas. Si&nbsp;<span class="math inline">h=0</span>, el único árbol posible es el árbol vacío (solo una hoja) y es AVL. Si&nbsp;<span class="math inline">h=1</span>, el único árbol posible es el que tiene un nodo interno y dos hojas como hijos, y también es AVL.</p>
<p>Consideremos el caso&nbsp;<span class="math inline">h\ge 2</span>. El árbol&nbsp;<span class="math inline">A_h</span> debe tener una raíz y dos subárboles hijos. Si queremos economizar al máximo el número de hojas, uno de ellos debe tener altura&nbsp;<span class="math inline">h-1</span>, para que la altura del árbol completo sea&nbsp;<span class="math inline">h</span>, y el otro debe tener altura&nbsp;<span class="math inline">h-2</span>, para que se cumpla la condición AVL, y ambos deben tener el mínimo posible de hojas, es decir, deben pertenecer a la misma familia.</p>
<p>Por lo tanto, la familia&nbsp;<span class="math inline">A_h</span> se puede construir recursivamente de la siguiente manera:</p>
<figure>
<img src="https://github.com/ivansipiran/CC3001-Apuntes/blob/main/recursos/arboles-fibonacci.png?raw=1" alt="arboles-fibonacci" /><figcaption aria-hidden="true">arboles-fibonacci</figcaption>
</figure>
<p>Los árboles así construídos se llaman <em>árboles de Fibonacci</em>.</p>
<p>Si llamamos&nbsp;<span class="math inline">N_h</span> al número de hojas del árbol&nbsp;<span class="math inline">A_h</span>, tenemos que</p>
<p><span class="math display">
\begin{align}
N_0 &amp;= 1\\
N_1 &amp;= 2\\
N_h &amp;= N_{h-1} + N_{h-2}
\end{align}
</span></p>
<p>Esta es la misma ecuación de Fibonacci, comenzando dos pasos más adelante. Por lo tanto, si denotamos&nbsp;<span class="math inline">f_n</span> al&nbsp;<span class="math inline">n</span>-ésimo número de Fibonacci, tenemos que&nbsp;<span class="math inline">N_h=f_{h+2}=\Theta(\phi^h)</span>.</p>
<p>Como los árboles de Fibonacci son los árboles AVL con el mínimo de hojas, cualquier otro árbol AVL tendrá más hojas que ellos, y por lo tanto, tomando logaritmos, la altura de todo árbol AVL será&nbsp;<span class="math inline">O(\log_{\phi}{(n+1)})</span>.</p>
</section>
<section id="operaciones-sobre-un-árbol-avl" class="level3">
<h3>Operaciones sobre un árbol AVL</h3>
<section id="búsqueda" class="level4">
<h4>Búsqueda</h4>
<p>Un árbol AVL es un ABB (con una condición adicional de balance), así que el algoritmo de búsqueda es el mismo. El que la altura de todo árbol AVL sea logarítmica garantiza que las operaciones de búsqueda tomarán tiempo logarítmico en el peor caso.</p>
</section>
<section id="inserción" class="level4">
<h4>Inserción</h4>
<p>Veremos a continuación que se puede insertar una nueva llave en un árbol AVL, preservando la condición AVL, en tiempo a lo más proporcional a la altura del árbol.</p>
<p>Supongamos que se inserta una nueva llave&nbsp;<span class="math inline">x</span> en un árbol AVL como el que muestra la siguiente figura:</p>
<figure>
<img src="recursos/AVL1.png" alt="AVL1" /><figcaption aria-hidden="true">AVL1</figcaption>
</figure>
<p>Supongamos que se inserta la llave&nbsp;<span class="math inline">x</span>, siguiendo una trayectoria desde la raíz hasta la hoja respectiva, y que luego se retorna hacia arriba revisando en cada nodo de esa trayectoria si la condición AVL se sigue cumpliendo. Si en todos ellos la condición se cumple, no es necesario hacer nada más. Si no, supongamos qie el nodo marcado con asterisco (<span class="math inline">d</span>) es el primero (de abajo hacia arriba) en donde la condición no se cumple.</p>
<p>Consideremos primero el caso en que a partir de&nbsp;<span class="math inline">d</span>, los dos pasos siguientes hacia abajo fueron en la misma dirección (ambos hacia la izquierda, en la figura). Esto se llama una <em>inserción exterior</em>, y los dos pasos son de tipo “zig-zig” (o “zag-zag,” en el caso simétrico en que los dos pasos fueron hacia la derecha).</p>
<p>Para que la condición AVL no se cumpla en&nbsp;<span class="math inline">d</span> y sí se cumpla en&nbsp;<span class="math inline">b</span>, es necesario que los tres subárboles&nbsp;<span class="math inline">A</span>,&nbsp;<span class="math inline">C</span> y&nbsp;<span class="math inline">E</span> sean todos de la misma altura, digamos&nbsp;<span class="math inline">h</span>, y que la inserción de&nbsp;<span class="math inline">x</span> haga que la altura de&nbsp;<span class="math inline">A</span> crezca a&nbsp;<span class="math inline">h+1</span>. Nótese que la altura del árbol, antes de la inserción, era&nbsp;<span class="math inline">h+2</span>.</p>
<p>En este caso hacemos una rotación (simple) entre los nodos&nbsp;<span class="math inline">b</span>y&nbsp;<span class="math inline">d</span>, con el resultado que se muestra a la derecha. En el árbol resultante, los nodos&nbsp;<span class="math inline">b</span> y&nbsp;<span class="math inline">d</span> ahora cumplen la condición AVL (con diferencia cero) y, más aún, después de esta rotación, el árbol resultante tiene altura&nbsp;<span class="math inline">h+2</span>. Por lo tanto, el árbol completo no ha cambiado de altura, lo cual implica que ningún nodo más arriba puede estar desbalanceado.</p>
<p>Por lo tanto, en el caso de una inserción exterior, basta con a lo más una rotación para restaurar la condición AVL en todo el árbol.</p>
<p>Consideremos ahora el caso de una <em>inserción interior</em>, en que los dos primeros pasos fueron en direcciones opuestas (“zig-zag” o el simétrico “zag-zig”):</p>
<figure>
<img src="recursos/AVL2.png" alt="AVL2" /><figcaption aria-hidden="true">AVL2</figcaption>
</figure>
<p>En este caso, es necesario entrar a examinar la estructura interna del subárbol&nbsp;<span class="math inline">C</span>:</p>
<figure>
<img src="recursos/AVL3.png" alt="AVL3" /><figcaption aria-hidden="true">AVL3</figcaption>
</figure>
<p>En este caso,&nbsp;<span class="math inline">x</span> puede ir al subárbol&nbsp;<span class="math inline">F</span> o al subárbol&nbsp;<span class="math inline">G</span> indistintamente (¡pero no a ambos!). Para restaurar la condición de balance AVL, necesitamos hacer <em>dos</em> rotaciones: primero entre&nbsp;<span class="math inline">c</span> y&nbsp;<span class="math inline">b</span>, y luego entre&nbsp;<span class="math inline">c</span> y&nbsp;<span class="math inline">d</span>. El resultado neto es que el zig-zag&nbsp;<span class="math inline">d-b-c</span> se transforma en el subárbol perfectamente balanceado&nbsp;<span class="math inline">b-c-d</span>. El efecto combinado de estas dos rotaciones se llama una <em>rotación doble</em>.</p>
<p>Tal como ocurrió en el caso anterior, los tres nodos involucrados quedan cumpliendo la condición AVL, y el árbol resultante tiene altura&nbsp;<span class="math inline">h+2</span>, la misma que tenía antes de la inserción. Por lo tanto, no puede haber nodos desbalanceados más arriba.</p>
<p>Esto, sumado a lo que vimos antes, demuestra que <strong>a lo más una rotación (simple o doble) basta para recuperar el balance AVL después de una inserción</strong>.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoi:</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, izq, info, der):</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.izq<span class="op">=</span>izq</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.info<span class="op">=</span>info</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.der<span class="op">=</span>der</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height<span class="op">=</span><span class="dv">1</span><span class="op">+</span><span class="bu">max</span>(izq.height,der.height)</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> right_rotation(<span class="va">self</span>):</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(Nodoi(<span class="va">self</span>.izq.izq,</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.izq.info,</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>                     Nodoi(<span class="va">self</span>.izq.der,<span class="va">self</span>.info,<span class="va">self</span>.der)))</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> left_rotation(<span class="va">self</span>):</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(Nodoi(Nodoi(<span class="va">self</span>.izq,<span class="va">self</span>.info,<span class="va">self</span>.der.izq),</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.der.info,</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>                     <span class="va">self</span>.der.der))</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> x<span class="op">!=</span><span class="va">self</span>.info</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">&lt;</span><span class="va">self</span>.info:</span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span>Nodoi(<span class="va">self</span>.izq.insert(x),<span class="va">self</span>.info,<span class="va">self</span>.der)</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p.izq.height<span class="op">&gt;</span>p.der.height<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x<span class="op">&lt;</span>p.izq.info: <span class="co"># inserción exterior</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">=</span>p.right_rotation()</span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>: <span class="co"># inserción interior</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">=</span>Nodoi(p.izq.left_rotation(),p.info,p.der).right_rotation()           </span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># x&gt;self.info, simétrico del anterior</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span>Nodoi(<span class="va">self</span>.izq,<span class="va">self</span>.info,<span class="va">self</span>.der.insert(x))</span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p.der.height<span class="op">&gt;</span>p.izq.height<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x<span class="op">&gt;</span>p.der.info: <span class="co"># inserción exterior</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">=</span>p.left_rotation()</span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>: <span class="co"># inserción interior</span></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">=</span>Nodoi(p.izq,p.info,p.der.right_rotation()).left_rotation()         </span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p</span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;(&quot;</span><span class="op">+</span><span class="va">self</span>.izq.<span class="fu">__str__</span>()<span class="op">+</span><span class="bu">str</span>(<span class="va">self</span>.info)<span class="op">+</span><span class="va">self</span>.der.<span class="fu">__str__</span>()<span class="op">+</span><span class="st">&quot;)&quot;</span></span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodoe:</span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height<span class="op">=</span><span class="dv">0</span></span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Nodoi(Nodoe(),x,Nodoe())</span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a>        return<span class="st">&quot;☐&quot;</span></span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArbolAVL:</span>
<span id="cb89-50"><a href="#cb89-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,raiz<span class="op">=</span>Nodoe()):</span>
<span id="cb89-51"><a href="#cb89-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span>raiz     </span>
<span id="cb89-52"><a href="#cb89-52" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb89-53"><a href="#cb89-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>,x):</span>
<span id="cb89-54"><a href="#cb89-54" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.raiz<span class="op">=</span><span class="va">self</span>.raiz.insert(x)</span>
<span id="cb89-55"><a href="#cb89-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-56"><a href="#cb89-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):        </span>
<span id="cb89-57"><a href="#cb89-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.raiz.<span class="fu">__str__</span>()</span></code></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>ArbolAVL()</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">20</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">40</span>)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">80</span>)</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">10</span>)</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>a.insert(<span class="dv">15</span>)</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code></pre></div>
<pre><code>(☐20☐)
(☐20(☐40☐))
((☐20☐)40(☐80☐))
(((☐10☐)20☐)40(☐80☐))
(((☐10☐)15(☐20☐))40(☐80☐))</code></pre>
</section>
<section id="eliminación" class="level4">
<h4>Eliminación</h4>
<p>La eliminación en árbol AVL se realiza de manera análoga a un ABB, pero también es necesario verificar que la condición de balance se mantenga una vez eliminado el elemento. En caso que dicha condición se pierda, será necesario realizar una rotación simple o doble dependiendo del caso, pero es posible que se requiera más de una rotación para reestablecer el balance del árbol.</p>
</section>
</section>
</section>
<section id="árboles-2-3" class="level2">
<h2>Árboles 2-3</h2>
<p>Los árboles 2-3 son árboles cuyos nodos internos pueden ser <em>binarios</em> o <em>ternarios</em>. Los nodos binarios tienen una llave en su interior, y los nodos ternarios tienen dos llaves.</p>
<p>Las llaves contenidas en los nodos del árbol cumplen la siguiente relación de orden de izquierda a derecha:</p>
<figure>
<img src="recursos/orden-2-3.png" alt="orden-2-3" /><figcaption aria-hidden="true">orden-2-3</figcaption>
</figure>
<p>En un nodo binario, la llave&nbsp;<span class="math inline">X</span> actúa como separador entre las llaves del subárbol izquierdo y las del derecho. En un nodo ternario, la llave&nbsp;<span class="math inline">X</span> separa el subárbol izquierdo del subárbol del medio, y la llave&nbsp;<span class="math inline">Y</span> separa el subárbol del medio del subárbol derecho.</p>
<p>Gracias a este orden, se puede realizar una búsqueda utilizando una generalización del algoritmo de búsqueda en un ABB.</p>
<p>Además de lo anterior, un árbol 2-3 debe tener a todas sus hojas en el mismo nivel. El siguiente es un ejemplo de un árbol 2-3 que satisface ambas condiciones:</p>
<figure>
<img src="recursos/ejemplo-2-3.png" alt="ejemplo-2-3" /><figcaption aria-hidden="true">ejemplo-2-3</figcaption>
</figure>
<p>Nótese que si un árbol 2-3 tiene&nbsp;<span class="math inline">n</span> llaves, ya no necesariamente se cumple que el número de hojas (nodos externos) sea uno más que el número de nodos internos, pero sí se cumple que el número de hojas es igual a&nbsp;<span class="math inline">n+1</span>.</p>
<p>Dado que la altura de un árbol 2-3 es mínima si todos sus nodos son ternarios y es máxima si todos sus nodos son binarios, es fácil ver que</p>
<p><span class="math display">
\log_3{(n+1)} \le \text{ altura } \le \log_2{(n+1)}
</span></p>
<p>y por lo tanto el costo de búsqueda es logarítmico en el peor caso.</p>
<section id="inserción-en-un-árbol-2-3" class="level3">
<h3>Inserción en un árbol 2-3</h3>
<p>Para insertar una nueva llave&nbsp;<span class="math inline">X</span> en un árbol 2-3, se realiza una búsqueda infructuosa y se inserta dicha llave en el último nodo interno visitado durante la búsqueda. Esto puede conducir a dos casos distintos:</p>
<ul>
<li>Si el nodo tenía solo una llave (era binario), ahora queda con dos llaves y pasa a ser ternario:</li>
</ul>
<figure>
<img src="recursos/insercion-2-3-binario.png" alt="insercion-2-3-binario" /><figcaption aria-hidden="true">insercion-2-3-binario</figcaption>
</figure>
<ul>
<li>Si el nodo tenía 2 llaves (era ternario), queda transitoriamente con 3 llaves y 4 hijos. Se dice que ese nodo está saturado, o que tiene <em>overflow</em>, y esto se corrige dividiendo el nodo en dos nodos binarios (<em>split</em>). Los 4 hijos se reparten entre esos dos nodos. Respecto a las llaves, la menor queda en el nodo izquierdo, la mayor en el nodo derecho, y la mediana sube y se inserta en el padre, para actuar como separador entre los dos subárboles resultantes del <em>split</em>.</li>
</ul>
<figure>
<img src="recursos/insercion-2-3-ternario.png" alt="insercion-2-3-ternario" /><figcaption aria-hidden="true">insercion-2-3-ternario</figcaption>
</figure>
<p>Si el padre era binario, la llegada de una nueva llave lo transforma en ternario y el proceso concluye ahí. Pero si ya era ternario, el padre ahora está saturado y el proceso se repite.</p>
<p>En el peor caso, es posible que la raíz llegue a dividirse. En ese caso, se crea una nueva raíz un nivel más arriba la altura del árbol crece en 1.</p>
<section id="ejemplo-de-inserciones-en-un-árbol-2-3" class="level4">
<h4>Ejemplo de inserciones en un árbol 2-3</h4>
<figure>
<img src="recursos/inserciones-2-3.png" alt="inserciones-2-3" /><figcaption aria-hidden="true">inserciones-2-3</figcaption>
</figure>
<hr />
</section>
</section>
<section id="ejercicio-6.2-número-de-operaciones-split" class="level3">
<h3>Ejercicio 6.2 (Número de operaciones <em>split</em>)</h3>
<p>Supongamos que comenzamos con un árbol 2-3 vacío y a continuación insertamos&nbsp;<span class="math inline">n</span> llaves. El objetivo de este ejercicio es calcular cuántas operaciones <em>split</em> se pueden llegar a ejecutar a lo largo de este proceso, en el peor caso.</p>
<p>Una manera de acotar este número de operaciones es ver que una inserción puede gatillar la ejecución de&nbsp;<span class="math inline">O(\log{n})</span> operaciones <em>split</em>, y como son&nbsp;<span class="math inline">n</span> inserciones, el número total de operaciones <em>split</em> es&nbsp;<span class="math inline">O(n\log{n})</span>.</p>
<p>Lo anterior es una cota superior, pero en realidad está muy sobredimensionada.</p>
<p>Demuestre que el número total de operaciones <em>split</em> ejecutadas al insertar&nbsp;<span class="math inline">n</span> llaves comenzando con un árbol 2-3 vacío es&nbsp;<span class="math inline">O(n)</span> en el peor caso. Escriba su demostración en el siguiente recuadro.</p>
<p><em>Indicación</em>: Considere el impacto de un <em>split</em> sobre el número de nodos del árbol.</p>
<section id="demostración" class="level4">
<h4>Demostración:</h4>
<hr />
</section>
</section>
<section id="eliminación-en-un-árbol-2-3" class="level3">
<h3>Eliminación en un árbol 2-3</h3>
<p>Supongamos que queremos eliminar una llave&nbsp;<span class="math inline">Z</span>. Sin perder generalidad, podemos suponer que&nbsp;<span class="math inline">Z</span> está en el nivel más bajo de árbol. Si esto no es así, entonces el sucesor y el predecesor de&nbsp;<span class="math inline">Z</span> se encuentran necesariamente en el nivel inferior, en cuyo caso basta con eliminar uno de ellos, y luego sobreescribir esa llave en el lugar de&nbsp;<span class="math inline">Z</span>.</p>
<p>La eliminación presenta dos posibles casos:</p>
<ul>
<li><p>El nodo en donde se encuentra&nbsp;<span class="math inline">Z</span> es ternario. En este caso, se elimina&nbsp;<span class="math inline">Z</span> junto con una hoja y el nodo queda como binario. <img src="recursos/eliminacion2-3a.gif" alt="eliminacion2-3a" /></p></li>
<li><p>El nodo en donde se encuentra&nbsp;<span class="math inline">Z</span> es binario. En ese caso, al eliminar&nbsp;<span class="math inline">Z</span> y una hoja, el nodo queda como “unario” y sin llaves (<em>underflow</em>). Cuando esto sucede, tenemos dos casos:</p>
<ul>
<li><p>Si el nodo hermano es ternario, le quitamos una llave y una hoja y ambos quedan como binarios. Nótese que, para preservar el orden, se debe realizar un traspaso con la llave en el padre que separa a ambos nodos: <img src="recursos/eliminacion2-3b.gif" alt="eliminacion2-3b" /></p></li>
<li><p>Si el nodo hermano es binario, no le podemos quitar nada. En ese caso, fusionamos a ambos hermanos, resultando un nodo ternario, y la llave del padre que actuaba como separador baja a este nuevo nodo: <img src="recursos/eliminacion2-3c.gif" alt="eliminacion2-3c" /></p></li>
</ul>
<p>Cuando ocurre esto último, el padre pierde un hijo y una llave, lo cual podría dejarlo transformado en unario. En ese caso, se repite el procedimiento anterior, un nivel más arriba.</p></li>
</ul>
<p>El peor caso es que finalmente la raíz quede como un nodo vacío unario. En ese caso, se elimina esa raíz y su hijo queda como raíz.</p>
</section>
<section id="costo-de-las-operaciones" class="level3">
<h3>Costo de las operaciones</h3>
<p>Dado que el árbol 2-3 tiene altura logarítmica, y que las operaciones de inserción, eliminación y búsqueda hacen una cantidad de trabajo constante en cada nivel, el costo de dichas operaciones en el peor caso es&nbsp;<span class="math inline">\Theta(\log{n})</span>.</p>
</section>
</section>
<section id="árboles-b-b-trees" class="level2">
<h2>Árboles B (<em>B-trees</em>)</h2>
<p>Los árboles 2-3 se pueden generalizar a árboles con un mayor número de hijos. La idea es que cuando un nodo excede el número máximo de hijos (y de llaves) permitidos, se divide en dos (<em>split</em>), con la mitad de los hijos cada uno.</p>
<p>Más precisamente, supongamos que&nbsp;<span class="math inline">t\ge 2</span> es un parámetro fijo, y permitimos que todo nodo tenga un mínimo de&nbsp;<span class="math inline">t</span> y un máximo de&nbsp;<span class="math inline">2t-1</span> hijos. Un nodo con&nbsp;<span class="math inline">k</span> hijos tiene&nbsp;<span class="math inline">k-1</span> llaves, que actúan como separadoras entre sus hijos.</p>
<p>Los árboles 2-3 son árboles B con&nbsp;<span class="math inline">t=2</span>. En la práctica, los árboles&nbsp;<span class="math inline">B</span> se implementan con valores mucho más grandes de&nbsp;<span class="math inline">t</span>, por ejemplo&nbsp;<span class="math inline">t=100</span>.</p>
<p>La motivación para utilizar valores altos de&nbsp;<span class="math inline">t</span> es hacer coincidir el tamaño del nodo con la capacidad de un bloque de disco (memoria secundaria). Ésta es memoria masiva de acceso más lento que la memoria cental del computador (memoria RAM), y al tener un grado alto de ramificación, el árbol tiene muy pocos niveles. Gracias a esto, el número de accesos a disco para implementar las operaciones es también muy pequeño.</p>
<section id="inserción-en-un-árbol-b" class="level3">
<h3>Inserción en un árbol B</h3>
<ul>
<li><p>La nueva llave, junto con una nueva hoja, se agregan en el nodo correspondiente en el nivel inferior del árbol.</p></li>
<li><p>Si ese nodo queda saturado (<em>overflow</em>), es decir, si queda con&nbsp;<span class="math inline">2t</span> hijos y&nbsp;<span class="math inline">2t-1</span> llaves, se divide en dos nodos con&nbsp;<span class="math inline">t</span> hijos y&nbsp;<span class="math inline">t-1</span> llaves cada uno. La llave sobrante, que debe ser la mediana del conjunto de llaves, sube al padre como separador de estos dos nuevos nodos.</p></li>
<li><p>Si a causa de esto el padre queda saturado, se repite el procedimiento un nivel más arriba.</p></li>
<li><p>El peor caso es que la raíz llegue a estar saturada. En ese caso, la raíz se divide en dos nodos y se crea un nuevo nodo binario como padre de ellos. Este nodo es la nueva raíz.</p></li>
</ul>
<p>Nótese que, debido a lo anterior, la raíz es el único nodo que está exento de la obligación de tener al menos&nbsp;<span class="math inline">t</span> hijos.</p>
</section>
<section id="eliminación-en-un-árbol-b" class="level3">
<h3>Eliminación en un árbol B</h3>
<ul>
<li><p>Tal como hicimos en el caso de los árboles 2-3, sin perder generalidad, suponemos que la llave a eliminar está en el nivel inferior. Se elimina la llave y una hoja.</p></li>
<li><p>Si a causa de esto el nodo queda con menos de&nbsp;<span class="math inline">t</span> hijos, tenemos dos casos:</p>
<ul>
<li>Si el hermano tiene más de <span class="math inline">t</span> hijos, redistribuimos los hijos y las llaves entre ambos hermanos, mitad y mitad.</li>
<li>Si el hermano tiene solo <span class="math inline">t</span> hijos, no le podemos quitar nada. En ese caso, fusionamos ambos nodos, y la llave del padre que los separaba baja al nuevo nodo. Si a causa de eso el padre queda con menos del mínimo de hijos, se repite este procedimiento un nivel más arriba.</li>
<li>Excepcionalmente, a la raíz se le permite que tenga menos de <span class="math inline">t</span> hijos, pero si llega a quedar como un nodo unario (sin llaves), se elimina y su hijo queda como nueva raíz.</li>
</ul></li>
</ul>
</section>
<section id="costo-de-las-operaciones-en-un-árbol-b" class="level3">
<h3>Costo de las operaciones en un árbol B</h3>
<p>En las estructuras de datos implementadas en memoria secundacia, el costo de las operaciones se aproxima por el número de bloques leídos o escritos, y se ignora el costo del procesamiento en memoria RAM. Esta aproximación se justifica porque el acceso a memoria secundaria es mucho más lento que a memoria RAM.</p>
<p>En un árbol B, el número de accesos a bloques corresponde al número de niveles del árbol, el cual es logarítmico, pero ese logaritmo es en una base muy grande (entre&nbsp;<span class="math inline">t</span> y&nbsp;<span class="math inline">2t-1</span>), de modo que en la práctica podemos decir que el costo es “casi constante.”</p>
</section>
<section id="variantes-de-los-árboles-b" class="level3">
<h3>Variantes de los árboles B</h3>
<p>Veremos dos variantes de la definición anterior, que son importantes en la práctica.</p>
<section id="árboles-b" class="level4">
<h4>Árboles B*</h4>
<p>La idea es no hacer un <em>split</em> apenas un nodo se satura, sino ver si el hermano tiene capacidad como para recibir que le enviemos llaves e hijos. El <em>split</em> solo se hace cuando <em>ambos</em> nodos están saturados, y en ese caso se crea un tercer nodo para distribuir entre los tres equitativamente el contenido.</p>
<p>En los árboles B, la utilización del espacio (fracción ocupada de un nodo) varía entre 50% y 100%. En un árbol B* la utilización varía entre 66,6% y 100%. Al haber una mayor utilización, el grado de ramificación de los nodos es mayor, y por la altura del árbol es menor.</p>
</section>
<section id="árboles-b-1" class="level4">
<h4>Árboles B+</h4>
<p>En los árboles B+, los datos del conjunto se almacenan en orden ascendente de llave en las hojas. Cada hoja tiene una cierta capacidad máxima (correspondiente a la capacidad del bloque de disco en donde se almacena), y cuando se excede, la hoja se divide en dos, cada una 50% llena. Adicionalmente, las hojas se enlazan en una lista de doble enlace, que permite un recorrido secuencial de los datos en orden ascendente o descendente de llave.</p>
<p>La máxima llave de cada hoja (excepto la de la hoja de más a la derecha) se toma como separador y se almacena dentro de los nodos internos del árbol. Nótese que en los nodos internos solo están las llaves y no toda la información que puede acompañarlas, en cambio en las hojas está la información completa.</p>
<p>Debido a esto, al hacer una búsqueda, las preguntas se hacen con&nbsp;<span class="math inline">\le/&gt;</span> y se debe llegar siempre hasta el nivel de las hojas.</p>
<p>El nivel de las hojas se llama en “<em>B-file</em>,” y el conjunto de los nodos internos del árbol se llama el “<em>B-index</em>.”</p>
<p>Los árboles B+ son la versión más utilizada, porque permiten hacer tanto recorridos secuenciales como búsqueda eficientes en memoria secundaria.</p>
</section>
</section>
</section>
<section id="árboles-digitales" class="level2">
<h2>Árboles Digitales</h2>
<p>En esta sección exploramos una manera distinta de almacenar un diccionario usando árboles. Hasta ahora hemos supuesto que las llaves pertenecen a algún conjunto ordenado, pero no hemos hecho ninguna suposición respecto de la estructura interna de las llaves. Ahora vamos a suponer que toda llave&nbsp;<span class="math inline">X</span> se representa como una secuencias de bits:</p>
<p><span class="math display">
X = b_0 b_1 \ldots b_k
</span></p>
<p>Vamos a suponer también que ninguna secuencia de bits asociada a una llave es prefijo de la secuencia de bits de otra llave. Esto se cumple trivialmente si todas las llaves son del mismo largo.</p>
<p>En los ejemplos vamos a considerar el siguiente conjunto de llaves:</p>
<pre><code>A = 00100
B = 01000
C = 01111
D = 11000
E = 11101</code></pre>
<section id="árboles-digitales-o-tries" class="level3">
<h3>Árboles digitales o “<em>tries</em>”</h3>
<p>Un <em>trie</em> es un árbol binario cuyos nodos internos solo se utilizan como puntos de ramificación, para separar las llaves según los bits que la componen. Por convención, supondremos que las llaves que tienen un bit&nbsp;<span class="math inline">0</span> en una posición dada se van hacia la izquierda, y las que tienen un&nbsp;<span class="math inline">1</span> se van hacia la derecha. Cuando se llega a que la secuencia de bits identifica a solo una posible llave, se coloca una hoja que contiene a dicha llave en su interior. Por ejemplo:</p>
<figure>
<img src="recursos/trie.png" alt="trie" /><figcaption aria-hidden="true">trie</figcaption>
</figure>
<p>Nótese que una hoja puede ser vacía. Esto ocurre si no hay ninguna llave que comience con ese prefijo, pero en la rama opuesta hay más de una llave.</p>
<section id="búsqueda-en-un-trie" class="level4">
<h4>Búsqueda en un <em>trie</em></h4>
<p>Para buscar una llave&nbsp;<span class="math inline">X</span> en un <em>trie</em> se procede de la siguiente manera:</p>
<ul>
<li>Se examinan los bits comenzando desde el bit <span class="math inline">b_0</span> en adelante.</li>
<li>Si <span class="math inline">b_i=0</span>, se avanza por la rama izquierda y se pasa a examinar el siguiente bit, <span class="math inline">b_{i+1}</span>.</li>
<li>Si <span class="math inline">b_i=1</span>, se avanza por la rama derecha y se pasa a examinar el siguiente bit.</li>
<li>El proceso termina cuando se llega a una hoja, único lugar posible en donde puede estar <span class="math inline">X</span>. Si la llave almacenada en esa hoja es igual a <span class="math inline">X</span>, se encontró. Si la hoja está vacía, o contiene una llave distinta de <span class="math inline">X</span>, no está.</li>
</ul>
</section>
<section id="inserción-en-un-trie" class="level4">
<h4>Inserción en un <em>trie</em></h4>
<p>Para insertar una llave&nbsp;<span class="math inline">X</span> en un <em>trie</em>, se realiza una búsqueda infructuosa, y se almacena transitoriamente la llave&nbsp;<span class="math inline">X</span> en esa hoja.</p>
<p>Si la hoja estaba vacía, la llave&nbsp;<span class="math inline">X</span> queda en ese lugar de manera definitiva.</p>
<p>Si la hoja contenía otra llave&nbsp;<span class="math inline">Y</span>, se divide la hoja en dos, colgando desde un nuevo nodo interno, y las llaves se trasladan hacia la hoja que corresponda, según si su siguiente bit es&nbsp;<span class="math inline">0</span> o&nbsp;<span class="math inline">1</span>. Se repite este proceso en caso de ser necesario, hasta que en ninguna hoja quede más de una llave.</p>
<p>Es importante notar que, para un conjunto dado de llaves, el <em>trie</em> resultante es único, de modo que el orden de llegada de las llaves no cambia el resultado final. Uno podría suponer que al principio <strong>todas</strong> las llaves estaban en un única hoja, la cual se fue subdividiendo y subdividiendo hasta que en cada hoja quedó a lo más una llave.</p>
</section>
<section id="eliminación-en-un-trie" class="level4">
<h4>Eliminación en un <em>trie</em></h4>
<p>Para eliminar una llave&nbsp;<span class="math inline">X</span> primero se ubica la hoja que la contiene, y se borra la llave, con lo cual la hoja queda vacía. Luego se mira si esta hoja vacía es hermana de otra hoja (la necesariamente sería no vacía) y ambas se fusionan, quedando un nivel más arriba. Se repite este procedimiento hasta que ninguna hoja con una llave quede como hermana de una hoja vacía.</p>
</section>
<section id="costo-esperado-de-búsqueda-exitosa-en-un-trie" class="level4">
<h4>Costo esperado de búsqueda exitosa en un <em>trie</em></h4>
<p>Los <em>tries</em> tienden a ser mejor balanciados que los ABBs, porque si los bits son uniformemente distribuídos, la probabilidad de que una nueva llave vaya a la izquierda o a la derecha es&nbsp;<span class="math inline">1/2</span>. En un ABB, en cambio, esa probabilidad es proporcional al tamaño del subárbol respectivo, de modo que si un árbol está desbalanceado, tiene una tendencia a desbalancearse más.</p>
<p>El análisis matemático del costo esperado de búsqueda es muy complicado, por lo cual solo daremos el resultado sin demostrarlo:</p>
<p><span class="math display">
\begin{align}
C_n &amp;= \frac{H_n}{\ln{2}}+\frac{1}{2}+P(\log_2{n})\\
    &amp; \approx \log_2{n}+1.3327\ldots
\end{align}
</span></p>
<p>donde&nbsp;<span class="math inline">P()</span> es una función periódica de muy pequeña amplitud (del orden de&nbsp;<span class="math inline">10^{-6}</span>).</p>
</section>
</section>
<section id="árboles-de-búsqueda-digital" class="level3">
<h3>Árboles de Búsqueda Digital</h3>
<p>Los árboles de búsqueda digital (ABD) son un híbrido entre los ABBs y los <em>tries</em>.</p>
<p>Las llaves se almacenan en los nodos internos, al igual que en un ABB, pero la ramificación izquierda-derecha se hace según si el siguiente bit es&nbsp;<span class="math inline">0</span> o&nbsp;<span class="math inline">1</span>.</p>
<p>Como los elementos se van insertando en orden de llegada, este orden sí impacta en el resultado final. Por ejemplo, si el orden de llegada de las llaves fuera&nbsp;<span class="math inline">B, A, C, D, E</span>, el resultado sería:</p>
<figure>
<img src="recursos/abd.png" alt="abd" /><figcaption aria-hidden="true">abd</figcaption>
</figure>
<p>El costo esperado de búsqueda en un ABD es levemente menor al de un <em>trie</em>, y se puede demostrar que</p>
<p><span class="math display">
C_n \approx \log_2{n}-0.7166\ldots
</span></p>
</section>
</section>
<section id="listas-saltadas-skip-lists" class="level2">
<h2>Listas Saltadas (<em>Skip Lists</em>)</h2>
<p>Las listas saltadas son una estructura aleatorizada basada en listas enlazadas.</p>
<p>Para motivar la idea, comencemos con una sencilla lista enlazada de menor a mayor, con una cabecera (que imaginamos que tiene una llave&nbsp;<span class="math inline">-\infty</span>) y un fin de lista (que imaginamos que tiene una llave&nbsp;<span class="math inline">+\infty</span>):</p>
<figure>
<img src="recursos/skip-list1.png" alt="skip-list1" /><figcaption aria-hidden="true">skip-list1</figcaption>
</figure>
<p>Una lista como ésta no es muy eficiente, dado que sabemos que una búsqueda en ella demora tiempo&nbsp;<span class="math inline">\Theta(n)</span> tanto en promedio como en el peor caso.</p>
<p>Para aumentar la eficiencia de la búsqueda, supongamos que enlazamos los elementos uno por medio en una segunda lista:</p>
<figure>
<img src="recursos/skip-list2.png" alt="skip-list2" /><figcaption aria-hidden="true">skip-list2</figcaption>
</figure>
<p>De esta manera, podemos buscar primero en la lista de más arriba para acotar en intervalo en que está la llave buscada, y luego usar la lista inferior para buscar en dicho intervalo. Con eso, el tiempo de búsqueda se reduce aproximadamente a la mitad.</p>
<p>Dado que esto fue una buena idea, la podemos aplicar de nuevo, las veces que sea necesaria:</p>
<figure>
<img src="recursos/skip-list3.png" alt="skip-list3" /><figcaption aria-hidden="true">skip-list3</figcaption>
</figure>
<p>La estructura resultante permite hacer búsquedas tan eficientes como la búsqueda binaria, pero sirve solo como motivación para el diseño de un estructura verdaderamente eficiente, porque como está no admite inserciones ni eliminaciones de costo logarítmico.</p>
<p>La clave para obtener una estructura flexible es abandonar la idea de que la altura de cada “torre” de punteros vaya variando regularmente, y concentrarse en que esas alturas solo sigan la misma distribución. Para eso, introduciremos aleatoriedad: para determinar cuántos punteros tendrá un elemento dado, lanzaremos una moneda repetidamente hasta obtener “cara,” y el número de veces que fue necesario lanzar será el número de punteros para ese elemento.</p>
<p>Así, todos los elementos tienen al menos un puntero, en promedio la mitad tiene al menos 2, la cuarta parte al menos 3, etc.</p>
<p>El resultado podría ser, por ejemplo:</p>
<figure>
<img src="recursos/skip-list4.png" alt="skip-list4" /><figcaption aria-hidden="true">skip-list4</figcaption>
</figure>
<section id="búsqueda-en-una-lista-saltada" class="level3">
<h3>Búsqueda en una lista saltada</h3>
<p>Supongamos que queremos buscar la llave&nbsp;<span class="math inline">x</span>. Para esto, vamos a colocar una ficha inicialmente en el casillero correspondiente al tope de la torre de punteros de la cabecera (“<span class="math inline">-\infty</span>”), y la vamos a ir moviendo de acuerdo a las siguientes reglas.</p>
<p>En cada paso, llamemos&nbsp;<span class="math inline">y</span> a la llave a la cual apunta el puntero donde está la ficha.</p>
<ul>
<li>Si <span class="math inline">x&gt;y</span>, movemos la ficha horizontalmente hacia la derecha.</li>
<li>Si <span class="math inline">x\le y</span>, movemos la ficha verticalmente hacia abajo.</li>
</ul>
<p>Lo anterior continúa hasta que al tratar de ejecutar el paso 2, no se puede porque la ficha ya está en el nivel inferior. En ese caso, hacemos una comparación de igualdad entre&nbsp;<span class="math inline">x</span> e&nbsp;<span class="math inline">y</span>. Si&nbsp;<span class="math inline">x=y</span>, lo hemos encontrado, y si no, no está.</p>
<p>La siguiente animación ilustra este proceso:</p>
<figure>
<img src="recursos/skip-search.gif" alt="skip-search" /><figcaption aria-hidden="true">skip-search</figcaption>
</figure>
</section>
<section id="inserción-en-una-lista-saltada" class="level3">
<h3>Inserción en una lista saltada</h3>
<p>Para insertar una nueva llave, se realiza primero una búsqueda infructuosa, y se conserva en una pila la lista de todos los punteros en donde se dio un paso vertical. Luego de determinar aleatoriamente cuántos punteros debe tener el nuevo elemento, éste se inserta en el lugar correspondiente y se recorre la pila, haciendo que todos esos puneros ahora apunten al nuevo elemento, y que éste apunte hacia adonde apuntaban ellos.</p>
</section>
<section id="eliminación-en-una-lista-saltada" class="level3">
<h3>Eliminación en una lista saltada</h3>
<p>Para eliminar una llave, se realiza una búsqueda y se conserva en una pila la lista de todos los punteros en donde se dio un paso vertical. Luego se recorre la pila, haciendo que todos esos punteros apunten hacia adonde apuntaba el elemento que se está eliminando.</p>
</section>
<section id="análisis-de-las-listas-saltadas" class="level3">
<h3>Análisis de las listas saltadas</h3>
<p>El análisis matemático de las listas saltadas es muy complejo, por lo que solo daremos aquí los resultados.</p>
<p>Para generalizar, vamos a suponer que la moneda no es necesariamente insesgada. Suponiendo que la probabilidad de que salga “cara” es&nbsp;<span class="math inline">p</span>, un primer resultado interesante es la <em>altura</em> de la lista saltada, esto es, el número de punteros que tiene la “torre” más alta, lo cual corresponde también al número de punteros que debe tener el elemento “cabecera” de las listas.</p>
<p>Se puede demostrar que la altura espera de una lista saltada con&nbsp;<span class="math inline">n</span> llaves es</p>
<p><span class="math display">
\log_{1/p}{n}+\Theta(1)
</span></p>
<p>Más aún, su varianza es constante, y aproximadamente igual a</p>
<p><span class="math display">
\frac{\pi^2}{6\ln^2{p}}+\frac{1}{12}
</span></p>
<p>con lo cual resulta muy improbable que la altura pueda exceder por mucho a su valor esperado.</p>
<p>Respecto al costo esperado de búsqueda, se puede demostrar que</p>
<p><span class="math display">
\begin{align}
C_n &amp;= \frac{1}{p}\log_{1/p}{n}+\Theta(1)\\
    &amp;= \frac{1}{p\log_{2}{(1/p)}}\log_{2}{n}+\Theta(1)
\end{align}
</span></p>
<p>Si la moneda es insesgada (<span class="math inline">p=1/2</span>), tenemos que la altura esperada es&nbsp;<span class="math inline">\log_{2}{n}+\Theta(1)</span> y que el costo esperado de búsqueda es&nbsp;<span class="math inline">2\log_{2}{n}+\Theta(1)</span>.</p>
<p>Pero el valor que minimiza la constante que multiplica al&nbsp;<span class="math inline">\log_{2}{n}</span> no es&nbsp;<span class="math inline">p=1/2</span>, sino que es&nbsp;<span class="math inline">p=1/e=0.3678794412\ldots</span>, y para este valor de&nbsp;<span class="math inline">p</span> se tiene que el costo esperado de búsqueda es</p>
<p><span class="math display">
C_n = (e\ln{2})\log_{2}{n}+\Theta(1) \approx 1.884 \log_{2}{n}+\Theta(1)
</span></p>
</section>
</section>
<section id="árboles-de-búsqueda-binaria-óptimos" class="level2">
<h2>Árboles de búsqueda binaria óptimos</h2>
<p>Si todas las llaves de un ABB son igualmente probables de ser buscadas, el ábol que minimiza el costo esperado de búsqueda es el árbol perfectamente balanceado.</p>
<p>Pero si las llaves tienen probabilidades no uniformes, o si las búsquedas infructuosas pueden caer en hojas con distinta probabilidad, el árbol que minimiza el costo esperado de búsqueda puede ser muy diferente.</p>
<p>Supongamos que tenemos&nbsp;<span class="math inline">n</span> llaves&nbsp;<span class="math inline">X_1 &lt; X_2, \ldots &lt; X_n</span> con probabilidades de acceso conocidas&nbsp;<span class="math inline">p_1, p_2, \ldots, p_n</span> respectivamente, y supongamos que las hojas, numeradas de&nbsp;<span class="math inline">0</span> a&nbsp;<span class="math inline">n</span> de izquierda a derecha, tienen probabilidades de búsqueda infructuosa&nbsp;<span class="math inline">q_0, q_1, \ldots, q_n</span> respectivamente.</p>
<p>El problema es encontrar el árbol de búsqueda binaria que minimiza el costo esperado de búsqueda</p>
<p><span class="math display">
C(0,n) = \sum_{1\le i \le n} (1+\text{nivel}(\text{llave }i))p_i +
         \sum_{0\le i \le n} \text{nivel}(\text{hoja }i)q_i
</span></p>
<p>donde los niveles del árbol se numeran de&nbsp;<span class="math inline">0</span> en adelante a partir de la raíz.</p>
<p>Por ejemplo, consideremos en siguiente ABB con&nbsp;<span class="math inline">6</span> llaves, en donde en cada nodo (interno o externo) se ha anotado la probabilidad de que la búsqueda termine en él:</p>
<figure>
<img src="recursos/abbopt1.png" alt="abbopt1" /><figcaption aria-hidden="true">abbopt1</figcaption>
</figure>
<p>El costo esperado de búsqueda es</p>
<p><span class="math display">
C(0,6) = (2q_0+2p_1+4q_1+4p_2+4q_2+3p_3+4q_3+4p_4+4q_4)+p_5+(2q_5+2p_6+2q_6)
</span></p>
<p>donde hemos parentizado la parte que corresponde al subárbol izquierdo y derecho, respectivamente.</p>
<p>Escribamos ahora las fórmulas análogos para los subáboles, suponiendo que ellos fueran árboles independientes:</p>
<p><span class="math display">
\begin{align}
C(0,4) &amp; = q_0+p_1+3q_1+3p_2+3q_2+2p_3+3q_3+3p_4+3q_4\\
C(5,6) &amp; = q_5+p_6+q_6
\end{align}
</span></p>
<p>Si restamos esto a la fórmula para&nbsp;<span class="math inline">C(0,6)</span>, la diferencia es la suma de todas las probabilidades, llamémosla&nbsp;<span class="math inline">W(0,6)</span> (<span class="math inline">W</span> por “weight,” o peso). Por cierto, en el caso del árbol completo esta suma es igual a&nbsp;<span class="math inline">1</span>, pero no así en los subárboles.</p>
<p>Utilizando esta notación, tenemos que</p>
<p><span class="math display">
C(0,6) = W(0,6)+C(0,4)+C(5,6)
</span></p>
<p>Lo anterior es para un árbol con hojas numeradas de&nbsp;<span class="math inline">0</span> a&nbsp;<span class="math inline">6</span> y con la raíz ocupada por&nbsp;<span class="math inline">X_5</span>.</p>
<p>Más en general, si tenemos un árbol con hojas numeradas desde&nbsp;<span class="math inline">i</span> a&nbsp;<span class="math inline">j</span> y con&nbsp;<span class="math inline">X_k</span> en la raíz, se cumple que</p>
<p><span class="math display">
C(i,j) = W(i,j)+C(i,k-1)+C(k,j)
</span></p>
<p>Nótese que si éste fuera el árbol óptimo, los subárboles también deberían ser óptimos, porque de lo contrario podríamos reemplazar ese subárbol por uno de costo menor, y el costo total disminuiría estrictamente, contradicción con la hipótesis de que el árbol era óptimo.</p>
<p>Pero al revés no necesariamente es cierto: los subárboles pueden ser óptimos, pero el árbol completo no, si es que hemos elegido mal la raíz. Para asegurarnos de que el árbol completo sea óptimo, debemos minimizar sobre todas las raíces posibles:</p>
<p><span class="math display">
\hat{C}(i,j) = W(i,j)+\min_{i+1\le k \le j}(\hat{C}(i,k-1)+\hat{C}(k,j))
</span></p>
<p>y el costo de buscar en un árbol vacío es&nbsp;<span class="math inline">0</span>:</p>
<p><span class="math display">
\hat{C}(i,i)=0 \text{ para }0 \le i \le n
</span></p>
<p>Finalmente, el costo del árbol óptimo para el conjunto completo de llaves es&nbsp;<span class="math inline">\hat{C}(0,n)</span>.</p>
<section id="un-algoritmo-de-programación-dinámica-para-encontrar-un-abb-óptimo" class="level3">
<h3>Un algoritmo de Programación Dinámica para encontrar un ABB óptimo</h3>
<p>A partir de la recurrencia anterior se puede formular fácilmente un algoritmo recursivo para el árbol óptimo y su costo, pero eso sería equivalente a un algoritmo de fuerza bruta que examina todos los árboles posibles. Como el número de árboles es el número de Catalan, que crece exponencialmente con&nbsp;<span class="math inline">n</span>, es sería un algoritmo muy ineficiente.</p>
<p>En cambio, si utilizamos <em>tabulación</em>, podemos resolver el problema de manera mucho más rápida. La tabulación es posible porque hay solo&nbsp;<span class="math inline">\Theta(n^2)</span> valores&nbsp;<span class="math inline">\hat{C}(i,j)</span> distintos por calcular, los cuales podemos almacenar en una matriz, y la podemos ir llenando de manera que todos los casilleros necesarios para calcular el casillero&nbsp;<span class="math inline">(i,j)</span> ya hayan sido llenados previamente.</p>
<p>Para implementar el algoritmo, definamos una nueva variable&nbsp;<span class="math inline">d=j-i</span> que calcula el número de llaves del subárbol&nbsp;<span class="math inline">(i,j)</span>, y vamos a ir llenando una matriz <code>C</code> en orden creciente de&nbsp;<span class="math inline">d</span>.</p>
<p>Al mismo tiempo que vamos llenando esa matriz, vamos a ir llenando una matriz paralela <code>R</code> que almacenará el valor del&nbsp;<span class="math inline">k</span> para el cual se alcanza el óptimo en el subárbol&nbsp;<span class="math inline">(i,j)</span>. Éste será el subíndice de la raíz óptima para dicho subárbol, lo cual nos permitirá construir el árbol óptimo y también, como veremos pronto, acelerar significativamente el algoritmo.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculaABBoptimo(p,q):</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(q)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    C<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)) <span class="co"># Esto ya deja la diagonal en cero</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    W<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>),dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>        W[i,i]<span class="op">=</span>q[i]</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n<span class="op">-</span>d<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i<span class="op">+</span>d</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>            W[i,j]<span class="op">=</span>W[i,j<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>p[j]<span class="op">+</span>q[j]</span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>            C[i,j]<span class="op">=</span>math.inf <span class="co"># +infinito</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>,j<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>                m<span class="op">=</span>W[i,j]<span class="op">+</span>C[i,k<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>C[k,j]</span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> m<span class="op">&lt;</span>C[i,j]:</span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>                    C[i,j]<span class="op">=</span>m</span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>                    R[i,j]<span class="op">=</span>k <span class="co"># anotamos dónde se alcanza el min</span></span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (C[<span class="dv">0</span>,n],R)</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ABBoptimo(R,i,j):</span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">&quot;☐&quot;</span> <span class="cf">if</span> i<span class="op">==</span>j <span class="cf">else</span> <span class="st">&quot;(&quot;</span><span class="op">+</span>ABBoptimo(R,i,R[i,j]<span class="op">-</span><span class="dv">1</span>)<span class="op">+</span><span class="st">&quot;X&quot;</span><span class="op">+</span><span class="bu">str</span>(R[i,j])<span class="op">+</span>ABBoptimo(R,R[i,j],j)<span class="op">+</span><span class="st">&quot;)&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>p<span class="op">=</span>[<span class="dv">0</span>,<span class="fl">0.15</span>,<span class="fl">0.10</span>,<span class="fl">0.05</span>,<span class="fl">0.10</span>,<span class="fl">0.20</span>]</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>q<span class="op">=</span>[<span class="fl">0.05</span>,<span class="fl">0.10</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.10</span>]</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>(Copt,R)<span class="op">=</span>calculaABBoptimo(p,q)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Costo óptimo=&quot;</span>, Copt)</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Arbol óptimo=&quot;</span>, ABBoptimo(R,<span class="dv">0</span>,<span class="dv">5</span>))</span></code></pre></div>
<pre><code>Costo óptimo= 2.35
Arbol óptimo= (((☐X1☐)X2(☐X3☐))X4(☐X5☐))</code></pre>
</section>
<section id="análisis-del-algoritmo" class="level3">
<h3>Análisis del algoritmo</h3>
<p>El algoritmo rellena todos los casilleros&nbsp;<span class="math inline">(i,j)</span> de la matriz, con&nbsp;<span class="math inline">0\le i \le j \le n</span>, y para cada casillero recorre el rango&nbsp;<span class="math inline">(i+1)..j</span>.</p>
<p>Dado que hay aproximadamente&nbsp;<span class="math inline">n^2/2</span> casileros que se deben llenar, y que para cada uno de ellos el rango es de tamaño a lo más&nbsp;<span class="math inline">n</span>, es evidente que el tiempo de ejecución del algoritmo es&nbsp;<span class="math inline">O(n^3)</span>.</p>
<p>Sin embargo, esta cota podría ser exagerada, porque el tamaño de muchos rangos es mucho menor que&nbsp;<span class="math inline">n</span>. Como el tamaño del rango que va desde&nbsp;<span class="math inline">i+1</span> hasta&nbsp;<span class="math inline">j</span> es&nbsp;<span class="math inline">j-i</span>, una contabilidad más precisa sería decir que el tiempo del algoritmo es</p>
<p><span class="math display">
\sum_{0\le i \le j \le n}{(j-i)} = \frac{n(n+1)(n+2)}{6} = \Theta(n^3)
</span></p>
<p>de modo que el tiempo que demora el algoritmo en realidad es cúbico.</p>
</section>
<section id="un-algoritmo-más-eficiente" class="level3">
<h3>Un algoritmo más eficiente</h3>
<p>Supongamos que hemos calculado que la raíz óptima para un subárbol&nbsp;<span class="math inline">(i,j)</span> es&nbsp;<span class="math inline">k=R[i,j]</span>.</p>
<p>Imaginemos ahora que quitamos la llave de más a la derecha y obtenemos la nueva raíz óptima&nbsp;<span class="math inline">R[i,j-1]</span>. Se puede demostrar que, al ser el subárbol de la derecha más “liviano,” la nueva raíz no puede estar a la derecha de&nbsp;<span class="math inline">k</span>: o se mantiene donde mismo, o se mueve a la izquierda. Por lo tanto,</p>
<p><span class="math display">
R[i,j-1]\le R[i,j]
</span></p>
<p>Por un razonamiento análogo, se puede demostrar que</p>
<p><span class="math display">
R[i+1,j] \ge R[i,j]
</span></p>
<p>Juntando ambos resultados, tenemos que para buscar la raíz óptima para&nbsp;<span class="math inline">(i,j)</span> ya no es necesario buscar en el rango&nbsp;<span class="math inline">i+1 \le k \le j</span>, sino que basta buscar en</p>
<p><span class="math display">
R[i,j-1]\le k \le R[i+1,j]
</span></p>
<p>con los valores de borde&nbsp;<span class="math inline">R[i,i+1]=i+1</span>.</p>
<p>Para la implementación de este algoritmo optimizado, debemos manejar aparte el caso&nbsp;<span class="math inline">d=1</span>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculaABBoptimo2(p,q):</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(q)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    C<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)) <span class="co"># Esto ya deja la diagonal en cero</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    W<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.zeros((n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>),dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>        W[i,i]<span class="op">=</span>q[i]</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Caso d=1</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n):</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>        W[i,i<span class="op">+</span><span class="dv">1</span>]<span class="op">=</span>W[i,i]<span class="op">+</span>p[i<span class="op">+</span><span class="dv">1</span>]<span class="op">+</span>q[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>        C[i,i<span class="op">+</span><span class="dv">1</span>]<span class="op">=</span>W[i,i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>        R[i,i<span class="op">+</span><span class="dv">1</span>]<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Casos de d=2 en adelante</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,n<span class="op">-</span>d<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>            j<span class="op">=</span>i<span class="op">+</span>d</span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>            W[i,j]<span class="op">=</span>W[i,j<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>p[j]<span class="op">+</span>q[j]</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a>            C[i,j]<span class="op">=</span>math.inf <span class="co"># +infinito</span></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(R[i,j<span class="op">-</span><span class="dv">1</span>],R[i<span class="op">+</span><span class="dv">1</span>,j]<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a>                m<span class="op">=</span>W[i,j]<span class="op">+</span>C[i,k<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>C[k,j]</span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> m<span class="op">&lt;</span>C[i,j]:</span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true" tabindex="-1"></a>                    C[i,j]<span class="op">=</span>m</span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true" tabindex="-1"></a>                    R[i,j]<span class="op">=</span>k <span class="co"># anotamos dónde se alcanza el min</span></span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (C[<span class="dv">0</span>,n],R)</span></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>p<span class="op">=</span>[<span class="dv">0</span>,<span class="fl">0.15</span>,<span class="fl">0.10</span>,<span class="fl">0.05</span>,<span class="fl">0.10</span>,<span class="fl">0.20</span>]</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>q<span class="op">=</span>[<span class="fl">0.05</span>,<span class="fl">0.10</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.10</span>]</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>(Copt,R)<span class="op">=</span>calculaABBoptimo2(p,q)</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Costo óptimo=&quot;</span>, Copt)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Arbol óptimo=&quot;</span>, ABBoptimo(R,<span class="dv">0</span>,<span class="dv">5</span>))</span></code></pre></div>
<pre><code>Costo óptimo= 2.35
Arbol óptimo= (((☐X1☐)X2(☐X3☐))X4(☐X5☐))</code></pre>
</section>
<section id="análisis-del-algoritmo-optimizado" class="level3">
<h3>Análisis del algoritmo optimizado</h3>
<p>En este nuevo algoritmo, el tamaño del rango que hay que examinar para llenar el casillero&nbsp;<span class="math inline">(i,j)</span> es&nbsp;<span class="math inline">R[i+1,j]-R[i,j-1]+1</span>. Al sumar todos estos tamaños, todos los elementos del interior de la matriz&nbsp;<span class="math inline">R</span> se cancelan, porque aparecen en la suma una vez con signo positivo y una vez con signo negativo. Solo sobreviven diferencias entre elementos de los bordes. Como hay&nbsp;<span class="math inline">\Theta(n)</span> casilleros en los bordes y cada diferencia es a lo más&nbsp;<span class="math inline">n</span>, la suma total es&nbsp;<span class="math inline">O(n^2)</span>. El término “<span class="math inline">+1</span>” aporta un término cuadrático a la suma total, y por lo tanto el tiempo total de ejecución del algoritmo es&nbsp;<span class="math inline">\Theta(n^2)</span>.</p>
<p>Por lo tanto, con esta optimización el algoritmo cúbico se transformó en un algoritmo cuadrático.</p>
</section>
</section>
<section id="splay-trees" class="level2">
<h2>Splay Trees</h2>
<p>Los Splay Trees son una estrategia para garantizar que cualquier secuencia de&nbsp;<span class="math inline">m</span> operaciones en un árbol que llega a tener tamaño&nbsp;<span class="math inline">n</span>, comenzando con un árbol vacío, toma tiempo&nbsp;<span class="math inline">O(m\log{n})</span>.</p>
<p>Esto no garantiza que el costo de una operación individual no pueda tener costo&nbsp;<span class="math inline">O(n)</span>, sino que el costo acumulado dividido por el número de operaciones da un promedio de&nbsp;<span class="math inline">O(\log{n})</span> por operación. Se dice que una estructura de este tipo es eficiente en el sentido <em>amortizado</em>.</p>
<p>La idea básica de un splay tree es que cuando una llave es accesada, se haga una secuencia de rotaciones para llevarla hasta la raíz. Si estas rotaciones se hacer de a un nivel a la vez, el resultado es lo que se llama “move to root,” pero esa estrategia es vulnerable a que una secuencia de&nbsp;<span class="math inline">m</span> operaciones bien escogidas pueda hacerla tener un costo acumulado de&nbsp;<span class="math inline">O(mn)</span>.</p>
<p>La idea del “splaying” es hacer las rotaciones de a dos niveles a la vez. Supongamos que la llave accesada es&nbsp;<span class="math inline">k</span>, y que las dos llaves siguientes hacia aarriba son&nbsp;<span class="math inline">p</span> (padre) y&nbsp;<span class="math inline">a</span> (abuelo). Hay tres casos:</p>
<p><strong>Caso zig-zag</strong></p>
<p>En este caso, se hace la misma rotación doble de los árboles AVL:</p>
<figure>
<img src="recursos/splay1.png" alt="splay1" /><figcaption aria-hidden="true">splay1</figcaption>
</figure>
<p><strong>Caso zig-zig</strong></p>
<p>En este caso, el zig-zig se transforma en un zag-zag. Esto <em>no</em> es lo mismo que si se hubiesen hecho dos rotaciones simples:</p>
<figure>
<img src="recursos/splay2.png" alt="splay2" /><figcaption aria-hidden="true">splay2</figcaption>
</figure>
<p>El análisis de los splay trees es complejo, porque debe considerar la estructura cambiante del árbol en cada acceso realizado. Por otra parte, los splay trees son más fáciles de implementar que un AVL dado que no hay que verificar una condición de balance.</p>
<p><strong>Caso zig</strong></p>
<p>Esto solo aplica cuando la llave accesada está a un paso de la raíz. En este caso, se hace una rotación simple para llevarla a la raíz del árbol.</p>
</section>
<section id="hashing" class="level2">
<h2>Hashing</h2>
<p>En esta sección vamos a ver un enfoque llamado <em>Hashing</em> que permite hacer búsquedas en tiempo esperado <em>constante</em>, en la medida que estemos dispuestos a no hacer uso del 100% de la memoria reservada para la estructura de datos.</p>
<p>Antes de ver hashing propiamente tal, veremos una estructura más sencilla y más eficiente, pero de utilidad más limitada, que nos servirá como motivación.</p>
<section id="bitmaps" class="level3">
<h3>Bitmaps</h3>
<p>Supongamos que queremos almacenar&nbsp;<span class="math inline">n</span> números enteros no negativos, sabiendo que todos ellos están contenidos en el rango&nbsp;<span class="math inline">[0..m-1]</span>, para algún valor de&nbsp;<span class="math inline">m</span>.</p>
<p>Una forma muy simple de poder almacenar estos números y hacer búsquedas, inserciones y eliminaciones eficientes es utilizar un arreglo&nbsp;<span class="math inline">a[0],\ldots,a[m-1]</span>, marcando con un&nbsp;<span class="math inline">1</span> los lugares correspondientes a los números que están presentes, y con&nbsp;<span class="math inline">0</span> a los que no.</p>
<p>Por ejemplo, si&nbsp;<span class="math inline">m=8</span> y el conjunto de números a almacenar es&nbsp;<span class="math inline">\{1,4,7\}</span>, el arreglo contendría lo siguiente:</p>
<figure>
<img src="recursos/bitmap.png" alt="bitmap" /><figcaption aria-hidden="true">bitmap</figcaption>
</figure>
<p>Con esta representación, insertar la llave&nbsp;<span class="math inline">x</span> es hacer&nbsp;<span class="math inline">a[x]=1</span>, para eliminarla hacemos&nbsp;<span class="math inline">a[x]=0</span> y para buscarla preguntamos si&nbsp;<span class="math inline">a[x]==1</span>. Todas estas operaciones toman tiempo&nbsp;<span class="math inline">\Theta(1)</span>.</p>
<p>¿Cómo es posible que se pueda violar la cota logarítmica que demostramos cuando vimos Búsqueda Binaria?</p>
<p>La razón es porque esa cota se demostró para cualquier algoritmo que funcione en base a comparaciones, y este algoritmo de Bitmaps no hace comparaciones de llaves, sino que las usa como subíndice, lo cual en realidad es equivalente a hacer aritmética con las llaves.</p>
<p>El motivo por el cual esta no es una solución muy usada es porque solo es aplicable si las llaves son enteros en un rango relativamente pequeño, porque de lo contrario el tamaño del arraglo&nbsp;<span class="math inline">a</span> podría ser exageradamente grande.</p>
<p>El método de hashing trata de aproximar la eficiencia de los Bitmaps sin tener esa limitación sobre las llaves.</p>
</section>
<section id="funciones-de-hashing" class="level3">
<h3>Funciones de hashing</h3>
<p>Una función de hashing es una función que transforma una llave&nbsp;<span class="math inline">x</span> en un valor&nbsp;<span class="math inline">h(x) \in [0..m-1]</span>, para un valor dado de&nbsp;<span class="math inline">m</span>, donde&nbsp;<span class="math inline">m</span> es mucho menor que el tamaño del universo al cual pertenece&nbsp;<span class="math inline">x</span>. La idea es utilizar la idea de un bitmap, utilizando&nbsp;<span class="math inline">h(x)</span> en lugar de&nbsp;<span class="math inline">x</span>.</p>
<p>La función&nbsp;<span class="math inline">h</span> debe ser de tipo <em>pseudoaleatorio</em>, esto es, debe distribuir sus valores uniformemente sobre el rango&nbsp;<span class="math inline">[0..m-1]</span>, pero debe ser reproducible.</p>
<p>Considerando que toda llave&nbsp;<span class="math inline">x</span> se codifica como una secuencia (posiblemente muy larga) de bits, y puede ser interpretada por lo tanto como un número entero, una familia de funciones de hashing puede obtenerse con la fórmula</p>
<p><span class="math display">
h(x) = (cx \bmod p) \bmod m
</span></p>
<p>donde&nbsp;<span class="math inline">c</span> es una constante y&nbsp;<span class="math inline">p</span> es un número primo. Distintos valores de estos parámetros producen distintas funciones de hashing.</p>
<p>Python tiene una función <code>hash()</code> que se vamos a utilizar en nuestros ejemplos.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>m<span class="op">=</span><span class="bu">int</span>(<span class="bu">input</span>(<span class="st">&quot;m=&quot;</span>))</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>x<span class="op">=</span><span class="bu">input</span>(<span class="st">&quot;x=&quot;</span>)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;h(x)=&quot;</span>,<span class="bu">hash</span>(x)<span class="op">%</span>m)</span></code></pre></div>
<pre><code>m=1000
x=Patricio Poblete
h(x)= 165</code></pre>
<p>Dado un conjunto de&nbsp;<span class="math inline">n</span> llaves, suponiendo por el momento que&nbsp;<span class="math inline">n\le m</span>, es posible que todas ellas sean mapeadas por la función&nbsp;<span class="math inline">h</span> a valores distintos. Si fuera ese el caso, podríamos utilizar los&nbsp;<span class="math inline">h(x)</span> con un bitmap sin problemas. Sin embargo, en la práctica esto es muy improbable, y seguramente vamos a encontrarnos con llaves distintas&nbsp;<span class="math inline">x, y</span> tales que&nbsp;<span class="math inline">h(x)=h(y)</span>. Esto se llama una <em>colisión</em>.</p>
<p>El que alguna colisión sea probable que exista viene de la <em>paradoja de los cumpleaños</em>, que veremos a continuación. Por otra parte, en promedio no puede haber muchas colisiones, porque para un valor de&nbsp;<span class="math inline">k</span> dado, el múmero promedio de llaves&nbsp;<span class="math inline">x</span> que tienen&nbsp;<span class="math inline">h(x)=k</span> es&nbsp;<span class="math inline">n/m\le 1</span>, dado que suponemos que&nbsp;<span class="math inline">h(x)</span> distribuye las llaves uniformemente.</p>
</section>
<section id="la-paradoja-de-los-cumpleaños" class="level3">
<h3>La Paradoja de los Cumpleaños</h3>
<p>Supongamos que en una sala hay&nbsp;<span class="math inline">n</span> personas. ¿Cuán grande debe ser&nbsp;<span class="math inline">n</span> para que sea probable que existan dos o más personas con cumpleaños el mismo día? Más precisamente, ¿para qué valor de&nbsp;<span class="math inline">n</span> la probabilidad de que haya alguna colisión de cumpleaños es&nbsp;<span class="math inline">\ge 1/2</span>?</p>
<p>Resulta más fácil calcular la probabilidad opuesta&nbsp;<span class="math inline">d_n</span> de que <em>no</em> haya colisión de cumpleaños. Esta probabilidad es igual a</p>
<p><span class="math display">
d_n = \left( \frac{365}{365} \right) \left( \frac{364}{365} \right) \cdots \left( \frac{365-n+1}{365} \right)
</span></p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pylab inline</span></code></pre></div>
<pre><code>Populating the interactive namespace from numpy and matplotlib</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">101</span>)</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>d<span class="op">=</span>zeros(<span class="dv">100</span>)</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>d[<span class="dv">0</span>]<span class="op">=</span><span class="dv">1</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">100</span>):</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    d[k]<span class="op">=</span>d[k<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>(<span class="dv">365</span><span class="op">-</span>k)<span class="op">/</span><span class="dv">365</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>plt.plot(n,d,label<span class="op">=</span><span class="st">&#39;$d_n$&#39;</span>)</span></code></pre></div>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x117ea24e0&gt;]</code></pre>
<figure>
<img src="06_Diccionarios_files/06_Diccionarios_144_1.png" alt="png" /><figcaption aria-hidden="true">png</figcaption>
</figure>
<p>Para&nbsp;<span class="math inline">n=23</span> se tiene&nbsp;<span class="math inline">d_n = 0.4927 &lt; 1/2</span>, por lo tanto para&nbsp;<span class="math inline">n=23</span> la probabilidad de que exista alguna colisión es mayor que&nbsp;<span class="math inline">1/2</span>.</p>
<p>Nótese que&nbsp;<span class="math inline">23</span> es relativamente pequeño comparado con&nbsp;<span class="math inline">365</span>, lo cual indica, en general, que no es necesario que&nbsp;<span class="math inline">n</span> sea muy grande en relación a&nbsp;<span class="math inline">m</span> para que sea probable que exista alguna colisión. Por otra parte, el número total de colisiones no puede ser muy grande, y ambos hechos son los que debemos tener en consideración al aplicar la idea de hashing al diseño de diccionarios.</p>
</section>
<section id="métodos-de-resolución-de-colisiones" class="level3">
<h3>Métodos de resolución de colisiones</h3>
<p>Dado que es inevitable que existan colisiones (aunque esperamos que sean pocas), debe haber alguna manera de resolver el problema que se produce cuando dos o más llaves son enviadas por la función de hashing al mismo casillero de la tabla.</p>
<p>Existen dos grandes familias de métodos:</p>
<ul>
<li><p><em>Encadenamiento</em>: Utilizar punteros para enlazar los elementos que coinciden en su función de hashing.</p></li>
<li><p><em>Direccionamiento abierto (Open addressing)</em>: Utilizar una secuencia de funciones de hashing</p></li>
</ul>
</section>
</section>
<section id="hashing-con-encadenamiento" class="level2">
<h2>Hashing con Encadenamiento</h2>
<p>La idea en este método es que todos los elementos que caen en el mismo lugar de la tabla se enlazan en una lista secuencial, y en cada casillero se almacena el puntero al inicio de la lista respectiva.</p>
<figure>
<img src="recursos/encadenamiento.gif" alt="encadenamiento" /><figcaption aria-hidden="true">encadenamiento</figcaption>
</figure>
<p>Para analizar la eficiencia de este método, recordemos que para un conjunto de&nbsp;<span class="math inline">n</span> llaves hemos definido&nbsp;<span class="math inline">C_n</span> y&nbsp;<span class="math inline">C&#39;_n</span> como respectivamente el número esperado de comparaciones de llaves en una búsqueda exitosa y en una búsqueda infructuosa.</p>
<p>Si suponemos que&nbsp;<span class="math inline">n</span> llaves se lanzan al azar sobre una tabla de tamaño&nbsp;<span class="math inline">m</span>, el número esperado de llaves por casillero es&nbsp;<span class="math inline">n/m</span>, y eso es también el largo esperado de una lista aleatoria. En una búsqueda infructuosa hay que recorrer toda la lista, y por lo tanto tenemos que</p>
<p><span class="math display">
C&#39;_n = \frac{n}{m}
</span></p>
<p>Para analizar el costo esperado de búsqueda exitosa&nbsp;<span class="math inline">C_n</span>, consideremos las llaves en orden de inserción. Supongamos que hay&nbsp;<span class="math inline">k</span> llaves en la tabla e insertamos una más. El largo esperado de la lista en que le toca almacenarse es&nbsp;<span class="math inline">k/m</span>, y supongamos que la nueva llave se agrega al final de su lista. Si ahora hacemos una búsqueda exitosa de llave recién insertada, su costo esperado de búsqueda será&nbsp;<span class="math inline">1+k/m</span>. Para calcular el costo esperado de búsqueda exitosa sobre todas las llaves de la tabla, tenemos que sumar esos costos individuales y dividir por&nbsp;<span class="math inline">n</span>:</p>
<p><span class="math display">
C_n = \frac{1}{n} \sum_{0\le k\le n-1} \left( 1 + C&#39;_k \right) = \frac{1}{n} \sum_{0\le k\le n-1} \left( 1 + \frac{k}{m} \right) = 1 + \frac{n-1}{2m}
</span></p>
<p>Se define el <em>factor de carga de la tabla</em> <span class="math inline">\alpha</span> como el cuociente</p>
<p><span class="math display">
\alpha = \frac{n}{m}
</span></p>
<p>Se dice que una tabla está&nbsp;<span class="math inline">\alpha</span>-llena si el cuociente&nbsp;<span class="math inline">n/m</span> se mantiene constante a medida que&nbsp;<span class="math inline">n</span> y&nbsp;<span class="math inline">m</span> crecen.</p>
<p>Para una tabla de hashing con encadenamiento que está&nbsp;<span class="math inline">\alpha</span>-llena, se tiene que</p>
<p><span class="math display">
\begin{align}
C&#39;_n &amp; = \alpha \\
C_n &amp; \approx 1+\frac{\alpha}{2}
\end{align}
</span></p>
<p>Esto ilustra un hecho que caracteriza a las tablas de hashing: cuando el factor de carga&nbsp;<span class="math inline">\alpha</span> se mantiene constante, los costos esperados de búsqueda son constantes, y no dependen de&nbsp;<span class="math inline">n</span> y&nbsp;<span class="math inline">m</span> por separado, sino de su cuociente&nbsp;<span class="math inline">\alpha</span>.</p>
<p>Una debilidad de muchas tablas de hashing es que su peor caso puede ser muy malo. En el caso de las tablas de hashing con encadenamiento, el peor caso se da cuando todas las llaves caen en el mismo casillero, y en ese caso los costos de búsqueda serían&nbsp;<span class="math inline">\Theta(n)</span>, porque la estructura degenera a una simple lista lineal.</p>
<p>Sin embargo, una buena función de hashing hace que ese peor caso sea extremadamente improbable, de modo que en la práctica no hay problema en confiar en que el costo observado será cercano al costo esperado que predice el modelo.</p>
<p>La <em>eliminación</em> de una llave es sencilla, porque basta desenlazarla de la lista en que se encuentra.</p>
</section>
<section id="hashing-con-direccionamiento-abierto" class="level2">
<h2>Hashing con Direccionamiento abierto</h2>
<p>Otra forma de resolver colisiones es disponer de una <em>secuencia</em> de funciones de hashing&nbsp;<span class="math inline">\{ h_0(x), h_1(x),\ldots\}</span>, donde cada valor es distinto de todos los anteriores. Para insertar una nueva llave primero se prueba en el casillero&nbsp;<span class="math inline">h_0(x)</span>, si está ocupado se intenta en&nbsp;<span class="math inline">h_1(x)</span> y así sucesivamente. Para hacer una búsqueda, se sigue el mismo itinerario.</p>
<p>Lo anterior en realidad define una familia de métodos, los cuales dependen de cómo se defina esa secuencia de funciones de hashing. A continuación veremos los dos más importantes.</p>
</section>
<section id="linear-probing" class="level2">
<h2>Linear Probing</h2>
<p>Este es un método muy sencillo, que consiste en probar primero en el casillero&nbsp;<span class="math inline">h(x)</span>, y si está ocupado, continuar buscando secuencialmente hacia la derecha, hasta encontrar un lugar libre. Si llegamos al extremo derecho de la tabla, continuamos en el extremo izquierdo, como si la tabla fuera circular.</p>
<p>Más formalmente, la secuencia de funciones de hashing se define como</p>
<p><span class="math display">
\begin{align}
h_0(x) &amp; = h(x)\\
h_{i+1}(x) &amp; = (h_i(x)+1) \bmod m
\end{align}
</span></p>
<figure>
<img src="recursos/LinearProbing.gif" alt="LinearProbing" /><figcaption aria-hidden="true">LinearProbing</figcaption>
</figure>
<hr />
<section id="ejercicio-6.3-inserciones-en-una-tabla-de-hashing-con-linear-probing" class="level3">
<h3>Ejercicio 6.3 (Inserciones en una tabla de hashing con Linear Probing)</h3>
<p>Suponga que se tiene una tabla de hashing con Linear Probing, de tamaño 10, inicialmente vacía, con la función de hashing&nbsp;<span class="math inline">h(x) = x \bmod 10</span> (por ejemplo,&nbsp;<span class="math inline">h(64)=4</span>). Muestre en la siguiente tabla el resultado de insertar (a mano) la siguiente secuencia de llaves:</p>
<pre><code>34, 59, 45, 27, 14, 22, 75, 25</code></pre>
<figure>
<img src="recursos/EjercicioLinearProbing.png" alt="EjercicioLinearProbing" /><figcaption aria-hidden="true">EjercicioLinearProbing</figcaption>
</figure>
<p>Utilizaremos la siguiente función para ver si su respuesta está correcta:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chequea_tabla(lista):</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    h<span class="op">=</span><span class="dv">0</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> lista:</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> (h<span class="op">*</span><span class="dv">100</span><span class="op">+</span>x) <span class="op">%</span> <span class="dv">100000007</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;OK&quot;</span> <span class="cf">if</span> h<span class="op">==</span><span class="dv">60375958</span> <span class="cf">else</span> <span class="st">&quot;Error&quot;</span>)</span></code></pre></div>
<p>En el siguiente recuadro reemplace la lista de ceros por la lista de los elementos resultantes en la tabla. Si un casillero queda vacío, escriba un cero.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>chequea_tabla([<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</span></code></pre></div>
<pre><code>Error</code></pre>
<hr />
<p>El análisis de este método de Linear Probing es complicado, por lo que solo daremos los resultados.</p>
<p>Para una tabla&nbsp;<span class="math inline">\alpha</span>-llena, tenemos que</p>
<p><span class="math display">
\begin{align}
C&#39;_n &amp; \approx \frac{1}{2}\left(1+\frac{1}{(1-\alpha)^2} \right) \\
C_n &amp; \approx \frac{1}{2}\left(1+\frac{1}{1-\alpha} \right)
\end{align}
</span></p>
<p>En el caso de una tabla llena (<span class="math inline">\alpha\to 1</span>), estas fórmulas no nos sirven, porque los denominadores tienden a cero. Se puede hacer obtener fórmulas precisas para ese caso, esto es, para el caso&nbsp;<span class="math inline">n=m</span> cuando la búsqueda es exitosa, o&nbsp;<span class="math inline">n=m-1</span> para una búsqueda infructuosa o inserción (porque en ambos casos debe haber al menos un casillero vacío):</p>
<p><span class="math display">
\begin{align}
C&#39;_{m-1} &amp; = \Theta(m) \\
C_m &amp; = \Theta(\sqrt{m})
\end{align}
</span></p>
<p>Cuando una tabla de hashing con Linear Probing se va acercando a estar llena, el método se vuelve muy lento:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\alpha</span></th>
<th><span class="math inline">C_n</span></th>
<th><span class="math inline">C&#39;_n</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.6</td>
<td>1.75</td>
<td>3.63</td>
</tr>
<tr class="even">
<td>0.7</td>
<td>2.17</td>
<td>6.06</td>
</tr>
<tr class="odd">
<td>0.8</td>
<td>3.00</td>
<td>13.00</td>
</tr>
<tr class="even">
<td>0.9</td>
<td>5.50</td>
<td>50.50</td>
</tr>
<tr class="odd">
<td>0.99</td>
<td>50.50</td>
<td>5000.50</td>
</tr>
<tr class="even">
<td>0.999</td>
<td>500.50</td>
<td>500000.50</td>
</tr>
</tbody>
</table>
<p>Si observamos la tabla a medida que se va llenando, veremos que empiezan a aparecer bloques (<em>clusters</em>) de casilleros ocupados.</p>
<figure>
<img src="recursos/clusters.gif" alt="clusters" /><figcaption aria-hidden="true">clusters</figcaption>
</figure>
<p>Idealmente, querríamos que los <em>clusters</em> fueran pequeños, porque así una llave que viene llegando necesita recorrer un camino corto hasta encontrar un casillero vacío. Pero en realidad ocurre todo lo contrario. En efecto, si la función de hashing distribuye los elementos uniformemente dentro de la tabla, <em>la probabilidad que un cluster crezca es proporcional a su tamaño</em>. Esto implica que una mala situación se vuelve peor cada vez con mayor probabilidad. Sin embargo, este no es todo el problema. La situación empeora cuando dos clusters están separados solo por un casillero libre y ese casillero es ocupado por la llave entrante: ambos clusters se fusionan en uno mucho más grande.</p>
<p>Otro problema que surge con linear probing es conocido como <em>clustering secundario</em>: si al realizar la búsqueda de dos elementos en la tabla se encuentran con el mismo casillero ocupado, entonces toda la búsqueda subsiguiente es la misma para ambos elementos.</p>
<p>El peor caso de Linear Probings es muy malo, y también increíblemente improbable. Se da cuando todas las llaves colisionan en un solo casillero, y en ese caso la estructura degenera a una simple búsqueda secuencial, con costos de búsqueda&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Respecto de la eliminación de elementos, es importante notar que no se puede eliminar un elemento y simplemente dejar su casillero vacío, puesto que las búsquedas terminarían en dicho casillero. Existen dos maneras para eliminar elementos de la tabla:</p>
<ul>
<li>Marcar el casillero como “eliminado,” pero sin liberar el espacio (excepto cuando se necesita para una inserción). Esto produce que las búsquedas puedan ser lentas incluso si el factor de carga de la tabla es pequeño.</li>
<li>Eliminar el elemento, liberar el casillero y mover elementos dentro de la tabla hasta que un casillero “verdaderamente” libre sea encontrado. Implementar esta operación es complejo y costoso.</li>
</ul>
</section>
</section>
<section id="hashing-doble" class="level2">
<h2>Hashing Doble</h2>
<p>Este es un método que evita el problema del clustering secundario, reemplazándolo por clustering terciario, que afecta menos el desempeño.</p>
<p>La idea es generar la secuencia de funciones de hashing usando <strong>dos</strong> funciones de hashing independientes:&nbsp;<span class="math inline">h(x)</span> y&nbsp;<span class="math inline">s(x)</span> (“step”), tales que&nbsp;<span class="math inline">h(x) \in [0..m-1]</span> y&nbsp;<span class="math inline">s(x) \in [1..m-1]</span>. Si el casillero&nbsp;<span class="math inline">h(x)</span> está ocupado, se intenta en&nbsp;<span class="math inline">h(x)+s(x)</span>,&nbsp;<span class="math inline">h(x)+2s(x)</span> y así sucesivamente, todo esto módulo el tamaño de la tabla.</p>
<p>Más precisamente,</p>
<p><span class="math display">
\begin{align}
h_0(x) &amp; = h(x)\\
h_{i+1}(x) &amp; = (h_i(x)+s(x)) \bmod m
\end{align}
</span></p>
<p>Si&nbsp;<span class="math inline">s(x)</span> fuera mayor que 1 y divisor de&nbsp;<span class="math inline">m</span>, la secuencia se repetiría después de&nbsp;<span class="math inline">m/s(x)</span> pasos, sin haber visitado todos los casilleros de la tabla. Para evitar esto, se debe escoger&nbsp;<span class="math inline">m</span> como un número <strong>primo</strong>.</p>
<p>El análisis exacto de la eficiencia de este método es muy complicado, pero se obtienen buenos resultados usando modelos idealizados, ya sea suponiendo que la tabla se recorre usando muestreo sin reemplazo (llamado <em>uniform probing</em>) o muestreo con reemplazo (llamado <em>random probing</em>). Bajo estos modelos, se obtiene que los costos esperados de búsqueda para una tabla&nbsp;<span class="math inline">\alpha</span>-llena son:</p>
<p><span class="math display">
\begin{align}
C&#39;_n &amp; \approx \frac{1}{1-\alpha} \\
C_n &amp; \approx \frac{1}{\alpha}\ln{\frac{1}{1-\alpha}}
\end{align}
</span></p>
<p>Para una tabla llena, tenemos:</p>
<p><span class="math display">
\begin{align}
C&#39;_{m-1} &amp; = \Theta(m) \\
C_m &amp; = \Theta(\log{m})
\end{align}
</span></p>
<p>La siguiente tabla muestra que este método se desempeña mejor que Linear Probing desde el punto de vista del número esperado de comparaciones:</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\alpha</span></th>
<th><span class="math inline">C_n</span></th>
<th><span class="math inline">C&#39;_n</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.6</td>
<td>1.53</td>
<td>2.50</td>
</tr>
<tr class="even">
<td>0.7</td>
<td>1.72</td>
<td>3.33</td>
</tr>
<tr class="odd">
<td>0.8</td>
<td>2.01</td>
<td>5.00</td>
</tr>
<tr class="even">
<td>0.9</td>
<td>2.56</td>
<td>10.00</td>
</tr>
<tr class="odd">
<td>0.99</td>
<td>4.65</td>
<td>100.00</td>
</tr>
<tr class="even">
<td>0.999</td>
<td>6.91</td>
<td>1000.00</td>
</tr>
</tbody>
</table>
<p>El peor caso de Hashing Doble es muy malo, pero incluso más improbable que el de Linear Probing. Se da cuando todas las llaves colisionan en un solo casillero y además todas tienen el mismo valor de&nbsp;<span class="math inline">s(x)</span>, en cuyo caso la estructura degenera a una simple búsqueda secuencial, con costos de búsqueda&nbsp;<span class="math inline">\Theta(n)</span>.</p>
<p>Respecto de las eliminaciones, la única posibilidad es marcar el elemento como “eliminado,” con lo cual se considera ocupado para efecto de las búsquedas, pero libre para efectos de una inserción. Esto funciona, pero estos elementos contaminan la tabla y hacen que las búsquedas sean más lentas incluso cuando el factor de carga efectivo es bajo.</p>
<p>Cuando dos llaves colisionan, el método de inserción le da preferencia a la que llegó primero (a este método se le llama también <em>First-Come-First-Served</em>, o <em>FCFS</em>), pero en realidad cualquiera de las dos llaves podría ocupar el casillero en disputa, y la otra tendría que buscar en otro lugar.</p>
<p>A partir de esta observación, existen heurísticas para resolver el problema de las colisiones en hashing con direccionamiento abierto, como por ejemplo <em>Last-Come-First-Served</em> o <em>LCFS</em> hashing (el elemento que se mueve de casillero no es el que se inserta sino el que ya lo ocupaba) y <em>Robin Hood</em> hashing (el elemento que se queda en el casillero es aquel que se encuentre más lejos de su posición original), que si no cambian el promedio del costo de búsqueda con respecto al método original <em>FCFS</em>, sí disminuyen dramáticamente su varianza.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
</section>
</section>

<div id="lastupdate">
Last updated: jue mar  4 15:11:49 -05 2021
</div>
</article>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</body>
</html>
